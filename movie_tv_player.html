<!DOCTYPE html>
<html lang="en" data-theme="jspecial">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta http-equiv="Permissions-Policy" content="fullscreen=*">
    <title>GlitchBox - Stream Movies & TV Shows</title>

    <!-- IMPORTANT: Define all onclick handler functions FIRST before any HTML is parsed -->
    

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- <script src="https://fpyf8.com/88/tag.min.js" data-zone="178035" async data-cfasync="false"></script> -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABKgAwAEAAAAAQAAABIAAAAAqSaGYgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAuFJREFUOBGdk01MU0EQx//zHv1UCNFSadVEbfmoit7kYFJivGjSGJRo4tnEgzcSo4l68ISRgwY/iMrBm5goiUD04EHF6MX4RYJRaUUCJRa11iKvBfrejrut1WLohUk23Tc789v9z0yBZVoq1VptJENG5megUyEqlsNh3mL/PDpyqbNT2BvqcSCTDobKgqLR5iobflx0u631YMDIAG43wBYQ/zxnI4iWx48EVVdRwOVCYEkQM9O3qcbb7e3W3oYGxo5mwulTjBMnCd+/Mfr7BTo6CE6n1EPA/ByXl0YkfIkEo7KSkUoBsZhAMqlh+itjbIxhmqQYf01TO6m5lrl+B3ODX30TEcuV0+SpzQY4HIDa2+2FpesFH5WQKoxk8Mhg38KhmV/mbr9PKhqve+n36TcNw3RWSOEf3sunzwOyDhgaYhizgBBAby8wa6hL1dWya0zmwUSCtvb1QZ+YELU+n4hEImZkMs4cjzPSaQn7yPlCDz3hfKK64NYtAUsWnvKaJGjlqvE9nK0Lt7XxsZEREX7wgH3d3YzZWSbVJSVNGcvOFffqW8nNZguvczioUGxyRZ/Ks6ecWbc23OJsDQbEmRs9onZ6mhclK0CpKVlr/QTT0gcWtZ/c8SkZeJWzwXe1Puru6rJCo6OytTKqWItSkC5lBYNSlosvLAIVg8gVe8Ic2Ffj1XvOnxM7X70WNlXgUltYAMJhDdu2a8+l/82SIJVA9CnGvGHvtev6q8tXeHPiC+dHoAizJLixkb6u9mj3iKIzZUEqITGpHR4cYM8aL8FbU0QUCi+E9Hm19EKOYuqkPEh2Wp/i9rt32Pt2uFAnlaBavnEjsGsXYXjYqmvdz0el+96fKVAh/xlBTjdMNSdqqotLFT6ZBB4+FIUGMJsqs/yL5CGLimdNTWa9x8MrFKhoaqZyOfmyTfQd0F8of8m/pRj27/css3Y8tXXEYbdCuZzMLgl3OgmZLN9fuepDRGX8BhlxI/bfEI5JAAAAAElFTkSuQmCC') 0 0, auto !important;
        }

        body {
            font-family: 'VT323', monospace;
            background: #1a1a2e;
            background-image:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.2) 2px, rgba(0, 0, 0, 0.2) 4px),
                linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            background-attachment: fixed;
            color: #e0e0e0;
            line-height: 1.6;
            font-weight: 400;
            min-height: 100vh;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-align: center;
            margin-bottom: 48px;
            padding: 32px 20px;
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }

        .header p {
            font-size: 1.5rem;
            line-height: 1.4;
            color: #00d9ff;
            margin-top: 12px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            line-height: 1.4;
            margin-bottom: 16px;
            color: #00ff9f;
            text-shadow:
                3px 3px 0 #ff00ff,
                6px 6px 0 rgba(0, 0, 0, 0.3),
                0 0 20px rgba(0, 255, 159, 0.5);
            animation: glitch 3s infinite;
        }

        @keyframes glitch {
            0%, 90%, 100% {
                transform: translate(0);
            }
            92% {
                transform: translate(-2px, 2px);
            }
            94% {
                transform: translate(2px, -2px);
            }
            96% {
                transform: translate(-2px, -2px);
            }
            98% {
                transform: translate(2px, 2px);
            }
        }

        .search-section {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 32px;
            margin-bottom: 32px;
            position: relative;
            z-index: 1000;
        }

        .search-box {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-input {
            font-family: 'VT323', monospace;
            width: 100%;
            padding: 14px 16px;
            background: #1a1a2e;
            border: 3px solid #00d9ff;
            color: #00ff9f;
            font-size: 24px;
            transition: all 0.2s;
            box-shadow:
                inset 2px 2px 0 rgba(0, 0, 0, 0.3),
                0 0 10px rgba(0, 217, 255, 0.3);
        }

        .search-input:focus {
            outline: none;
            border-color: #00ff9f;
            background: #16213e;
            box-shadow:
                inset 2px 2px 0 rgba(0, 0, 0, 0.3),
                0 0 15px rgba(0, 255, 159, 0.5);
            color: #00ff9f;
        }

        .search-input::placeholder {
            color: #4a5568;
        }

        .search-container {
            position: relative;
            flex: 1;
            z-index: 100001;
        }

        .search-autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(29, 29, 31, 0.98);
            backdrop-filter: saturate(180%) blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-top: 8px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 100002;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: none;
        }

        .search-autocomplete::-webkit-scrollbar {
            width: 8px;
        }

        .search-autocomplete::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .search-autocomplete::-webkit-scrollbar-thumb {
            background: rgba(0, 122, 255, 0.5);
            border-radius: 4px;
        }

        .search-autocomplete::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 122, 255, 0.7);
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background: rgba(145, 70, 255, 0.2);
        }

        .autocomplete-poster {
            width: 40px;
            height: 60px;
            object-fit: cover;
            border-radius: 4px;
        }

        .autocomplete-info {
            flex: 1;
        }

        .autocomplete-title {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }

        .autocomplete-meta {
            color: #888;
            font-size: 12px;
            margin-top: 4px;
        }

        .year-input {
            width: 120px;
            padding: 16px 20px;
            background: rgba(58, 58, 60, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #f5f5f7;
            font-size: 17px;
            font-weight: 400;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(20px);
        }

        .btn {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: var(--primary-color, #00ff9f);
            border: 2px solid var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            font-size: 20px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 159, 0.3);
            text-decoration: none;
            text-align: center;
        }

        .btn:hover {
            background: rgba(0, 255, 159, 0.1);
            color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bg-dark, #0f0f1e);
            color: var(--primary-color, #00ff9f);
            border: 2px solid var(--primary-color, #00ff9f);
        }

        .btn-secondary:hover {
            background: rgba(0, 255, 159, 0.1);
            color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .btn-secondary:active {
            transform: translateY(0);
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .content-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        @media (min-width: 1400px) {
            .content-results {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 28px;
            }
        }

        .content-card {
            background: var(--bg-dark, #0f0f1e);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.1s;
            border: 3px solid var(--accent-color, #00d9ff);
            position: relative;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .content-card:hover {
            transform: translate(-3px, -3px);
            border-color: var(--primary-color, #00ff9f);
            box-shadow:
                9px 9px 0 rgba(0, 0, 0, 0.5),
                0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .content-card:hover .watchlist-btn {
            /* Watchlist button is always visible */
        }

        .content-card:hover .genre-overlay {
            opacity: 1;
        }

        .omdb-ratings-tooltip {
            font-family: 'VT323', monospace;
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.98);
            border: 2px solid var(--primary-color, #00ff9f);
            padding: 14px 18px;
            z-index: 100;
            min-width: 200px;
            max-width: 75%;
            box-shadow:
                0 0 0 2px var(--bg-medium, #1a1a2e),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
            pointer-events: none;
            display: none;
        }

        .content-card:hover .omdb-ratings-tooltip {
            display: block !important;
        }

        .tooltip-loading {
            color: #00d9ff;
            font-size: 17px;
            text-align: center;
        }

        .tooltip-rating-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 7px 0;
            border-bottom: 1px solid #00d9ff;
        }

        .tooltip-rating-row:last-child {
            border-bottom: none;
        }

        .tooltip-rating-source {
            color: #00d9ff;
            font-size: 17px;
            font-weight: 500;
        }

        .tooltip-rating-value {
            color: #00ff9f;
            font-size: 17px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 159, 0.5);
        }

        .content-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
        }

        .content-info {
            padding: 15px;
        }

        .content-title {
            font-weight: 600;
            font-size: 19px;
            margin-bottom: 5px;
            line-height: 1.3;
            color: var(--primary-color, #00ff9f);
        }

        .content-year {
            color: var(--accent-color, #00d9ff);
            font-size: 17px;
            margin-bottom: 8px;
        }

        .content-genres {
            color: #888;
            font-size: 16px;
            margin-top: 4px;
            line-height: 1.3;
        }

        .card-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 5;
        }

        .card-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color, #00ff9f), var(--accent-color, #00d9ff));
            transition: width 0.3s ease;
            box-shadow: 0 0 8px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .content-type-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: var(--primary-color, #00ff9f);
            padding: 4px 8px;
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .content-rating-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            color: #FFD700;
            padding: 4px 10px;
            border: 2px solid #FFD700;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .content-runtime-badge {
            position: absolute;
            top: 45px;
            left: 10px;
            background: rgba(0,0,0,0.85);
            color: var(--accent-color, #00d9ff);
            padding: 4px 10px;
            border: 2px solid var(--accent-color, #00d9ff);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
            font-family: 'VT323', monospace;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .content-card:hover .content-rating-badge,
        .content-card:hover .content-runtime-badge {
            opacity: 1;
        }

        .imdb-btn {
            position: absolute;
            bottom: 67px;
            right: 10px;
            background: #F5C518;
            color: #000;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            text-decoration: none;
            display: none;
            align-items: center;
            gap: 4px;
            transition: all 0.3s;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .content-card:hover .imdb-btn {
            display: flex;
        }

        .imdb-btn:hover {
            background: #FFD93D;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(245, 197, 24, 0.5);
        }

        .genre-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 70%, transparent 100%);
            padding: 40px 15px 15px 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .genre-text {
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            line-height: 1.4;
            text-align: center;
        }

        .tv-badge {
            background: #ff6b6b;
        }

        .movie-badge {
            background: #4ecdc4;
        }

        .player-section {
            background: var(--bg-dark, #0f0f1e);
            border: none;
            border-bottom: 2px solid var(--primary-color, #00ff9f);
            padding: 32px;
            margin-bottom: 32px;
            box-shadow: none;
            position: relative;
        }

        .backdrop-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1;
            pointer-events: none;
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }

        .backdrop-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(15, 15, 30, 0.4) 0%,
                rgba(15, 15, 30, 0.6) 50%,
                rgba(15, 15, 30, 0.8) 100%
            );
            backdrop-filter: blur(2px);
        }

        .backdrop-image.loaded {
            opacity: 1;
        }

        .player-bg-animation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            overflow: hidden;
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }

        .current-content > *:not(.backdrop-image):not(.player-bg-animation) {
            position: relative;
            z-index: 2;
        }

        .player-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: #000000;
            overflow: hidden;
            margin-bottom: 24px;
            border: none;
            box-shadow: none;
        }

        .player-container:fullscreen,
        .player-container:-webkit-full-screen,
        .player-container:-moz-full-screen,
        .player-container:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            margin: 0;
            border: none;
            box-shadow: none;
        }

        .player-container:fullscreen iframe,
        .player-container:-webkit-full-screen iframe,
        .player-container:-moz-full-screen iframe,
        .player-container:-ms-fullscreen iframe {
            width: 100%;
            height: 100%;
            border: none;
            box-shadow: none;
        }

        .player-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 18px;
            text-align: center;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Fullscreen styles for iframe itself (mobile support) */
        iframe:fullscreen,
        iframe:-webkit-full-screen,
        iframe:-moz-full-screen,
        iframe:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            border: none;
            box-shadow: none;
        }

        .current-content {
            display: grid;
            grid-template-columns: 1fr auto;
            grid-template-rows: auto 1fr;
            gap: 20px;
            align-items: start;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            padding: 20px;
        }

        .poster-container {
            position: static !important;
            grid-column: 2 !important;
            grid-row: 1 / span 2 !important;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 0;
            align-self: start;
            justify-self: end;
            order: 2;
        }

        .current-content-poster {
            width: 200px;
            height: 300px;
            object-fit: cover;
            border-radius: 8px;
            background: #333;
            border: 3px solid var(--accent-color, #00d9ff);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .poster-container #playerWatchlistBtn {
            width: 100%;
        }

        .current-content-info {
            grid-column: 1 !important;
            grid-row: 1 / span 2 !important;
            display: flex;
            flex-direction: column;
            gap: 16px;
            order: 1;
            min-width: 0;
            overflow: hidden;
        }

        .current-content-info h3 {
            font-family: 'VT323', monospace;
            margin: 0 0 4px 0;
            color: var(--primary-color, #00ff9f);
            text-shadow:
                2px 2px 0 var(--accent-color, #00d9ff),
                4px 4px 0 rgba(0, 0, 0, 0.3);
            font-weight: 600;
            font-size: 36px;
        }

        .current-content-info p {
            font-family: 'VT323', monospace;
            color: var(--accent-color, #00d9ff);
            font-size: 24px;
            margin: 0;
        }

        /* --- User & friends ratings (UI) --- */
.rating-item.user-pill {
  display:flex; align-items:center; gap:8px; padding:8px 12px;
  border-radius:8px; background:rgba(255,255,255,0.06);
  border:1px solid rgba(255,255,255,0.12);
}
.rating-item.user-pill input[type="number"]{
  width:84px; padding:6px 8px; border-radius:6px;
  border:1px solid rgba(255,255,255,0.25); background:transparent; color:inherit;
}
.rating-item.user-pill .post-btn{
  padding:6px 10px; border-radius:6px;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.08); cursor:pointer;
  font-family:'VT323', monospace; font-size:18px;
  color:var(--primary-color, #00ff9f);
  transition:all 0.2s;
  box-shadow:0 0 10px rgba(255,255,255,0.15);
  margin-left:8px;
  margin-right:8px;
}
.rating-item.user-pill .post-btn:hover{
  background:rgba(255,255,255,0.12);
  box-shadow:0 0 15px rgba(255,255,255,0.25);
}
.rating-item.user-pill .post-btn:active{
  transform:scale(0.98);
}
.friends-ratings{ display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
.friend-pill{
  padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.15);
  background:rgba(255,255,255,0.04); font-size:14px; opacity:0.9;
}
.friend-pill b{ margin-left:4px; }

        /* OMDB Ratings Styles */
        .omdb-ratings {
            margin: 0;
            width: 100%;
        }

        .ratings-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .rating-item {
            font-family: 'VT323', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 20px;
            background: rgba(0, 122, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            min-width: 100px;
            transition: all 0.1s;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
        }

        .rating-item:hover {
            transform: translate(-2px, -2px);
            border-color: var(--primary-color, #00ff9f);
            box-shadow:
                5px 5px 0 rgba(0, 0, 0, 0.4),
                0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .rating-source {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent-color, #00d9ff);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .rating-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary-color, #00ff9f);
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        /* OMDB Details Styles */
        .omdb-details {
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 16px;
            background: rgba(0, 122, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        .detail-item {
            color: #f5f5f7;
            font-size: 20px;
            margin-bottom: 8px;
            line-height: 1.5;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .detail-item strong {
            color: var(--accent-color, #00d9ff);
            font-weight: 600;
            margin-right: 8px;
        }

        .detail-item span {
            color: #e5e5e7;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .detail-item.awards span {
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            font-weight: 600;
        }

        /* Cast Grid Styles */
        .cast-section {
            margin: 0;
            padding: 16px;
            background: rgba(0, 122, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-top: 12px;
        }

        .cast-member {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s ease;
            min-width: 0;
            overflow: hidden;
            padding: 8px;
        }

        .cast-member:hover {
            transform: translateY(-4px);
        }

        .cast-member-image {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid var(--primary-color, #00ff9f);
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.4));
            object-fit: cover;
            margin-bottom: 8px;
            background: var(--bg-dark, #0f0f1e);
        }

        .cast-member-image.placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: var(--primary-color, #00ff9f);
            background: var(--bg-medium, #1a1a2e);
        }

        .cast-member-name {
            font-family: 'VT323', monospace;
            font-size: 22px;
            color: var(--primary-color, #00ff9f);
            font-weight: 600;
            margin-bottom: 4px;
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .cast-member-character {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--accent-color, #00d9ff);
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        /* Episode Description Styles */
        .episode-description {
            margin: 0;
            padding: 16px;
            background: rgba(0, 122, 255, 0.05);
            border-radius: 8px;
            width: 100%;
        }

        #episodeDescriptionText {
            font-family: 'VT323', monospace;
            font-size: 26px;
            line-height: 1.6;
            color: #e5e5e7;
            margin: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        #currentOverview {
            font-family: 'VT323', monospace;
            font-size: 26px;
            line-height: 1.6;
            color: #e5e5e7;
            margin: 0;
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        .tv-controls {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 122, 255, 0.05) 0%, rgba(88, 86, 214, 0.05) 50%, rgba(175, 82, 222, 0.05) 100%);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
            text-align: center;
            width: 100%;
        }

        .season-selector,
        .episode-selector {
            font-family: 'VT323', monospace;
            width: 200px;
            padding: 14px 18px;
            background: var(--bg-dark, #0f0f1e);
            border: 4px solid var(--primary-color, #00ff9f);
            border-style: solid;
            color: var(--primary-color, #00ff9f);
            font-size: 24px;
            font-weight: 600;
            margin: 8px 8px 8px 0;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow:
                4px 4px 0 var(--primary-glow, rgba(0, 255, 159, 0.3)),
                inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.4));
            image-rendering: pixelated;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .season-selector::before,
        .episode-selector::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            width: 4px;
            height: 4px;
            background: #00ff9f;
            box-shadow:
                calc(100% + 2px) 0 0 #00ff9f,
                0 calc(100% + 2px) 0 #00ff9f,
                calc(100% + 2px) calc(100% + 2px) 0 #00ff9f;
        }

        .episode-selector {
            width: 320px;
        }

        .season-selector:focus,
        .episode-selector:focus {
            outline: none;
            border-color: var(--secondary-color, #ff00ff);
            background: var(--bg-light, #16213e);
            box-shadow:
                4px 4px 0 var(--secondary-glow, rgba(255, 0, 255, 0.4)),
                inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                0 0 25px var(--secondary-glow, rgba(255, 0, 255, 0.6));
            animation: pulse-glow 1s ease-in-out infinite;
        }

        .season-selector:hover,
        .episode-selector:hover {
            border-color: var(--accent-color, #00d9ff);
            background: var(--bg-medium, #1a1a2e);
            box-shadow:
                4px 4px 0 rgba(0, 217, 255, 0.4),
                inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 217, 255, 0.5);
        }

        .episode-selector {
            max-height: 500px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00ff9f #0f0f1e;
        }

        .episode-selector::-webkit-scrollbar {
            width: 12px;
        }

        .episode-selector::-webkit-scrollbar-track {
            background: var(--bg-dark, #0f0f1e);
            border: 3px solid var(--accent-color, #00d9ff);
        }

        .episode-selector::-webkit-scrollbar-thumb {
            background: var(--primary-color, #00ff9f);
            border: 2px solid var(--primary-color, #00ff9f);
            box-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .episode-selector::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color, #00d9ff);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.7);
        }

        .episode-selector option,
        .season-selector option {
            padding: 14px 16px !important;
            background: #0f0f1e !important;
            background-color: #0f0f1e !important;
            border-bottom: 2px solid #00d9ff !important;
            min-height: 55px;
            color: #00ff9f !important;
            font-weight: 500 !important;
            font-family: 'VT323', monospace !important;
            font-size: 22px !important;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5) !important;
            border-left: none !important;
            border-right: none !important;
            border-top: none !important;
        }

        .episode-selector option:hover,
        .season-selector option:hover {
            background: #1a1a2e !important;
            background-color: #1a1a2e !important;
            color: #00d9ff !important;
            text-shadow: 0 0 8px rgba(0, 217, 255, 0.8), 2px 2px 0 rgba(0, 0, 0, 0.5) !important;
            box-shadow: inset 0 0 20px rgba(0, 217, 255, 0.3) !important;
        }

        .episode-selector option:checked,
        .season-selector option:checked {
            background: #00ff9f !important;
            background-color: #00ff9f !important;
            color: #0f0f1e !important;
            font-weight: 700 !important;
            text-shadow: 1px 1px 0 rgba(0, 217, 255, 0.5) !important;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3) !important;
        }

        .episode-selector option:active,
        .season-selector option:active {
            background: #00ff9f !important;
            background-color: #00ff9f !important;
            color: #0f0f1e !important;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow:
                    4px 4px 0 rgba(255, 0, 255, 0.4),
                    inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                    0 0 25px rgba(255, 0, 255, 0.6);
            }
            50% {
                box-shadow:
                    4px 4px 0 rgba(255, 0, 255, 0.4),
                    inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                    0 0 35px rgba(255, 0, 255, 0.8);
            }
        }

        .player-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: visible;
        }

        .loading {
            font-family: 'VT323', monospace;
            text-align: center;
            color: var(--primary-color, #00ff9f);
            font-size: 24px;
            padding: 20px;
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .error {
            font-family: 'VT323', monospace;
            background: var(--bg-medium, #1a1a2e);
            border: 3px solid #FF453A;
            color: #FF453A;
            padding: 16px 20px;
            margin: 12px 0;
            font-size: 20px;
            box-shadow:
                inset 1px 1px 0 rgba(0, 0, 0, 0.3),
                0 0 15px rgba(255, 69, 58, 0.4);
        }

        .status-bar {
            font-family: 'VT323', monospace;
            background: var(--bg-medium, #1a1a2e);
            padding: 12px 20px;
            margin-bottom: 24px;
            font-size: 22px;
            color: var(--primary-color, #00ff9f);
            border: 2px solid var(--accent-color, #00d9ff);
            box-shadow:
                inset 1px 1px 0 rgba(0, 0, 0, 0.3),
                0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            font-family: 'VT323', monospace;
            padding: 10px 20px;
            background: var(--bg-medium, #1a1a2e);
            border: 3px solid var(--accent-color, #00d9ff);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 22px;
            font-weight: 400;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .tab.active {
            background: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            border-color: var(--primary-color, #00ff9f);
            border-width: 3px;
            box-shadow: 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.8)),
                        inset 0 0 20px rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            font-weight: 600;
        }

        .tab:hover {
            background: var(--bg-light, #16213e);
            color: #fff;
            border-color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .tab.active:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            border-color: var(--accent-color, #00d9ff);
            box-shadow: 0 0 25px var(--secondary-glow, rgba(0, 217, 255, 0.6));
        }

        .section-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            font-weight: 400;
            line-height: 1.6;
            margin-bottom: 24px;
            color: var(--secondary-color, #ff00ff);
            text-shadow:
                2px 2px 0 var(--accent-color, #00d9ff),
                4px 4px 0 rgba(0, 0, 0, 0.3);
        }

        .watchlist-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 2px solid var(--accent-color, #00d9ff);
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
            opacity: 1;
            transform: scale(1);
        }

        .watchlist-btn:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            border-color: var(--accent-color, #00d9ff);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.6));
        }

        .watchlist-btn.added {
            background: var(--primary-color, #00ff9f);
            border-color: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .watchlist-btn.added:hover {
            background: var(--secondary-color, #ff00ff);
            border-color: var(--secondary-color, #ff00ff);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(255, 0, 255, 0.6));
        }

        .continue-watching-section, .watchlist-section {
            background: var(--bg-dark, #0f0f1e);
            border: 3px solid var(--secondary-color, #ff00ff);
            box-shadow:
                0 0 0 3px var(--bg-medium, #1a1a2e),
                0 0 15px var(--secondary-glow, rgba(255, 0, 255, 0.4)),
                inset 0 0 15px var(--secondary-glow, rgba(255, 0, 255, 0.1));
            padding: 32px;
            margin-bottom: 32px;
            position: relative;
        }

        .continue-watching-section::before,
        .continue-watching-section::after,
        .watchlist-section::before,
        .watchlist-section::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--secondary-color, #ff00ff);
            box-shadow: 0 0 8px var(--secondary-color, #ff00ff);
        }

        .continue-watching-section::before,
        .watchlist-section::before {
            top: -3px;
            right: -3px;
        }

        .continue-watching-section::after,
        .watchlist-section::after {
            bottom: -3px;
            left: -3px;
        }

        .horizontal-scroll-container {
            display: none;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        @media (min-width: 1400px) {
            .horizontal-scroll-container {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 28px;
            }
        }

        .continue-item {
            background: var(--bg-dark, #0f0f1e);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.1s;
            border: 3px solid var(--accent-color, #00d9ff);
            position: relative;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
            animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        .continue-item:hover {
            transform: translate(-3px, -3px);
            border-color: var(--primary-color, #00ff9f);
            box-shadow:
                9px 9px 0 rgba(0, 0, 0, 0.5),
                0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .continue-item:hover .watchlist-btn,
        .result-item:hover .watchlist-btn {
            opacity: 1;
            transform: scale(1);
        }

        .continue-item:hover .omdb-ratings-tooltip {
            display: block !important;
        }

        .continue-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            transition: all 0.2s;
        }

        .continue-item:hover .continue-poster {
            filter: brightness(1.1);
        }

        .continue-info {
            padding: 15px;
        }

        .continue-title {
            font-weight: 600;
            font-size: 19px;
            margin-bottom: 5px;
            line-height: 1.3;
            color: var(--primary-color, #00ff9f);
        }

        .continue-progress {
            color: var(--accent-color, #00d9ff);
            font-size: 17px;
            margin-bottom: 8px;
        }

        .continue-last-watched {
            color: #888;
            font-size: 16px;
        }

        .continue-episode-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: var(--accent-color, #00d9ff);
            padding: 4px 8px;
            border: 2px solid var(--accent-color, #00d9ff);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .watchlist-remove-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 68, 68, 0.9);
            color: white;
            border: 2px solid #FF453A;
            width: 48px;
            height: 48px;
            cursor: pointer;
            font-size: 24px;
            transition: all 0.2s;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 0 10px rgba(255, 69, 58, 0.3);
        }

        .continue-item:hover .watchlist-remove-btn {
            display: flex;
        }

        .watchlist-remove-btn:hover {
            background: #FF453A;
            border-color: #FF453A;
            color: white;
            box-shadow: 0 0 15px rgba(255, 69, 58, 0.6);
        }

        .progress-bar {
            width: 100%;
            height: 3px;
            background: rgba(68, 68, 68, 0.5);
            border-radius: 2px;
            overflow: hidden;
            position: absolute;
            bottom: 0;
            left: 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color, #00ff9f), var(--accent-color, #00d9ff));
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .remove-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 16px;
            margin-left: 10px;
        }

        .remove-btn:hover {
            background: #ff6666;
        }

        @media (max-width: 1200px) {
            .container {
                padding: 24px 16px;
            }

            .header h1 {
                font-size: 3rem;
            }

            .search-section,
            .player-section,
            .continue-watching-section,
            .watchlist-section {
                padding: 32px 24px;
            }
        }

        /* Responsive design for content player */
        @media (max-width: 1200px) {
            .current-content {
                padding: 12px;
                gap: 12px;
            }

            .current-content-poster {
                width: 140px;
                height: 210px;
            }

            .current-content-info {
                gap: 12px;
                width: 100%;
            }

            .omdb-details,
            .cast-section,
            .episode-description,
            .tv-controls {
                width: 100%;
                box-sizing: border-box;
            }

            .omdb-details,
            .cast-section,
            .episode-description {
                padding: 12px;
            }

            .cast-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 15px;
            }

            .cast-member {
                padding: 5px;
            }

            .cast-member-name {
                font-size: 18px;
            }

            .cast-member-character {
                font-size: 16px;
            }

            .tv-controls {
                padding: 16px;
            }

            .detail-item {
                font-size: 16px;
                margin-bottom: 6px;
            }

            .tv-controls {
                padding: 12px;
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            .season-selector,
            .episode-selector {
                width: 100%;
                max-width: 100%;
                min-width: unset;
                padding: 10px 14px;
                font-size: 20px;
                margin: 4px 0;
            }

            .bg-animation-toggle {
                padding: 10px 18px;
                font-size: 20px;
                width: 100%;
                max-width: 100%;
                min-width: unset;
                margin: 4px 0;
                box-sizing: border-box;
            }

            #seasonButton,
            #episodeButton {
                width: 100%;
                max-width: 100%;
                min-width: unset !important;
                margin: 4px 0 !important;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.75rem;
            }

            .header p {
                font-size: 0.85rem;
            }

            .user-menu-container {
                top: 12px;
                left: 12px;
            }

            .user-menu-btn {
                padding: 8px 12px;
                font-size: 18px;
                gap: 6px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in {
                padding: 8px 12px;
                font-size: 18px;
                gap: 6px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in #userMenuIcon {
                width: 18px;
                height: 18px;
            }

            #userMenuText {
                font-size: 16px;
                line-height: 1;
            }

            .bg-animation-toggle {
                padding: 8px 12px;
                font-size: 18px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
                padding: 8px 12px;
                font-size: 18px;
                line-height: 1;
            }

            .theme-selector-btn,
            .bg-animation-toggle[onclick*="toggleEffectsPanel"] {
                padding: 8px 12px;
                font-size: 18px;
            }

            /* Top-right and bottom-right button containers */
            div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"] {
                top: 12px !important;
                right: 12px !important;
            }

            /* Bottom-right button container */
            div[style*="position: fixed"][style*="bottom: 20px"][style*="right: 20px"] {
                bottom: 12px !important;
                right: 12px !important;
                gap: 8px !important;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 24px 0;
            }

            .header,
            .search-section,
            .tabs {
                padding-left: 16px;
                padding-right: 16px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header p {
                font-size: 0.75rem;
            }

            .user-menu-container {
                top: 10px;
                left: 10px;
            }

            .user-menu-btn {
                padding: 4px 8px;
                font-size: 14px;
                gap: 3px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in {
                padding: 4px 8px;
                font-size: 14px;
                gap: 3px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in #userMenuIcon {
                width: 14px;
                height: 14px;
            }

            #userMenuText {
                font-size: 12px;
                line-height: 1;
            }

            .bg-animation-toggle {
                padding: 4px 8px;
                font-size: 14px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
                padding: 4px 8px;
                font-size: 14px;
                line-height: 1;
            }

            .theme-selector-btn,
            .bg-animation-toggle[onclick*="toggleEffectsPanel"] {
                padding: 4px 8px;
                font-size: 14px;
            }

            /* Top-right and bottom-right button containers */
            div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"] {
                top: 10px !important;
                right: 10px !important;
            }

            /* Bottom-right button container */
            div[style*="position: fixed"][style*="bottom: 20px"][style*="right: 20px"] {
                bottom: 10px !important;
                right: 10px !important;
                gap: 5px !important;
            }

            .player-section {
                padding: 16px 0;
            }

            .current-content {
                padding: 8px 0;
                gap: 8px;
                grid-template-columns: 1fr;
                display: flex;
                flex-direction: column;
            }
        }

        @media (max-width: 440px) {
            .header h1 {
                font-size: 1.3rem;
            }

            .header p {
                font-size: 0.7rem;
            }

            .user-menu-container {
                top: 8px;
                left: 8px;
            }

            .user-menu-btn {
                padding: 3px 6px;
                font-size: 12px;
                gap: 2px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in {
                padding: 3px 6px;
                font-size: 12px;
                gap: 2px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in #userMenuIcon {
                width: 12px;
                height: 12px;
            }

            #userMenuText {
                font-size: 11px;
                line-height: 1;
            }

            .bg-animation-toggle {
                padding: 3px 6px;
                font-size: 12px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
                padding: 3px 6px;
                font-size: 12px;
                line-height: 1;
            }

            .theme-selector-btn,
            .bg-animation-toggle[onclick*="toggleEffectsPanel"] {
                padding: 3px 6px;
                font-size: 12px;
            }

            /* Top-right and bottom-right button containers */
            div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"] {
                top: 8px !important;
                right: 8px !important;
            }

            /* Bottom-right button container */
            div[style*="position: fixed"][style*="bottom: 20px"][style*="right: 20px"] {
                bottom: 8px !important;
                right: 8px !important;
                gap: 4px !important;
            }
        }

        @media (max-width: 420px) {
            .header {
                margin-top: 40px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .header p {
                font-size: 0.9rem;
            }
        }

        @media (max-width: 410px) {
            .header {
                margin-top: 40px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .header p {
                font-size: 0.9rem;
            }

            .user-menu-container {
                top: 6px;
                left: 6px;
            }

            .user-menu-btn {
                padding: 2px 5px;
                font-size: 11px;
                gap: 2px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in {
                padding: 2px 5px;
                font-size: 11px;
                gap: 2px;
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .user-menu-btn.logged-in #userMenuIcon {
                width: 11px;
                height: 11px;
            }

            #userMenuText {
                font-size: 10px;
                line-height: 1;
            }

            .bg-animation-toggle {
                line-height: 1;
                display: flex;
                align-items: center;
            }

            .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
                padding: 2px 5px;
                font-size: 11px;
                line-height: 1;
            }

            /* Top-right button container */
            div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"] {
                top: 6px !important;
                right: 6px !important;
            }

            .poster-container {
                grid-column: unset !important;
                grid-row: unset !important;
                justify-self: flex-start;
                order: 1;
                padding: 0 16px;
                align-self: flex-start;
            }

            .poster-container #playerWatchlistBtn {
                padding: 6px 12px;
                font-size: 14px;
                width: 100px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .poster-container #playerWatchlistBtn #playerWatchlistBtnText {
                font-size: 14px;
            }

            .current-content-info {
                grid-column: unset !important;
                grid-row: unset !important;
                order: 2;
                gap: 8px;
                width: 100%;
                padding: 0;
                min-width: 0;
            }

            .current-content-poster {
                width: 100px;
                height: 150px;
            }

            .omdb-details,
            .cast-section,
            .episode-description,
            .tv-controls {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                margin: 0;
            }

            .omdb-details {
                padding: 0;
                border-radius: 0;
                background: transparent;
                border: none;
                box-shadow: none;
            }

            .cast-section {
                padding: 16px;
                border-radius: 0;
                margin: 0;
            }

            .episode-description {
                padding: 16px;
                border-radius: 0;
            }

            .omdb-details .detail-item {
                padding-left: 16px;
                padding-right: 16px;
            }

            .current-content-info h3 {
                font-size: 1.3rem;
                text-align: center;
                padding: 0 16px;
            }

            .current-content-info p {
                text-align: center;
                font-size: 18px;
                padding: 0 16px;
            }

            .omdb-ratings {
                width: 100%;
                max-width: 100%;
                margin: 0;
                padding: 0;
            }

            .ratings-container {
                gap: 12px;
                justify-content: center;
                padding: 0 16px;
                width: 100%;
                max-width: 100%;
            }

            .rating-item {
                padding: 8px 16px;
                min-width: 90px;
                flex: 0 1 auto;
            }

            .rating-source {
                font-size: 14px;
            }

            .rating-value {
                font-size: 22px;
            }

            .cast-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 0;
            }

            .cast-member {
                padding: 4px;
            }

            .cast-member-image {
                width: 70px;
                height: 70px;
            }

            .cast-member-name {
                font-size: 15px;
            }

            .cast-member-character {
                font-size: 13px;
            }

            #currentOverview,
            #episodeDescriptionText {
                font-size: 22px;
                line-height: 1.5;
                width: 100%;
                max-width: 100%;
            }

            #currentOverview {
                padding: 0 16px;
            }

            .detail-item {
                font-size: 16px;
                margin-bottom: 6px;
                line-height: 1.5;
            }

            .tv-controls {
                padding: 16px;
                margin: 0;
                display: flex;
                flex-direction: column;
                align-items: stretch;
                border-radius: 0;
            }

            .season-selector,
            .episode-selector {
                width: 100%;
                max-width: 100%;
                min-width: unset;
                padding: 8px 12px;
                font-size: 18px;
                margin: 4px 0;
            }

            .bg-animation-toggle {
                padding: 8px 14px;
                font-size: 18px;
                width: 100%;
                max-width: 100%;
                min-width: unset;
                margin: 4px 0;
                box-sizing: border-box;
            }

            #seasonButton,
            #episodeButton {
                width: 100%;
                max-width: 100%;
                min-width: unset !important;
                margin: 4px 0 !important;
                text-align: left;
            }
        }

        /* Advanced animations and effects */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -468px 0;
            }
            100% {
                background-position: 468px 0;
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .container {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .header {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s both;
        }

        .continue-watching-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.3s both;
        }

        .watchlist-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.4s both;
        }

        .search-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.5s both;
        }

        .player-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.6s both;
        }

        .content-card {
            animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        .content-card:nth-child(2) { animation-delay: 0.1s; }
        .content-card:nth-child(3) { animation-delay: 0.2s; }
        .content-card:nth-child(4) { animation-delay: 0.3s; }
        .content-card:nth-child(5) { animation-delay: 0.4s; }
        .content-card:nth-child(6) { animation-delay: 0.5s; }

        .continue-item {
            animation: slideInFromRight 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        .continue-item:nth-child(2) { animation-delay: 0.1s; }
        .continue-item:nth-child(3) { animation-delay: 0.2s; }
        .continue-item:nth-child(4) { animation-delay: 0.3s; }

        /* Removed white gradient shine effect */

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .content-poster {
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .content-card:hover .content-poster {
            transform: scale(1.05);
        }

        .continue-poster {
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .continue-item:hover .continue-poster {
            transform: scale(1.1);
        }

        .watchlist-btn {
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .content-type-badge {
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .content-card:hover .content-type-badge {
            transform: scale(1.1);
        }

        .status-bar {
            position: relative;
            overflow: hidden;
        }

        .status-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(0, 122, 255, 0) 0%,
                rgba(0, 122, 255, 0.1) 50%,
                rgba(0, 122, 255, 0) 100%);
            animation: shimmer 2s infinite;
        }

        /* Smooth scrolling */
        * {
            scroll-behavior: smooth;
        }

        /* Focus states */
        .btn:focus-visible {
            outline: 2px solid #007AFF;
            outline-offset: 2px;
        }

        .search-input:focus,
        .year-input:focus {
            transform: translateY(-1px);
        }

        /* Glass morphism enhancement */
        .search-section,
        .player-section,
        .continue-watching-section,
        .watchlist-section {
            position: relative;
        }

        .continue-watching-section::before,
        .watchlist-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(135deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.05) 50%,
                rgba(255, 255, 255, 0.02) 100%);
            pointer-events: none;
        }


        /* Progress bar animation */
        .progress-fill {
            position: relative;
            overflow: hidden;
        }

        .progress-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        /* ============= WATCHPARTY STYLES ============= */

        .watchparty-sidebar {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 280px;
            max-width: 50vw;
            height: auto;
            max-height: 50vh;
            background: transparent;
            border: none;
            box-shadow: none;
            transition: all 0.2s;
            z-index: 100000;
            display: none;
            flex-direction: column;
            opacity: 0;
            transform: translateY(10px);
            overflow: hidden;
        }

        .watchparty-sidebar.active {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        .watchparty-sidebar.minimized {
            width: 60px;
            height: 60px;
            max-height: 60px;
            border-radius: 50%;
            overflow: hidden;
        }

        .watchparty-sidebar.minimized .watchparty-header,
        .watchparty-sidebar.minimized .watchparty-users,
        .watchparty-sidebar.minimized .watchparty-chat {
            display: none;
        }

        /* Fullscreen mode - sidebar moves into player */
        .watchparty-sidebar.fullscreen-mode {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2147483647;
            max-height: 50vh;
            pointer-events: auto;
        }

        .watchparty-sidebar.fullscreen-mode .chat-input {
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .watchparty-sidebar.fullscreen-mode * {
            pointer-events: auto;
        }

        .player-container:fullscreen iframe,
        .player-container:-webkit-full-screen iframe,
        .player-container:-moz-full-screen iframe,
        .player-container:-ms-fullscreen iframe,
        .player-container:fullscreen video,
        .player-container:-webkit-full-screen video,
        .player-container:-moz-full-screen video,
        .player-container:-ms-fullscreen video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .watchparty-header {
            padding: 12px;
            border-bottom: 2px solid var(--secondary-color, #ff00ff);
            background: transparent;
            position: relative;
        }

        .watchparty-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            font-weight: 400;
            color: var(--secondary-color, #ff00ff);
            margin: 0;
            text-shadow: 1px 1px 0 var(--accent-color, #00d9ff);
            white-space: nowrap;
        }

        .watchparty-room-code {
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: var(--accent-color, #00d9ff);
            margin: 0;
            white-space: nowrap;
        }

        .room-code-display {
            background: var(--bg-medium, #1a1a2e);
            border: 2px solid var(--primary-color, #00ff9f);
            padding: 4px 8px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 2px;
            color: var(--primary-color, #00ff9f);
            display: inline-block;
            cursor: pointer;
            box-shadow:
                2px 2px 0 rgba(0, 0, 0, 0.4),
                0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .room-code-display:hover {
            background: var(--bg-dark, #0f0f1e);
            transform: translate(1px, 1px);
            box-shadow:
                1px 1px 0 rgba(0, 0, 0, 0.4),
                0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .copy-room-code {
            display: none;
        }

        .watchparty-users {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 100px;
            overflow-y: auto;
        }

        .watchparty-users-title {
            font-size: 10px;
            font-weight: 600;
            color: #a1a1a6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .user-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #007AFF, #5856D6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 11px;
        }

        .user-name {
            flex: 1;
            font-size: 12px;
            color: #f5f5f7;
        }

        .host-badge {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 700;
        }

        .watchparty-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .chat-message {
            display: flex;
            flex-direction: column;
            gap: 3px;
            padding: 8px 12px;
            background: rgba(26, 26, 46, 0.4);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .chat-message:hover {
            background: rgba(26, 26, 46, 0.6);
        }

        .chat-message:nth-child(odd) {
            background: rgba(15, 15, 30, 0.4);
        }

        .chat-message:nth-child(odd):hover {
            background: rgba(15, 15, 30, 0.6);
        }

        .reply-indicator {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 13px;
            color: var(--accent-color, #00d9ff);
            padding: 4px 8px;
            background: var(--secondary-glow, rgba(0, 217, 255, 0.2));
            border-left: 3px solid var(--accent-color, #00d9ff);
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reply-indicator button {
            background: transparent;
            border: none;
            color: var(--secondary-color, #ff00ff);
            cursor: pointer;
            font-size: 18px;
            padding: 0 4px;
            line-height: 1;
        }

        .reply-indicator button:hover {
            color: var(--primary-color, #00ff9f);
        }

        .replying-to {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            color: var(--accent-color, #00d9ff);
            font-style: italic;
            margin-bottom: 2px;
        }

        .chat-message-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chat-username {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 15px;
            font-weight: 600;
        }

        .chat-timestamp {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            color: #999;
        }

        .chat-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            color: #e0e0e0;
            background: transparent;
            border: none;
            padding: 0;
            line-height: 1.4;
        }

        .chat-input-container {
            padding: 12px;
            border-top: none;
            background: transparent;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            flex: 1;
            padding: 8px 12px;
            background: rgba(26, 26, 46, 0.4);
            border: none;
            color: var(--primary-color, #00ff9f);
            font-size: 14px;
            outline: none;
            border-radius: 4px;
        }

        .chat-input:focus {
            background: rgba(22, 33, 62, 0.5);
        }

        .chat-send-btn {
            display: none;
            box-shadow: 1px 1px 0 rgba(0, 0, 0, 0.4);
        }

        .chat-send-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 0 0 0 rgba(0, 0, 0, 0.4);
        }

        .watchparty-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            line-height: 1;
            flex-shrink: 0;
            z-index: 10;
            position: relative;
            pointer-events: auto;
        }

        .watchparty-close:hover {
            background: rgba(255, 59, 48, 0.8);
        }

        .sync-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 122, 255, 0.9);
            padding: 12px 24px;
            border-radius: 24px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            z-index: 99997;
            display: none;
            animation: fadeIn 0.3s;
        }

        .sync-indicator.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* ============= END WATCHPARTY STYLES ============= */

        /* ============= THEME SYSTEM ============= */

        /* Theme Selector Button */
        .theme-selector-btn {
            padding: 10px 16px;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 20px;
            color: var(--primary-color, #00ff9f);
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .theme-selector-btn:hover {
            background: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        /* Theme Selector Panel */
        .theme-selector-panel {
            position: fixed;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 3px solid var(--primary-color, #00ff9f);
            border-radius: 16px;
            padding: 20px;
            z-index: 100000;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-width: 280px;
            box-shadow: 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .theme-selector-panel.active {
            display: flex;
            animation: slideInFromRight 0.3s ease-out;
        }

        .theme-selector-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--primary-color, #00ff9f);
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .theme-option {
            padding: 12px 16px;
            background: rgba(15, 15, 30, 0.6);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .theme-option:hover {
            transform: translateX(5px);
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.8);
        }

        .theme-option.active {
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.9);
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .theme-color-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .theme-name {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #e0e0e0;
        }

        /* Theme: Matrix (Default) - Green/Cyan/Magenta */
        [data-theme="matrix"] {
            --primary-color: #00ff9f;
            --secondary-color: #ff00ff;
            --accent-color: #00d9ff;
            --bg-dark: #0f0f1e;
            --bg-medium: #1a1a2e;
            --bg-light: #16213e;
            --primary-glow: rgba(0, 255, 159, 0.4);
            --secondary-glow: rgba(255, 0, 255, 0.4);
        }

        /* Theme: Hacker - Pure Green Terminal */
        [data-theme="hacker"] {
            --primary-color: #00ff00;
            --secondary-color: #00cc00;
            --accent-color: #33ff33;
            --bg-dark: #000000;
            --bg-medium: #0a0a0a;
            --bg-light: #1a1a1a;
            --primary-glow: rgba(0, 255, 0, 0.4);
            --secondary-glow: rgba(0, 204, 0, 0.4);
        }

        [data-theme="hacker"] body {
            background: #000000;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 0, 0.03) 2px, rgba(0, 255, 0, 0.03) 4px);
            color: #00ff00;
        }

        /* Theme: Sunset - Orange/Pink/Purple */
        [data-theme="sunset"] {
            --primary-color: #ff6b35;
            --secondary-color: #ff006e;
            --accent-color: #ffbe0b;
            --bg-dark: #1a0a0a;
            --bg-medium: #2a1515;
            --bg-light: #3a2020;
            --primary-glow: rgba(255, 107, 53, 0.4);
            --secondary-glow: rgba(255, 0, 110, 0.4);
        }

        [data-theme="sunset"] body {
            background: #1a0a0a;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 107, 53, 0.03) 2px, rgba(255, 107, 53, 0.03) 4px);
            color: #ff6b35;
        }

        /* Theme: Vaporwave - Pink/Cyan/Purple */
        [data-theme="vaporwave"] {
            --primary-color: #ff00ff;
            --secondary-color: #00ffff;
            --accent-color: #ff71ce;
            --bg-dark: #0a0a1a;
            --bg-medium: #1a0a2e;
            --bg-light: #2a1a3e;
            --primary-glow: rgba(255, 0, 255, 0.4);
            --secondary-glow: rgba(0, 255, 255, 0.4);
        }

        [data-theme="vaporwave"] body {
            background: #0a0a1a;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 0, 255, 0.03) 2px, rgba(255, 0, 255, 0.03) 4px);
            color: #ff00ff;
        }

        /* Theme: Ocean - Blue/Teal/Aqua */
        [data-theme="ocean"] {
            --primary-color: #00d4ff;
            --secondary-color: #00ffc8;
            --accent-color: #0088ff;
            --bg-dark: #001a2e;
            --bg-medium: #00243e;
            --bg-light: #003a5e;
            --primary-glow: rgba(0, 212, 255, 0.4);
            --secondary-glow: rgba(0, 255, 200, 0.4);
        }

        [data-theme="ocean"] body {
            background: #001a2e;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 212, 255, 0.03) 2px, rgba(0, 212, 255, 0.03) 4px);
            color: #00d4ff;
        }

        /* Theme: Dracula - Purple/Pink/Red */
        [data-theme="dracula"] {
            --primary-color: #bd93f9;
            --secondary-color: #ff79c6;
            --accent-color: #ff5555;
            --bg-dark: #1e1e2e;
            --bg-medium: #282a36;
            --bg-light: #44475a;
            --primary-glow: rgba(189, 147, 249, 0.4);
            --secondary-glow: rgba(255, 121, 198, 0.4);
        }

        [data-theme="dracula"] body {
            background: #1e1e2e;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(189, 147, 249, 0.03) 2px, rgba(189, 147, 249, 0.03) 4px);
            color: #bd93f9;
        }

        /* Theme: Midnight Oil - Deep Navy/Gold */
        [data-theme="midnight"] {
            --primary-color: #ffd700;
            --secondary-color: #ffb700;
            --accent-color: #ffa500;
            --bg-dark: #0a1628;
            --bg-medium: #152238;
            --bg-light: #1f2e48;
            --primary-glow: rgba(255, 215, 0, 0.4);
            --secondary-glow: rgba(255, 183, 0, 0.4);
        }

        [data-theme="midnight"] body {
            background: #0a1628;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 215, 0, 0.03) 2px, rgba(255, 215, 0, 0.03) 4px);
            color: #ffd700;
        }

        /* Theme: J's Special - Rainbow Multicolor */
        [data-theme="jspecial"] {
            --primary-color: #ff1493;
            --secondary-color: #00ff00;
            --accent-color: #00d4ff;
            --bg-dark: #0a0a0a;
            --bg-medium: #1a1a1a;
            --bg-light: #2a2a2a;
            --primary-glow: rgba(255, 20, 147, 0.5);
            --secondary-glow: rgba(0, 255, 0, 0.5);
        }

        [data-theme="jspecial"] body {
            background: #000;
            background-image:
                linear-gradient(45deg, rgba(255, 20, 147, 0.1) 0%, rgba(0, 255, 255, 0.1) 25%, rgba(0, 255, 0, 0.1) 50%, rgba(255, 165, 0, 0.1) 75%, rgba(138, 43, 226, 0.1) 100%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 255, 255, 0.02) 2px, rgba(255, 255, 255, 0.02) 4px);
            color: #fff;
        }

        /* J's Special - Rainbow buttons and elements */
        [data-theme="jspecial"] .btn:nth-child(10n+1),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+1) {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+2),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+2) {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border-color: #00bfff;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+3),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+3) {
            background: linear-gradient(135deg, #00ff00, #7fff00);
            border-color: #00ff00;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+4),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+4) {
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            border-color: #ff8c00;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+5),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+5) {
            background: linear-gradient(135deg, #8a2be2, #9370db);
            border-color: #8a2be2;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+6),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+6) {
            background: linear-gradient(135deg, #ffff00, #ffd700);
            border-color: #ffff00;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+7),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+7) {
            background: linear-gradient(135deg, #ff0000, #ff6347);
            border-color: #ff0000;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+8),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+8) {
            background: linear-gradient(135deg, #00ffff, #40e0d0);
            border-color: #00ffff;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+9),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+9) {
            background: linear-gradient(135deg, #ff00ff, #da70d6);
            border-color: #ff00ff;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+10),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+10) {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            border-color: #ff69b4;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+1) {
            background: linear-gradient(135deg, #adff2f, #7fff00);
            border-color: #adff2f;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+2) {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+3) {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border-color: #00bfff;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+4) {
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            border-color: #ff8c00;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+5) {
            background: linear-gradient(135deg, #8a2be2, #9370db);
            border-color: #8a2be2;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+6) {
            background: linear-gradient(135deg, #ffff00, #ffd700);
            border-color: #ffff00;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+7) {
            background: linear-gradient(135deg, #ff0000, #ff6347);
            border-color: #ff0000;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+8) {
            background: linear-gradient(135deg, #00ffff, #40e0d0);
            border-color: #00ffff;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+9) {
            background: linear-gradient(135deg, #ff00ff, #da70d6);
            border-color: #ff00ff;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+10) {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            border-color: #ff69b4;
            color: #000;
        }

        [data-theme="jspecial"] .content-card {
            border-color: #ff00ff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 0, 255, 0.5);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+3) {
            border-color: #00ff00;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+4) {
            border-color: #ffa500;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 165, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+5) {
            border-color: #8a2be2;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(138, 43, 226, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+6) {
            border-color: #ffff00;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+7) {
            border-color: #ff0000;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 0, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+8) {
            border-color: #00ffff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 255, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+9) {
            border-color: #ff00ff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 0, 255, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Search Results */
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Recommendations */
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Movies Tab */
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful TV Shows Tab */
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        [data-theme="jspecial"] .header {
            border: none;
            background: transparent;
            box-shadow: none;
        }

        [data-theme="jspecial"] h1 {
            color: #ff1493;
            text-shadow:
                2px 2px 0 #00ffff,
                4px 4px 0 #00ff00,
                6px 6px 0 #ffa500,
                8px 8px 10px rgba(0, 0, 0, 0.5);
        }

        [data-theme="jspecial"] .search-container input {
            border-color: #ff00ff;
            color: #fff;
            background: #1a1a1a;
        }

        [data-theme="jspecial"] .search-container input:focus {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        [data-theme="jspecial"] .content-title {
            color: #00ffff;
        }

        [data-theme="jspecial"] .content-year {
            color: #ffa500;
        }

        [data-theme="jspecial"] .watchlist-btn {
            border-color: #ff1493;
            background: rgba(255, 20, 147, 0.2);
        }

        [data-theme="jspecial"] .watchlist-btn:hover {
            background: #ff1493;
            box-shadow: 0 0 20px #ff1493;
        }

        [data-theme="jspecial"] .imdb-btn {
            background: linear-gradient(135deg, #ff00ff, #ff1493);
            border-color: #ff00ff;
        }

        [data-theme="jspecial"] .bg-animation-toggle {
            background: linear-gradient(135deg, #8a2be2, #9370db);
            border-color: #8a2be2;
            color: #000;
        }

        [data-theme="jspecial"] .theme-selector-btn {
            background: linear-gradient(135deg, #00ff00, #7fff00);
            border-color: #00ff00;
            color: #000;
        }

        [data-theme="jspecial"] .genre-btn {
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            border-color: #ff8c00;
            color: #000;
        }

        [data-theme="jspecial"] .status-bar {
            background: linear-gradient(90deg, #ff1493, #00ffff, #00ff00, #ffa500, #8a2be2);
        }

        [data-theme="jspecial"] .omdb-ratings-tooltip {
            border-color: #00ffff;
            background: rgba(10, 10, 10, 0.98);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        /* Continue watching, search results, and other items */
        [data-theme="jspecial"] .continue-item:nth-child(10n+1),
        [data-theme="jspecial"] .result-item:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+2),
        [data-theme="jspecial"] .result-item:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+3),
        [data-theme="jspecial"] .result-item:nth-child(10n+3) {
            border-color: #00ff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+4),
        [data-theme="jspecial"] .result-item:nth-child(10n+4) {
            border-color: #ffa500;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 165, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+5),
        [data-theme="jspecial"] .result-item:nth-child(10n+5) {
            border-color: #8a2be2;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(138, 43, 226, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+6),
        [data-theme="jspecial"] .result-item:nth-child(10n+6) {
            border-color: #ffff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+7),
        [data-theme="jspecial"] .result-item:nth-child(10n+7) {
            border-color: #ff0000;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+8),
        [data-theme="jspecial"] .result-item:nth-child(10n+8) {
            border-color: #00ffff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 255, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+9),
        [data-theme="jspecial"] .result-item:nth-child(10n+9) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+10),
        [data-theme="jspecial"] .result-item:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Particles */
        [data-theme="jspecial"] .particle:nth-child(10n+1) {
            background: #ff1493;
            box-shadow: 0 0 15px #ff1493, 0 0 30px #ff1493, 0 0 45px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+2) {
            background: #00bfff;
            box-shadow: 0 0 15px #00bfff, 0 0 30px #00bfff, 0 0 45px #00bfff, 0 0 60px #00bfff;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+3) {
            background: #ffd700;
            box-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700, 0 0 45px #ffd700, 0 0 60px #ffd700;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+4) {
            background: #ff6b35;
            box-shadow: 0 0 15px #ff6b35, 0 0 30px #ff6b35, 0 0 45px #ff6b35, 0 0 60px #ff6b35;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+5) {
            background: #00ff9f;
            box-shadow: 0 0 15px #00ff9f, 0 0 30px #00ff9f, 0 0 45px #00ff9f, 0 0 60px #00ff9f;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+6) {
            background: #ff00ff;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff, 0 0 45px #ff00ff, 0 0 60px #ff00ff;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+7) {
            background: #7fff00;
            box-shadow: 0 0 15px #7fff00, 0 0 30px #7fff00, 0 0 45px #7fff00, 0 0 60px #7fff00;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+8) {
            background: #ff1493;
            box-shadow: 0 0 15px #ff1493, 0 0 30px #ff1493, 0 0 45px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+9) {
            background: #00d9ff;
            box-shadow: 0 0 15px #00d9ff, 0 0 30px #00d9ff, 0 0 45px #00d9ff, 0 0 60px #00d9ff;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+10) {
            background: #ff69b4;
            box-shadow: 0 0 15px #ff69b4, 0 0 30px #ff69b4, 0 0 45px #ff69b4, 0 0 60px #ff69b4;
        }

        /* J's Special - Colorful Stars */
        [data-theme="jspecial"] .pixel-star:nth-child(10n+1) {
            background: #ff1493;
            box-shadow: 0 0 10px #ff1493, 0 0 20px #ff1493, 0 0 30px #ff1493, 0 0 40px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+2) {
            background: #00bfff;
            box-shadow: 0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff, 0 0 60px #00bfff;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+3) {
            background: #ffd700;
            box-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700, 0 0 30px #ffd700, 0 0 40px #ffd700, 0 0 60px #ffd700;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+4) {
            background: #ff6b35;
            box-shadow: 0 0 10px #ff6b35, 0 0 20px #ff6b35, 0 0 30px #ff6b35, 0 0 40px #ff6b35, 0 0 60px #ff6b35;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+5) {
            background: #00ff9f;
            box-shadow: 0 0 10px #00ff9f, 0 0 20px #00ff9f, 0 0 30px #00ff9f, 0 0 40px #00ff9f, 0 0 60px #00ff9f;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+6) {
            background: #ff00ff;
            box-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff, 0 0 60px #ff00ff;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+7) {
            background: #7fff00;
            box-shadow: 0 0 10px #7fff00, 0 0 20px #7fff00, 0 0 30px #7fff00, 0 0 40px #7fff00, 0 0 60px #7fff00;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+8) {
            background: #ff1493;
            box-shadow: 0 0 10px #ff1493, 0 0 20px #ff1493, 0 0 30px #ff1493, 0 0 40px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+9) {
            background: #00d9ff;
            box-shadow: 0 0 10px #00d9ff, 0 0 20px #00d9ff, 0 0 30px #00d9ff, 0 0 40px #00d9ff, 0 0 60px #00d9ff;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+10) {
            background: #ff69b4;
            box-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4, 0 0 30px #ff69b4, 0 0 40px #ff69b4, 0 0 60px #ff69b4;
        }

        /* J's Special - Colorful Tab Buttons (Continue Watching, My Watchlist, Stats) */
        [data-theme="jspecial"] .tab:nth-child(1) {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(2) {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border-color: #00bfff;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(3) {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            border-color: #ffd700;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(4) {
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border-color: #ff6b35;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(5) {
            background: linear-gradient(135deg, #00ff9f, #00d4aa);
            border-color: #00ff9f;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(6) {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(7) {
            background: linear-gradient(135deg, #7fff00, #65d900);
            border-color: #7fff00;
            color: #000;
        }

        /* J's Special - Active tab state */
        [data-theme="jspecial"] .tab.active {
            border-width: 4px;
            transform: scale(1.08);
            box-shadow: 0 0 30px currentColor, inset 0 0 30px rgba(255, 255, 255, 0.4);
            font-weight: 700;
        }

        /* J's Special - Colorful bg-animation-toggle buttons (Season, Episode, Popular, Trending, etc) */
        [data-theme="jspecial"] #seasonButton {
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border-color: #ff6b35;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #episodeButton {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #popularFilterBtn {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
        }
        [data-theme="jspecial"] #trendingFilterBtn {
            background: linear-gradient(135deg, #7fff00, #65d900);
            border-color: #7fff00;
            color: #000;
        }
        [data-theme="jspecial"] #nowPlayingFilterBtn {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }
        [data-theme="jspecial"] #upcomingFilterBtn {
            background: linear-gradient(135deg, #00d9ff, #00bfff);
            border-color: #00d9ff;
            color: #000;
        }
        [data-theme="jspecial"] #genreFilterBtn {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            border-color: #ffd700;
            color: #000;
        }
        [data-theme="jspecial"] #languageFilterBtn {
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border-color: #ff6b35;
            color: #000;
        }

        /* J's Special - Party and Effects buttons */
        [data-theme="jspecial"] .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] .bg-animation-toggle[onclick*="toggleEffectsPanel"] {
            background: linear-gradient(135deg, #7fff00, #65d900);
            border-color: #7fff00;
            color: #000;
            box-shadow: 0 0 15px rgba(127, 255, 0, 0.6);
        }

        /* J's Special - Search Button */
        [data-theme="jspecial"] #searchBtn {
            background: linear-gradient(135deg, #00d9ff, #00bfff);
            border-color: #00d9ff;
            color: #fff;
        }

        /* J's Special - Colorful Container Borders in Content Player */
        [data-theme="jspecial"] .current-content {
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        [data-theme="jspecial"] .omdb-ratings {
            border: none;
            border-radius: 12px;
            padding: 16px;
            box-shadow: none;
        }

        /* J's Special - Colorful Rating Items */
        [data-theme="jspecial"] .rating-item:nth-child(1) {
            background: rgba(255, 215, 0, 0.08);
            border: 3px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        [data-theme="jspecial"] .rating-item:nth-child(2) {
            background: rgba(255, 20, 147, 0.08);
            border: 3px solid #ff1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .rating-item:nth-child(3) {
            background: rgba(0, 191, 255, 0.08);
            border: 3px solid #00bfff;
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .omdb-details {
            background: rgba(0, 255, 159, 0.08);
            border: 3px solid #00ff9f;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
        }

        [data-theme="jspecial"] .cast-section {
            background: rgba(255, 0, 255, 0.08);
            border: 3px solid #ff00ff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }

        [data-theme="jspecial"] .tv-controls {
            border: 3px solid #ff1493;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .episode-description {
            background: rgba(0, 191, 255, 0.08);
        }

        /* J's Special - All Buttons with Black Text */
        [data-theme="jspecial"] .btn,
        [data-theme="jspecial"] .btn-secondary {
            color: #000000;
        }

        [data-theme="jspecial"] .btn:hover,
        [data-theme="jspecial"] .btn-secondary:hover {
            color: #000000;
        }

        /* J's Special - Theme Selector button animation */
        [data-theme="jspecial"] .theme-selector-btn {
            background: linear-gradient(135deg, #ff1493, #00bfff, #ffd700, #00ff9f, #ff00ff);
            background-size: 300% 300%;
            animation: rainbowShift 3s ease infinite;
        }

        @keyframes rainbowShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Theme: Phosphor Burn - Vintage CRT Amber Monitor */
        [data-theme="phosphor"] {
            --primary-color: #ffb000;
            --secondary-color: #33ff66;
            --accent-color: #ff6600;
            --bg-dark: #0a0800;
            --bg-medium: #1a1408;
            --bg-light: #2a2010;
            --primary-glow: rgba(255, 176, 0, 0.5);
            --secondary-glow: rgba(51, 255, 102, 0.4);
        }

        [data-theme="phosphor"] body {
            background: #0a0800;
            background-image:
                radial-gradient(ellipse at center, #1a1408 0%, #0a0800 70%, #050400 100%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 176, 0, 0.02) 2px, rgba(255, 176, 0, 0.02) 4px);
            color: #ffb000;
        }

        @keyframes phosphorBurn {
            0%, 100% {
                text-shadow: 0 0 10px rgba(255, 176, 0, 0.8),
                             0 0 20px rgba(255, 176, 0, 0.4);
            }
            50% {
                text-shadow: 0 0 15px rgba(255, 176, 0, 1),
                             0 0 30px rgba(255, 176, 0, 0.6),
                             0 0 5px rgba(51, 255, 102, 0.3);
            }
        }

        @keyframes phosphorGhost {
            0%, 100% { opacity: 1; filter: blur(0px); }
            25% { opacity: 0.95; filter: blur(0.5px); }
            75% { opacity: 0.97; filter: blur(0.3px); }
        }

        /* Phosphor Burn - Header with phosphor burn animation */
        [data-theme="phosphor"] .header h1 {
            color: #ffb000;
            text-shadow: 0 0 10px rgba(255, 176, 0, 0.8),
                         0 0 20px rgba(255, 176, 0, 0.4);
            animation: phosphorBurn 3s ease-in-out infinite;
        }

        [data-theme="phosphor"] .header p {
            color: #33ff66;
            text-shadow: 0 0 8px rgba(51, 255, 102, 0.5);
        }

        /* Phosphor Burn - Buttons */
        [data-theme="phosphor"] .btn,
        [data-theme="phosphor"] .nav-btn {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 100%);
            border: 2px solid #ffb000;
            color: #0a0800;
            box-shadow: 0 0 10px rgba(255, 176, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        [data-theme="phosphor"] .btn:hover,
        [data-theme="phosphor"] .nav-btn:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            border-color: #33ff66;
            color: #0a0800;
            box-shadow: 0 0 15px rgba(51, 255, 102, 0.5);
        }

        [data-theme="phosphor"] .btn-secondary {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            border: 2px solid #33ff66;
            color: #0a0800;
            box-shadow: 0 0 10px rgba(51, 255, 102, 0.4);
        }

        [data-theme="phosphor"] .btn-secondary:hover {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 100%);
            border-color: #ffb000;
            color: #0a0800;
            box-shadow: 0 0 15px rgba(255, 176, 0, 0.5);
        }

        /* Phosphor Burn - Effects buttons */
        [data-theme="phosphor"] .effects-btn {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 100%);
            border: 2px solid #ffb000;
            color: #0a0800;
        }

        [data-theme="phosphor"] .effects-btn:hover,
        [data-theme="phosphor"] .effects-btn.active {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            border-color: #33ff66;
            box-shadow: 0 0 15px rgba(51, 255, 102, 0.5);
        }

        /* Phosphor Burn - Content Cards with CRT vignette */
        [data-theme="phosphor"] .content-card {
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 2px solid #ffb000;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5),
                        0 0 15px rgba(255, 176, 0, 0.3);
            position: relative;
            overflow: hidden;
            animation: phosphorGhost 4s ease-in-out infinite;
        }

        [data-theme="phosphor"] .content-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 1;
        }

        [data-theme="phosphor"] .content-card:hover {
            border-color: #33ff66;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5),
                        0 0 25px rgba(51, 255, 102, 0.5);
            transform: translate(-2px, -2px);
        }

        [data-theme="phosphor"] .content-card .rating {
            background: #33ff66;
            color: #0a0800;
            box-shadow: 0 0 8px rgba(51, 255, 102, 0.5);
        }

        [data-theme="phosphor"] .content-card h3 {
            color: #ffb000;
            text-shadow: 0 0 5px rgba(255, 176, 0, 0.5);
        }

        [data-theme="phosphor"] .content-card p,
        [data-theme="phosphor"] .content-card .year {
            color: rgba(255, 176, 0, 0.7);
        }

        /* Phosphor Burn - Input fields */
        [data-theme="phosphor"] input[type="text"],
        [data-theme="phosphor"] input[type="search"],
        [data-theme="phosphor"] .search-input {
            background: #0a0800;
            border: 2px solid #ffb000;
            color: #ffb000;
            box-shadow: inset 0 0 10px rgba(255, 176, 0, 0.1);
        }

        [data-theme="phosphor"] input[type="text"]:focus,
        [data-theme="phosphor"] input[type="search"]:focus,
        [data-theme="phosphor"] .search-input:focus {
            border-color: #33ff66;
            box-shadow: 0 0 15px rgba(51, 255, 102, 0.4),
                        inset 0 0 10px rgba(51, 255, 102, 0.1);
            outline: none;
        }

        [data-theme="phosphor"] input::placeholder {
            color: rgba(255, 176, 0, 0.5);
        }

        /* Phosphor Burn - Modals and panels */
        [data-theme="phosphor"] .modal-content,
        [data-theme="phosphor"] .panel {
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 2px solid #ffb000;
            box-shadow: 0 0 30px rgba(255, 176, 0, 0.3);
        }

        [data-theme="phosphor"] .theme-selector-panel,
        [data-theme="phosphor"] .effects-panel {
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 2px solid #ffb000;
            box-shadow: 0 0 30px rgba(255, 176, 0, 0.4);
        }

        /* Phosphor Burn - Theme selector button */
        [data-theme="phosphor"] .theme-selector-btn {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 100%);
            border-color: #ffb000;
            box-shadow: 0 0 15px rgba(255, 176, 0, 0.5);
        }

        [data-theme="phosphor"] .theme-selector-btn:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            border-color: #33ff66;
            box-shadow: 0 0 20px rgba(51, 255, 102, 0.6);
        }

        /* Phosphor Burn - Scrollbar */
        [data-theme="phosphor"] ::-webkit-scrollbar {
            width: 12px;
            background: #0a0800;
        }

        [data-theme="phosphor"] ::-webkit-scrollbar-track {
            background: #0a0800;
            border: 1px solid #1a1408;
        }

        [data-theme="phosphor"] ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 100%);
            border: 1px solid #ffb000;
            border-radius: 0;
        }

        [data-theme="phosphor"] ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            border-color: #33ff66;
        }

        /* Phosphor Burn - Category tabs and filters */
        [data-theme="phosphor"] .category-tab,
        [data-theme="phosphor"] .filter-btn {
            background: transparent;
            border: 2px solid #ffb000;
            color: #ffb000;
        }

        [data-theme="phosphor"] .category-tab:hover,
        [data-theme="phosphor"] .filter-btn:hover,
        [data-theme="phosphor"] .category-tab.active,
        [data-theme="phosphor"] .filter-btn.active {
            background: #ffb000;
            color: #0a0800;
            box-shadow: 0 0 15px rgba(255, 176, 0, 0.5);
        }

        /* Phosphor Burn - Navigation and links */
        [data-theme="phosphor"] a {
            color: #33ff66;
        }

        [data-theme="phosphor"] a:hover {
            color: #ffb000;
            text-shadow: 0 0 8px rgba(255, 176, 0, 0.5);
        }

        /* ============= PHOSPHOR BURN CRT REDESIGN ============= */

        /* Hide existing search bar in phosphor theme */
        [data-theme="phosphor"] .search-section {
            display: none !important;
        }

        /* Show phosphor-only elements (boot overlay is controlled by JS only) */
        [data-theme="phosphor"] .crt-scanlines-overlay,
        [data-theme="phosphor"] .crt-curvature-overlay,
        [data-theme="phosphor"] .floating-search,
        [data-theme="phosphor"] .crt-power-led {
            display: block;
        }

        /* CRT Boot Sequence Overlay */
        .crt-boot-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 999999;
            pointer-events: none;
        }

        .crt-boot-overlay.active {
            pointer-events: all;
        }

        .crt-boot-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .crt-boot-line {
            width: 0;
            height: 3px;
            background: #ffb000;
            box-shadow: 0 0 20px #ffb000, 0 0 40px #ffb000;
            margin: 0 auto 30px;
            transition: width 0.5s ease-out;
        }

        .crt-boot-line.expanding {
            width: 80vw;
        }

        .crt-boot-text {
            font-family: 'VT323', monospace;
            color: #ffb000;
            font-size: 24px;
            text-shadow: 0 0 10px #ffb000;
            white-space: pre-wrap;
            text-align: left;
            max-width: 600px;
            margin: 0 auto;
        }

        /* CRT Scanlines Overlay */
        .crt-scanlines-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99998;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            animation: scanlineMove 0.1s linear infinite;
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* CRT Curvature/Vignette Overlay */
        .crt-curvature-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99997;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 60%,
                rgba(0, 0, 0, 0.3) 80%,
                rgba(0, 0, 0, 0.7) 100%
            );
        }

        /* Screen Flicker Effect */
        [data-theme="phosphor"] body {
            animation: screenFlicker 8s ease-in-out infinite;
        }

        @keyframes screenFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.95; }
            94% { opacity: 1; }
            95% { opacity: 0.97; }
            96% { opacity: 1; }
        }

        /* Floating Search Styles */
        .floating-search {
            display: none;
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100000;
        }

        .floating-search-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ffb000 0%, #cc8c00 100%);
            border: 3px solid #ffb000;
            color: #0a0800;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(255, 176, 0, 0.5),
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .floating-search-btn:hover {
            background: linear-gradient(145deg, #33ff66 0%, #28cc52 100%);
            border-color: #33ff66;
            box-shadow: 0 0 30px rgba(51, 255, 102, 0.6);
            transform: scale(1.1);
        }

        .floating-search-btn svg {
            width: 28px;
            height: 28px;
        }

        .floating-search-panel {
            position: absolute;
            right: 70px;
            top: 50%;
            transform: translateY(-50%) scaleX(0);
            transform-origin: right center;
            width: 400px;
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid #ffb000;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 176, 0, 0.4),
                        inset 0 0 60px rgba(255, 176, 0, 0.05);
            opacity: 0;
            overflow: hidden;
        }

        .floating-search-panel.active {
            transform: translateY(-50%) scaleX(1);
            opacity: 1;
        }

        .floating-search-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 2px solid rgba(255, 176, 0, 0.3);
            background: rgba(255, 176, 0, 0.1);
        }

        .terminal-prompt {
            font-family: 'VT323', monospace;
            color: #33ff66;
            font-size: 18px;
            text-shadow: 0 0 8px rgba(51, 255, 102, 0.5);
        }

        .floating-search-close {
            background: none;
            border: none;
            color: #ffb000;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: all 0.2s;
        }

        .floating-search-close:hover {
            color: #33ff66;
            text-shadow: 0 0 10px rgba(51, 255, 102, 0.8);
        }

        .floating-search-input-wrapper {
            display: flex;
            align-items: center;
            padding: 16px;
            gap: 12px;
        }

        .terminal-cursor {
            font-family: 'VT323', monospace;
            color: #33ff66;
            font-size: 24px;
            animation: cursorBlink 1s step-end infinite;
        }

        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .floating-search-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #ffb000;
            font-family: 'VT323', monospace;
            font-size: 22px;
            outline: none;
            caret-color: #33ff66;
        }

        .floating-search-input::placeholder {
            color: rgba(255, 176, 0, 0.4);
        }

        .floating-search-results {
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid rgba(255, 176, 0, 0.2);
        }

        .floating-search-results::-webkit-scrollbar {
            width: 8px;
        }

        .floating-search-results::-webkit-scrollbar-track {
            background: #0a0800;
        }

        .floating-search-results::-webkit-scrollbar-thumb {
            background: #ffb000;
        }

        .floating-search-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 176, 0, 0.1);
            transition: all 0.2s;
        }

        .floating-search-result-item:hover {
            background: rgba(255, 176, 0, 0.15);
        }

        .floating-search-result-item img {
            width: 40px;
            height: 60px;
            object-fit: cover;
            border: 1px solid #ffb000;
        }

        .floating-search-result-info {
            flex: 1;
        }

        .floating-search-result-title {
            color: #ffb000;
            font-family: 'VT323', monospace;
            font-size: 18px;
        }

        .floating-search-result-year {
            color: rgba(51, 255, 102, 0.7);
            font-family: 'VT323', monospace;
            font-size: 14px;
        }

        /* Power LED Indicator */
        .crt-power-led {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 12px;
            height: 12px;
            background: #33ff66;
            border-radius: 50%;
            box-shadow: 0 0 10px #33ff66, 0 0 20px #33ff66;
            animation: powerLedPulse 2s ease-in-out infinite;
            z-index: 99999;
        }

        @keyframes powerLedPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px #33ff66, 0 0 20px #33ff66; }
            50% { opacity: 0.7; box-shadow: 0 0 5px #33ff66, 0 0 10px #33ff66; }
        }

        /* Phosphor Theme - Enhanced Content Cards (Mini CRT Monitors) */
        [data-theme="phosphor"] .content-card {
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid #ffb000;
            border-radius: 8px;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5),
                        0 0 15px rgba(255, 176, 0, 0.3),
                        inset 0 0 30px rgba(255, 176, 0, 0.05);
            position: relative;
            overflow: visible;
            transition: all 0.3s ease;
        }

        /* Card Power LED */
        [data-theme="phosphor"] .content-card::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            width: 8px;
            height: 8px;
            background: #33ff66;
            border-radius: 50%;
            box-shadow: 0 0 8px #33ff66;
            z-index: 10;
            animation: cardLedPulse 3s ease-in-out infinite;
        }

        @keyframes cardLedPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Card CRT Screen Effect (poster area) */
        [data-theme="phosphor"] .content-card .content-poster {
            position: relative;
            filter: contrast(1.1) saturate(0.9);
        }

        [data-theme="phosphor"] .content-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.1) 0px,
                    rgba(0, 0, 0, 0.1) 1px,
                    transparent 1px,
                    transparent 2px
                ),
                radial-gradient(
                    ellipse at center,
                    transparent 0%,
                    transparent 50%,
                    rgba(0, 0, 0, 0.2) 100%
                );
            pointer-events: none;
            z-index: 5;
            border-radius: 5px;
        }

        [data-theme="phosphor"] .content-card:hover {
            border-color: #33ff66;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5),
                        0 0 30px rgba(51, 255, 102, 0.5),
                        inset 0 0 40px rgba(51, 255, 102, 0.1);
            transform: translate(-3px, -3px);
        }

        /* Phosphor ghost/trail effect on hover */
        [data-theme="phosphor"] .content-card:hover .content-poster {
            animation: phosphorTrail 0.3s ease-out;
        }

        @keyframes phosphorTrail {
            0% { filter: contrast(1.1) saturate(0.9) brightness(1); }
            50% { filter: contrast(1.3) saturate(1.2) brightness(1.2); }
            100% { filter: contrast(1.1) saturate(0.9) brightness(1); }
        }

        /* Enhanced Phosphor Buttons */
        [data-theme="phosphor"] .btn,
        [data-theme="phosphor"] .nav-btn {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 50%, #a37000 100%);
            border: 3px solid #ffb000;
            border-top-color: #ffd466;
            border-left-color: #ffd466;
            border-bottom-color: #996600;
            border-right-color: #996600;
            color: #0a0800;
            font-family: 'VT323', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 0 #664400,
                        0 0 15px rgba(255, 176, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.15s ease;
            position: relative;
            overflow: hidden;
        }

        /* Light sweep animation on hover */
        [data-theme="phosphor"] .btn::before,
        [data-theme="phosphor"] .nav-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            transition: left 0.4s ease;
        }

        [data-theme="phosphor"] .btn:hover::before,
        [data-theme="phosphor"] .nav-btn:hover::before {
            left: 100%;
        }

        [data-theme="phosphor"] .btn:hover,
        [data-theme="phosphor"] .nav-btn:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 50%, #1fa342 100%);
            border-color: #33ff66;
            border-top-color: #7fff99;
            border-left-color: #7fff99;
            border-bottom-color: #1a8035;
            border-right-color: #1a8035;
            box-shadow: 0 4px 0 #145528,
                        0 0 20px rgba(51, 255, 102, 0.5);
        }

        /* Button press effect */
        [data-theme="phosphor"] .btn:active,
        [data-theme="phosphor"] .nav-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #664400,
                        0 0 10px rgba(255, 176, 0, 0.3);
        }

        /* Secondary Button (green outline) */
        [data-theme="phosphor"] .btn-secondary {
            background: transparent;
            border: 3px solid #33ff66;
            color: #33ff66;
            box-shadow: 0 0 15px rgba(51, 255, 102, 0.3);
        }

        [data-theme="phosphor"] .btn-secondary:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            color: #0a0800;
            box-shadow: 0 0 25px rgba(51, 255, 102, 0.6);
        }

        /* Tertiary Button (subtle) */
        [data-theme="phosphor"] .btn-tertiary {
            background: transparent;
            border: 1px solid rgba(255, 176, 0, 0.3);
            color: rgba(255, 176, 0, 0.6);
            box-shadow: none;
        }

        [data-theme="phosphor"] .btn-tertiary:hover {
            border-color: #ffb000;
            color: #ffb000;
            background: rgba(255, 176, 0, 0.1);
        }

        /* Phosphor Theme Container Adjustments */
        [data-theme="phosphor"] .container {
            position: relative;
            z-index: 1;
        }

        /* Reduced header for phosphor theme */
        [data-theme="phosphor"] .header {
            padding: 16px 20px;
            margin-bottom: 24px;
        }

        [data-theme="phosphor"] .header h1 {
            font-size: 1.6rem;
        }

        /* Mobile adjustments for floating search */
        @media (max-width: 768px) {
            .floating-search {
                right: 10px;
            }

            .floating-search-btn {
                width: 50px;
                height: 50px;
            }

            .floating-search-panel {
                width: calc(100vw - 80px);
                right: 60px;
            }

            .floating-search-panel.active {
                max-width: 350px;
            }
        }

        /* ============= END PHOSPHOR BURN CRT REDESIGN ============= */

        /* Apply theme colors to existing elements */
        .header {
            border: none;
            box-shadow: none;
        }

        .header h1 {
            color: var(--primary-color, #00ff9f);
            text-shadow:
                3px 3px 0 var(--secondary-color, #ff00ff),
                6px 6px 0 rgba(0, 0, 0, 0.3),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .header p {
            color: var(--accent-color, #00d9ff);
        }

        .search-section {
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .btn {
            border-color: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            background: var(--primary-color, #00ff9f);
            box-shadow:
                3px 3px 0 rgba(0, 0, 0, 0.4),
                0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .btn:hover {
            background: var(--bg-dark, #0f0f1e);
            color: var(--primary-color, #00ff9f);
            box-shadow:
                1px 1px 0 rgba(0, 0, 0, 0.4),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        /* ============= ANIMATED BACKGROUNDS ============= */

        /* Background Animation Container */
        #bgAnimation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            opacity: 0.4;
        }

        /* Matrix Rain Effect */
        .matrix-rain {
            position: absolute;
            top: -100%;
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--primary-color, #00ff9f);
            text-shadow: 0 0 8px var(--primary-color, #00ff9f);
            animation: matrixFall linear infinite;
            white-space: nowrap;
        }

        @keyframes matrixFall {
            to {
                top: 100%;
            }
        }

        /* Pixel Stars */
        .pixel-star {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--primary-color, #00ff9f);
            box-shadow:
                0 0 10px var(--primary-color, #00ff9f),
                0 0 20px var(--primary-color, #00ff9f),
                0 0 30px var(--primary-color, #00ff9f),
                0 0 40px var(--primary-color, #00ff9f),
                0 0 60px var(--primary-color, #00ff9f);
            animation: twinkle 3s ease-in-out infinite;
            filter: brightness(1.5);
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }

        /* Floating Particles */
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent-color, #00d9ff);
            border-radius: 50%;
            animation: float linear infinite;
            opacity: 1;
            box-shadow:
                0 0 15px var(--accent-color, #00d9ff),
                0 0 30px var(--accent-color, #00d9ff),
                0 0 45px var(--accent-color, #00d9ff),
                0 0 60px var(--accent-color, #00d9ff);
            filter: brightness(1.5);
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Scan Lines */
        .scanline {
            position: absolute;
            width: 100%;
            height: 3px;
            background: var(--primary-color, #00ff9f);
            opacity: 0.4;
            box-shadow:
                0 0 10px var(--primary-color, #00ff9f),
                0 0 20px var(--primary-color, #00ff9f);
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% {
                top: 0%;
            }
            100% {
                top: 100%;
            }
        }

        /* Background Animation Toggle */
        .bg-animation-toggle {
            padding: 10px 16px;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 20px;
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .bg-animation-toggle:hover {
            background: var(--primary-color, #00ff9f);
            color: #000;
            box-shadow: 0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .bg-animation-toggle.active {
            background: var(--primary-color, #00ff9f);
            color: #000;
            border-width: 3px;
            box-shadow: 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.8)),
                        inset 0 0 20px rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
            font-weight: 600;
        }

        /* Background Effects Panel */
        .bg-effects-panel {
            position: fixed;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 3px solid var(--primary-color, #00ff9f);
            border-radius: 16px;
            padding: 20px;
            z-index: 99999;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-width: 250px;
            box-shadow: 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .bg-effects-panel.active {
            display: flex;
            animation: slideInFromRight 0.3s ease-out;
        }

        .bg-effects-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--primary-color, #00ff9f);
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .panel-close-btn {
            font-family: 'VT323', monospace;
            font-size: 24px;
            color: var(--primary-color, #00ff9f);
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            opacity: 0.7;
        }

        .panel-close-btn:hover {
            opacity: 1;
            transform: scale(1.2);
            color: var(--secondary-color, #ff00ff);
            text-shadow: 0 0 10px currentColor;
        }

        .bg-effects-title .title-text {
            flex: 1;
            text-align: center;
        }

        .effect-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: rgba(15, 15, 30, 0.6);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .effect-option:hover {
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.8);
        }

        .effect-option.active {
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.9);
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .effect-name {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #e0e0e0;
        }

        .effect-toggle {
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
        }

        .effect-option.active .effect-toggle {
            background: var(--primary-color, #00ff9f);
        }

        .effect-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .effect-option.active .effect-toggle::after {
            left: 22px;
        }

        .effects-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .effects-btn {
            flex: 1;
            padding: 8px;
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--accent-color, #00d9ff);
            color: var(--accent-color, #00d9ff);
            font-family: 'VT323', monospace;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .effects-btn:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.5));
        }

        /* ============= END ANIMATED BACKGROUNDS ============= */

        /* ============= USER MENU DROPDOWN ============= */
        .user-menu-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100002;
        }

        .user-menu-btn {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: var(--primary-color, #00ff9f);
            backdrop-filter: blur(10px);
            border: 2px solid var(--primary-color, #00ff9f);
            color: #BF00FF;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 159, 0.3);
        }

        .user-menu-btn:hover {
            background: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .user-menu-btn.logged-in {
            border-color: var(--accent-color, #00d9ff);
            color: black;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.3);
        }

        .user-menu-btn.logged-in:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.6);
        }

        #userMenuIcon {
            image-rendering: pixelated;
            transition: all 0.3s ease;
        }

        .user-menu-btn.logged-in #userMenuIcon {
            width: 20px;
            height: 20px;
        }

        .user-menu-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 0;
            min-width: 200px;
            background: rgba(15, 15, 30, 0.98);
            backdrop-filter: blur(20px);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 8px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.3);
            animation: slideDown 0.3s ease;
        }

        .user-menu-dropdown.show {
            display: flex;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-menu-item {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: transparent;
            border: 2px solid transparent;
            color: var(--primary-color, #00ff9f);
            font-size: 20px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .user-menu-item:hover {
            background: rgba(0, 255, 159, 0.1);
            border-color: var(--primary-color, #00ff9f);
            transform: translateX(4px);
        }

        .user-menu-divider {
            height: 2px;
            background: var(--secondary-color, #ff00ff);
            margin: 4px 0;
            opacity: 0.3;
        }

        .user-menu-username {
            font-family: 'VT323', monospace;
            padding: 8px 16px;
            color: var(--accent-color, #00d9ff);
            font-size: 18px;
            text-align: center;
            border-bottom: 2px solid rgba(0, 217, 255, 0.3);
            margin-bottom: 4px;
        }
        /* ============= END USER MENU DROPDOWN ============= */

        /* ============= SOURCE MENU DROPDOWN ============= */
        .source-menu-container {
            position: relative !important;
            display: inline-block;
            overflow: visible;
        }

        .source-menu-btn {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--primary-color, #00ff9f);
            color: var(--primary-color, #00ff9f);
            font-size: 20px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 159, 0.3);
        }

        .source-menu-btn:hover {
            background: rgba(0, 255, 159, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .source-menu-dropdown {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 0;
            min-width: 220px;
            background: rgba(15, 15, 30, 0.98);
            backdrop-filter: blur(20px);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 8px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.3);
            animation: slideUp 0.3s ease;
        }

        .source-menu-dropdown.show {
            display: flex;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .source-menu-item {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: transparent;
            border: 2px solid transparent;
            color: var(--primary-color, #00ff9f);
            font-size: 20px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .source-menu-item:hover {
            background: rgba(0, 255, 159, 0.1);
            border-color: var(--primary-color, #00ff9f);
            transform: translateX(4px);
        }

        .source-menu-item.active {
            background: rgba(0, 255, 159, 0.15);
            border-color: var(--primary-color, #00ff9f);
        }

        .source-menu-divider {
            height: 2px;
            background: var(--secondary-color, #ff00ff);
            margin: 4px 0;
            opacity: 0.3;
        }

        .source-check {
            color: var(--accent-color, #00d9ff);
            font-size: 24px;
        }
        /* ============= END SOURCE MENU DROPDOWN ============= */

        /* ============= SOURCE TOOLTIP ARROW ============= */
        .source-tooltip-hint {
            position: absolute;
            left: calc(100% + 20px);
            top: 50%;
            transform: translateY(-50%);
            display: none;
            z-index: 100001;
            animation: gentleBounce 2s ease-in-out infinite;
        }

        .source-tooltip-hint.active {
            display: flex;
            align-items: center;
            gap: 0;
            flex-direction: row;
        }

        .source-tooltip-arrow-left {
            width: 0;
            height: 0;
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
            border-right: 15px solid var(--primary-color, #00ff9f);
            filter: drop-shadow(0 0 8px rgba(0, 255, 159, 0.5));
            flex-shrink: 0;
        }

        .source-tooltip-box {
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 8px;
            padding: 12px 40px 12px 16px;
            color: var(--primary-color, #00ff9f);
            font-family: 'VT323', monospace;
            font-size: 18px;
            white-space: nowrap;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.5);
            position: relative;
        }

        .source-tooltip-close {
            position: absolute;
            top: 4px;
            right: 6px;
            background: none;
            border: none;
            color: var(--secondary-color, #ff00ff);
            font-size: 24px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            line-height: 1;
            padding: 8px;
            transition: all 0.2s;
        }

        .source-tooltip-close:hover {
            color: var(--primary-color, #00ff9f);
            transform: scale(1.2);
        }

        @keyframes gentleBounce {
            0%, 100% {
                transform: translateY(-50%) translateX(0);
            }
            50% {
                transform: translateY(-50%) translateX(-8px);
            }
        }

        /* Responsive: Switch to top positioning on smaller screens */
        @media (max-width: 768px) {
            .source-tooltip-hint {
                left: auto;
                right: 0;
                top: auto;
                bottom: calc(100% + 15px);
                transform: none;
                animation: gentleBounceVertical 2s ease-in-out infinite;
            }

            .source-tooltip-hint.active {
                flex-direction: column;
                align-items: flex-end;
            }

            .source-tooltip-arrow-left {
                display: none;
            }

            .source-tooltip-hint::after {
                content: '';
                width: 0;
                height: 0;
                border-left: 12px solid transparent;
                border-right: 12px solid transparent;
                border-top: 15px solid var(--primary-color, #00ff9f);
                filter: drop-shadow(0 0 8px rgba(0, 255, 159, 0.5));
                margin-right: 20px;
            }

            .source-tooltip-box {
                white-space: normal;
                max-width: 200px;
                font-size: 16px;
                padding: 10px 36px 10px 14px;
            }

            @keyframes gentleBounceVertical {
                0%, 100% {
                    transform: translateY(0);
                }
                50% {
                    transform: translateY(5px);
                }
            }
        }

        /* Even smaller screens - compact text */
        @media (max-width: 480px) {
            .source-tooltip-box {
                max-width: 160px;
                font-size: 14px;
                padding: 8px 32px 8px 12px;
            }

            .source-tooltip-close {
                font-size: 20px;
                padding: 6px;
            }
        }
        /* ============= END SOURCE TOOLTIP ARROW ============= */
    </style>

    <!-- Monetag Ads Integration -->
    <!-- Push Notifications - Zone 10039525 -->
    <!-- <script src="//cdn.webpushs.com/js/push/af80e01f7f3e9a2cfc87f4f7c24833c8_1.js" async></script> -->

    <!-- In-Page Push - Zone 10039522 -->
    <!-- <script type="text/javascript" src="//pl25015888.cpmrevenuegate.com/bc/b9/07/bcb907ef732c6ac0daed2e2ad61d9bb0.js"></script> -->
</head>
<body>
    <!-- Monetag Ads - OnClick Popunder - Zone 10039521 -->
    <!-- <script type="text/javascript">
        atOptions = {
            'key' : '8af468976c973602ab1d62e5e750e8e3',
            'format' : 'iframe',
            'height' : 90,
            'width' : 728,
            'params' : {}
        };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/8af468976c973602ab1d62e5e750e8e3/invoke.js"></script>
-->

    <!-- CRT Boot Sequence Overlay (Phosphor Theme Only) -->
    <div id="crtBootOverlay" class="crt-boot-overlay">
        <div class="crt-boot-screen">
            <div class="crt-boot-line"></div>
            <div class="crt-boot-text"></div>
        </div>
    </div>

    <!-- CRT Scanlines Overlay (Phosphor Theme Only) -->
    <div id="crtScanlines" class="crt-scanlines-overlay"></div>

    <!-- CRT Curvature/Vignette Overlay (Phosphor Theme Only) -->
    <div id="crtCurvature" class="crt-curvature-overlay"></div>

    <!-- Floating Search (Phosphor Theme Only) -->
    <div id="floatingSearch" class="floating-search">
        <button class="floating-search-btn" onclick="toggleFloatingSearch()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
            </svg>
        </button>
        <div class="floating-search-panel">
            <div class="floating-search-header">
                <span class="terminal-prompt">&gt; SEARCH DATABASE</span>
                <button class="floating-search-close" onclick="toggleFloatingSearch()">&times;</button>
            </div>
            <div class="floating-search-input-wrapper">
                <span class="terminal-cursor">&gt;</span>
                <input type="text" id="floatingSearchInput" class="floating-search-input" placeholder="Enter search query..." autocomplete="off">
            </div>
            <div id="floatingSearchResults" class="floating-search-results"></div>
        </div>
    </div>

    <!-- Power LED Indicator (Phosphor Theme Only) -->
    <div id="crtPowerLed" class="crt-power-led"></div>


    <div id="bgAnimation"></div>

    <!-- User Menu Dropdown -->
    <div class="user-menu-container">
        <button class="user-menu-btn" id="userMenuBtn" onclick="toggleUserMenu()">
            <img id="userMenuIcon" src="data:image/png;base64,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
            rkJggg==" alt="User" style="width: 30px; height: 30px;">
            <span id="userMenuText" style="display: none;"></span>
        </button>
        <div class="user-menu-dropdown" id="userMenuDropdown">
            <!-- Content dynamically populated by updateAuthUI() -->
        </div>
    </div>

    <!-- Theme Selector Button -->
    <!-- Top-right Control Button -->
    <div style="position: fixed; top: 20px; right: 20px; z-index: 100001;">
        <button class="bg-animation-toggle" onclick="toggleWatchpartyPanel()"> Party</button>
    </div>

    <!-- Bottom-right Control Buttons -->
    <div style="position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 100000;">
        <button class="theme-selector-btn" onclick="toggleThemeSelector()"> Theme</button>
        <button class="bg-animation-toggle" onclick="toggleEffectsPanel()"> Effects</button>
    </div>

    <!-- Theme Selector Panel -->
    <div id="themeSelectorPanel" class="theme-selector-panel" style="bottom: 70px;">
        <div class="theme-selector-title">SELECT THEME</div>
    </div>

    <!-- Watchparty Panel -->
    <div id="watchpartyPanel" class="bg-effects-panel" style="top: 70px; min-width: 320px;">
        <div class="bg-effects-title">
            <span style="width: 24px;"></span>
            <span class="title-text">WATCHPARTY</span>
            <button class="panel-close-btn" onclick="document.getElementById('watchpartyPanel').classList.remove('active')"></button>
        </div>

        <div style="font-family: 'VT323', monospace; color: var(--accent-color, #00d9ff); font-size: 18px; margin-bottom: 16px; text-align: center; line-height: 1.4;">
            Watch together with friends! (chat only)
        </div>

        <div style="margin-bottom: 12px;">
            <label style="font-family: 'VT323', monospace; color: var(--primary-color, #00ff9f); font-size: 16px; display: block; margin-bottom: 6px;">Display Name</label>
            <input type="text" id="usernameInput" placeholder="Enter your name..."
                   style="font-family: 'VT323', monospace; width: 100%; padding: 12px; background: var(--bg-dark, #0f0f1e); border: 2px solid var(--secondary-color, #ff00ff); color: var(--primary-color, #00ff9f); font-size: 18px; border-radius: 8px; box-shadow: inset 1px 1px 0 rgba(0, 0, 0, 0.3);">
        </div>

        <button onclick="createWatchparty()" class="effects-btn" style="width: 100%; margin-bottom: 8px; padding: 12px; background: var(--primary-color, #00ff9f); border-color: var(--primary-color, #00ff9f); color: var(--bg-dark, #0f0f1e);">
            Create Party
        </button>

        <div style="font-family: 'VT323', monospace; text-align: center; color: #888; margin: 8px 0; font-size: 16px;">OR</div>

        <input type="text" id="joinRoomCodeInput" placeholder="Room Code"
               style="font-family: 'VT323', monospace; width: 100%; padding: 12px; background: var(--bg-dark, #0f0f1e); border: 2px solid var(--accent-color, #00d9ff); color: var(--primary-color, #00ff9f); font-size: 18px; margin-bottom: 8px; text-align: center; text-transform: uppercase; letter-spacing: 2px; font-weight: 600; border-radius: 8px; box-shadow: inset 1px 1px 0 rgba(0, 0, 0, 0.3);">

        <button onclick="joinWatchparty()" class="effects-btn" style="width: 100%; padding: 12px;">
            Join Party
        </button>

    </div>

    <!-- Background Effects Panel -->
    <div id="bgEffectsPanel" class="bg-effects-panel" style="bottom: 70px;">
        <div class="bg-effects-title">
            <span style="width: 24px;"></span>
            <span class="title-text">BG EFFECTS</span>
            <button class="panel-close-btn" onclick="document.getElementById('bgEffectsPanel').classList.remove('active')"></button>
        </div>
        <div class="effect-option" data-effect="matrix" onclick="toggleEffect('matrix')">
            <span class="effect-name">Matrix Rain</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effect-option" data-effect="stars" onclick="toggleEffect('stars')">
            <span class="effect-name">Pixel Stars</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effect-option" data-effect="particles" onclick="toggleEffect('particles')">
            <span class="effect-name">Particles</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effect-option" data-effect="scanline" onclick="toggleEffect('scanline')">
            <span class="effect-name">Scanline</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effects-actions">
            <button class="effects-btn" onclick="enableAllEffects()">All ON</button>
            <button class="effects-btn" onclick="disableAllEffects()">All OFF</button>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <div style="flex: 1;">
                <h1 onclick="location.reload()" style="cursor: pointer;">GlitchBox</h1>
                <p>your one stop streaming shop</p>
            </div>
            <!-- Old auth buttons hidden - now using top-left user menu -->
            <div id="authButtons" style="display: none;">
                <button class="btn" onclick="showLoginModal()" style="padding: 10px 20px;">Login</button>
                <button class="btn" onclick="showRegisterModal()" style="padding: 10px 20px;">Sign Up</button>
            </div>
            <div id="userMenu" style="display: none;">
                <span id="usernameDisplay" style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 20px;"></span>
                <button class="btn" onclick="showFriendsModal()" style="padding: 10px 20px; display: flex; align-items: center; gap: 8px;">
                    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABaAAAAAQAAAFoAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABSgAwAEAAAAAQAAABQAAAAAeyom9gAAAAlwSFlzAAAN1wAADdcBQiibeAAAAWRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD53d3cuaW5rc2NhcGUub3JnPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgqyyWIhAAACrUlEQVQ4EeVSW0tUURT+zmVGR2siK1EyKkwlerBApeghIYssXx2kt0jtIiISEtWTBtZDLxIEXR4KQfCSUC+KRkUlRQgmCg5OWqHOeM3LONOcOWf2aa1xDkww4Q9wDWv2Pnt/+1vrW2sBW86kOMUq7TvJd8adhWlfQf47dpZGazu5PfbNC9+Vkxv8wSRs++x2e21d/c2ylMgnFaFJQFIQiZh40j7dNL+ktzAoPT2jrvrq9RJl/DmwNgUoCoKaabS81ZrDBh4SZEolK87Ozi7Kzc1taLpVjmRTA9YpcckGhAV+ekM1QyOry0jJw7H8vJq7taXAQA+wuEDp2BBaF6p7TjSMz0UWJxbFV5ZslpScRn9/F/CjkhJnBQp5zFJVuC5/AZxl6HjRCLSeACIUVJItBECxzzzw482YsSHZDI5SsteIzE+gODJ+QrJNOQmYeA28GgSE/i8ZYwRlZfIG2AhjUu0NksA3CY2E6AEg4Et4G38Yy5uVx0mIR1h7iTDUqM0syiIzn43/EpgqQSZAFPM/PjqP3tNzWVVROjWr3XZVD0OjrsJGMbgeCgUgssr6Ebi/rze7F0Rz5TOSzaSWGBo6zTDhehTAzIq4k6TgvGoY6HVPBlbJcWBvMqoqspBzKBU+7x88bptB60sfwoYY4NzdsxqynBKunEpGZpoEj0/g6UcNnYM8/3hH/ll1OHB8f4ajwOm0o+fDEi4U70bO4W1YXtHR3TeP/CPbEQjoR+EPITVFRvc3Ha6CJGTukeFdEegZ1VF0UMWqJgq9ywIS1do8e3IXersKqdOx3nM8yxwKLl4aAqYX0HZjBw17AgyV4dz9NfTxHPL8eH4F0XjPQ1OzAbaeRNukyhgeo/n0CzR2BGkuucQWghpPP66pZ15EZ5HfvLeS2WSN8m+C2YrXfwHqzfa7JgSB/AAAAABJRU5ErkJggg==" alt="Friends" style="width: 20px; height: 20px; image-rendering: pixelated;">
                    <span>Friends</span>
                    <span id="friendRequestCount" style="display: none; color: var(--secondary-color); font-weight: bold;"></span>
                </button>
                <button class="btn" onclick="logout()" style="padding: 10px 20px;">Logout</button>
            </div>
        </div>

        <div class="search-section">
            <div class="search-box">
                <div class="search-container">
                    <input type="text" id="searchInput" class="search-input"
                           placeholder="Search movies & TV shows..."
                           autocomplete="off">
                    <div id="searchAutocomplete" class="search-autocomplete"></div>
                </div>
                <button onclick="searchContent()" class="btn" id="searchBtn">Search</button>
            </div>

            <div id="statusBar" class="status-bar" style="display: none;"></div>
            <div id="errorMessage" class="error" style="display: none;"></div>
        </div>

        <div class="player-section" id="playerSection" style="display: none;">
            <div id="currentContent" class="current-content" style="display: none;">
                <div id="backdropImage" class="backdrop-image"></div>
                <div id="playerBgAnimation" class="player-bg-animation"></div>
                <div class="poster-container">
                    <img id="currentPoster" class="current-content-poster" alt="Poster">
                    <button id="playerWatchlistBtn" class="bg-animation-toggle" onclick="togglePlayerWatchlist()" style="display: none;">
                        <span id="playerWatchlistBtnText"> Add to Watchlist</span>
                    </button>
                </div>
                <div class="current-content-info">
                    <h3 id="currentTitle">Title</h3>
                    <p id="currentYear">Year</p>

                    <!-- OMDB Ratings -->
                    <div id="omdbRatings" class="omdb-ratings" style="display: none;">
                        <div class="ratings-container">
                            <div class="rating-item">
                                <span class="rating-source">IMDb</span>
                                <span class="rating-value" id="imdbRating">N/A</span>
                            </div>
                            <div class="rating-item">
                                <span class="rating-source">Rotten Tomatoes</span>
                                <span class="rating-value" id="rtRating">N/A</span>
                            </div>
                            <div class="rating-item">
                                <span class="rating-source">Metacritic</span>
                                <span class="rating-value" id="metacriticRating">N/A</span>
                            </div>
                        </div>
                    </div>

                    <p id="currentOverview">Overview...</p>

                    <!-- OMDB Details -->
                    <div id="omdbDetails" class="omdb-details" style="display: none;">
                        <div id="castSection" class="cast-section" style="display: none;">
                            <h3 style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 28px; margin-bottom: 12px;">Cast</h3>
                            <div id="castGrid" class="cast-grid"></div>
                        </div>
                        <p id="omdbActors" class="detail-item" style="display: none;"><strong>Cast:</strong> <span></span></p>
                        <p id="omdbDirector" class="detail-item"><strong>Director:</strong> <span></span></p>
                        <p id="omdbGenre" class="detail-item"><strong>Genre:</strong> <span></span></p>
                        <p id="omdbRated" class="detail-item"><strong>Rating:</strong> <span></span></p>
                        <p id="omdbRuntime" class="detail-item"><strong>Runtime:</strong> <span></span></p>
                        <p id="omdbAwards" class="detail-item awards"><strong>Awards:</strong> <span></span></p>
                    </div>

                    <!-- Episode Selection and Description Container -->
                    <div id="tvControls" class="tv-controls" style="display: none;">
                        <button id="seasonButton" class="bg-animation-toggle" onclick="toggleSeasonPanel()" style="margin-right: 12px;">
                            <span id="seasonButtonText">Season 1</span>
                        </button>
                        <button id="episodeButton" class="bg-animation-toggle" onclick="toggleEpisodePanel()" style="min-width: 400px; text-align: left;">
                            <span id="episodeButtonText">Episode 1</span>
                        </button>

                        <!-- Episode Description -->
                        <div id="episodeDescription" class="episode-description" style="display: none;">
                            <p id="episodeDescriptionText"></p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="player-container">
                <div id="playerPlaceholder" class="player-placeholder">
                    <div>
                        <h3>Select content to start watching</h3>
                        <p>Search for movies or TV shows above, or browse popular content</p>
                    </div>
                </div>
                <iframe id="contentPlayer" src="about:blank" allowfullscreen webkitallowfullscreen mozallowfullscreen allow="fullscreen" style="display: none;"></iframe>
                <video id="playerVideo" controls style="display: none; width: 100%; height: 100%; max-width: 100%; background: #000; object-fit: contain;"></video>
            </div>

            <div class="player-controls">
                <button onclick="playNextEpisode()" class="btn" id="nextEpisodeBtn" style="display: none;">Next Episode</button>
                <button onclick="toggleFullscreen()" class="btn btn-secondary">Fullscreen</button>
                <button id="sportsSourceBtn" class="btn btn-secondary" onclick="switchSportsSource()" style="display: none;" title="Switch between available sources">
                    <span id="sportsSourceBtnText">Source 1</span> 
                </button>
                <button onclick="toggleComments()" class="btn btn-secondary" id="commentsBtn" style="display: none;"> Comments</button>
                <button onclick="copyCurrentUrl()" class="btn btn-secondary">Copy URL</button>
                <button onclick="stopPlayback()" class="btn btn-secondary" id="stopBtn" style="display: none;">Stop</button>

                <!-- Source Dropdown Menu -->
                <div class="source-menu-container" id="sourceMenuContainer" style="display: none;">
                    <button class="source-menu-btn" id="videoSourceBtn" onclick="toggleSourceMenu()">
                        <span id="videoSourceBtnText">Source: VidSrc</span>
                    </button>
                    <div class="source-menu-dropdown" id="sourceMenuDropdown">
                        <button class="source-menu-item" onclick="selectVideoSource('vidsrc'); closeSourceMenu();">
                            <span>VidSrc</span>
                            <span class="source-check" id="vidsrc-check"></span>
                        </button>
                        <button class="source-menu-item" onclick="selectVideoSource('vidking'); closeSourceMenu();">
                            <span>VidKing</span>
                            <span class="source-check" id="vidking-check" style="display: none;"></span>
                        </button>
                        <button class="source-menu-item" onclick="selectVideoSource('superembed'); closeSourceMenu();">
                            <span>SuperEmbed</span>
                            <span class="source-check" id="superembed-check" style="display: none;"></span>
                        </button>
                    </div>

                    <!-- Tooltip beside source button -->
                    <div class="source-tooltip-hint" id="sourceTooltipHint">
                        <div class="source-tooltip-arrow-left"></div>
                        <div class="source-tooltip-box">
                            <button class="source-tooltip-close" onclick="dismissSourceHint()"></button>
                            Change source if stuck or not loading
                        </div>
                    </div>
                </div>
            </div>

            <!-- Old Watchparty Menu Modal (Hidden - Using Panel Instead) -->
            <div id="watchpartyMenuModal" style="display: none !important; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 99999; align-items: center; justify-content: center; padding: 20px;" onclick="closeWatchpartyMenu()">
                <div style="max-width: 450px; width: 90%; background: #0f0f1e; border: 4px solid #ff00ff; padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px rgba(255, 0, 255, 0.5), inset 0 0 20px rgba(255, 0, 255, 0.1);" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="margin: 0; font-family: 'Press Start 2P', cursive; color: #ff00ff; font-size: 18px; font-weight: 400; text-shadow: 2px 2px 0 #00d9ff;">Watchparty</h2>
                        <button onclick="closeWatchpartyMenu()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>

                    <div style="margin-bottom: 24px;">
                        <p style="font-family: 'VT323', monospace; color: #00d9ff; font-size: 20px; margin-bottom: 20px;">Watch together with friends! Host controls playback and everyone can chat.</p>

                        <div style="margin-bottom: 20px;">
                            <label style="font-family: 'VT323', monospace; color: #00ff9f; font-size: 20px; display: block; margin-bottom: 8px;">Display Name</label>
                            <input type="text" id="usernameInput" placeholder="Enter your name..."
                                   style="font-family: 'VT323', monospace; width: 100%; padding: 16px; background: #1a1a2e; border: 3px solid #ff00ff; color: #00ff9f; font-size: 22px; box-shadow: inset 2px 2px 0 rgba(0, 0, 0, 0.3);">
                        </div>

                        <button onclick="createWatchparty()" class="btn" style="width: 100%; margin-bottom: 12px; padding: 16px;">
                            Create Watchparty
                        </button>

                        <div style="font-family: 'VT323', monospace; text-align: center; color: #888; margin: 16px 0; font-size: 20px;">OR</div>

                        <input type="text" id="joinRoomCodeInput" placeholder="Enter Room Code (e.g., ABC123)"
                               style="font-family: 'VT323', monospace; width: 100%; padding: 16px; background: #1a1a2e; border: 3px solid #00d9ff; color: #00ff9f; font-size: 22px; margin-bottom: 12px; text-align: center; text-transform: uppercase; letter-spacing: 3px; font-weight: 600; box-shadow: inset 2px 2px 0 rgba(0, 0, 0, 0.3);">

                        <button onclick="joinWatchparty()" class="btn btn-secondary" style="width: 100%; padding: 16px;">
                            Join Watchparty
                        </button>
                    </div>
                </div>
            </div>

            <!-- Sync Indicator -->
            <div id="syncIndicator" class="sync-indicator"></div>

            <!-- Comments Section -->
            <div id="commentsSection" style="display: none; background: #0f0f1e; border: 3px solid var(--accent-color, #00d9ff); padding: 24px; margin-top: 24px; box-shadow: 0 0 15px rgba(0, 217, 255, 0.3);">
                <h3 style="font-family: 'Press Start 2P', cursive; font-size: 16px; color: var(--accent-color, #00d9ff); margin-bottom: 20px; text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);">
                    Friends' Comments
                </h3>

                <div id="commentsList" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
                    <!-- Comments will be loaded here -->
                </div>

                <div id="addCommentSection" style="border-top: 2px solid rgba(0, 217, 255, 0.3); padding-top: 16px;">
                    <textarea id="commentTextarea" placeholder="Share your thoughts with friends..."
                              style="width: 100%; padding: 12px; background: #1a1a2e; border: 2px solid var(--secondary-color, #ff00ff); color: #e0e0e0; font-family: 'VT323', monospace; font-size: 18px; resize: none; overflow: hidden; min-height: 40px; max-height: 200px; border-radius: 4px;"
                              maxlength="500"
                              rows="1"
                              oninput="autoResizeTextarea(this); updateCharCount();"></textarea>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 12px;">
                        <span id="commentCharCount" style="color: #666; font-family: 'VT323', monospace; font-size: 14px;">0/500</span>
                        <button onclick="submitComment()" class="btn" style="padding: 10px 24px;">Post Comment</button>
                    </div>
                </div>
            </div>

            <!-- Watchlist Modal -->
            <div id="watchlistModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 2147483647; align-items: center; justify-content: center; padding: 20px;" onclick="closeWatchlistModal()">
                <div style="max-width: 600px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 id="watchlistModalTitle" style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> ADD TO WATCHLIST</h2>
                        <button onclick="closeWatchlistModal()" class="btn btn-secondary" style="padding: 12px 24px;"> Close</button>
                    </div>
                    <div id="watchlistModalContent">
                        <!-- Content for manage lists will be loaded here -->
                    </div>
                    <div id="watchlistPanelContent" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Watchlist options will be loaded dynamically -->
                    </div>
                    <div id="watchlistCreateSection" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid var(--primary-color, #00ff9f);">
                        <div style="font-family: 'VT323', monospace; font-size: 24px; margin-bottom: 12px; color: var(--primary-color, #00ff9f); text-align: center; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));">CREATE NEW WATCHLIST</div>
                        <input type="text" id="newWatchlistName" placeholder="Enter watchlist name..."
                               style="font-family: 'VT323', monospace; width: 100%; padding: 12px; background: var(--bg-dark, #0f0f1e); border: 2px solid var(--primary-color, #00ff9f); color: var(--primary-color, #00ff9f); font-size: 18px; margin-bottom: 12px;">
                        <button onclick="createNewWatchlist()" class="effects-btn" style="width: 100%; padding: 12px;">Create Watchlist</button>
                    </div>
                </div>
            </div>

            <!-- Video Source Selector Modal -->
            <div id="sourceSelectorModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 10000; align-items: center; justify-content: center; padding: 20px;" onclick="closeSourceSelector()">
                <div style="max-width: 500px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> SELECT SOURCE</h2>
                        <button onclick="closeSourceSelector()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>

                    <p style="font-family: 'VT323', monospace; color: #00d9ff; font-size: 20px; margin-bottom: 24px; line-height: 1.4;">
                        Choose a streaming source. Different sources may have better quality or reliability.
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="selectVideoSource('vidsrc')" class="btn" style="width: 100%; padding: 16px; text-align: left; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 18px;"> VidSrc</span>
                            <span id="vidsrc-check" style="color: #00ff9f; display: none;"></span>
                        </button>
                        <button onclick="selectVideoSource('vidking')" class="btn" style="width: 100%; padding: 16px; text-align: left; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 18px;"> VidKing</span>
                            <span id="vidking-check" style="color: #00ff9f; display: none;"></span>
                        </button>
                        <button onclick="selectVideoSource('superembed')" class="btn" style="width: 100%; padding: 16px; text-align: left; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 18px;"> SuperEmbed</span>
                            <span id="superembed-check" style="color: #00ff9f; display: none;"></span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Subtitle Selection Modal -->
            <div id="subtitleModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; padding: 40px; overflow-y: auto;">
                <div style="max-width: 800px; margin: 0 auto; background: #0f0f1e; border: 4px solid #00d9ff; padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px rgba(0, 217, 255, 0.5), inset 0 0 20px rgba(0, 217, 255, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 class="section-title" style="margin: 0;">Select Subtitles</h2>
                        <button onclick="closeSubtitleModal()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="color: #a1a1a6; display: block; margin-bottom: 8px;">Language:</label>
                        <select id="subtitleLanguage" class="year-input" style="width: 200px;" onchange="loadSubtitles()">
                            <option value="eng">English</option>
                            <option value="spa">Spanish</option>
                            <option value="fre">French</option>
                            <option value="ger">German</option>
                            <option value="ita">Italian</option>
                            <option value="por">Portuguese</option>
                            <option value="ara">Arabic</option>
                            <option value="chi">Chinese</option>
                            <option value="jpn">Japanese</option>
                            <option value="kor">Korean</option>
                            <option value="rus">Russian</option>
                            <option value="hin">Hindi</option>
                        </select>
                    </div>

                    <!-- Info Box -->
                    <div style="background: rgba(0, 122, 255, 0.1); border: 1px solid rgba(0, 122, 255, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <div style="font-size: 24px;"></div>
                            <div style="flex: 1;">
                                <div style="color: #007AFF; font-weight: 600; margin-bottom: 4px;">How Subtitles Work</div>
                                <div style="color: #a1a1a6; font-size: 13px;">
                                    Click "Open Search" to find subtitles, then download and paste the URL below. The subtitle will be converted to VTT format and ready to download or use with external players.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="subtitleList" style="max-height: 400px; overflow-y: auto;">
                        <div style="text-align: center; color: #666; padding: 40px;">
                            Loading subtitles...
                        </div>
                    </div>

                    <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                        <label style="color: #a1a1a6; display: block; margin-bottom: 8px;">Or paste subtitle URL (SRT/VTT):</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="customSubtitleUrl" class="search-input" placeholder="https://example.com/subtitle.srt" style="flex: 1;">
                            <button onclick="loadCustomSubtitle()" class="btn">Load</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Login Modal -->
        <div id="loginModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; padding: 20px;">
            <div style="max-width: 450px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5));" onclick="event.stopPropagation()">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-family: 'Press Start 2P', cursive; font-size: 18px; color: var(--primary-color, #00ff9f); margin: 0;">Login</h2>
                    <button onclick="closeLoginModal()" style="background: none; border: none; color: #ff00ff; font-size: 40px; cursor: pointer; padding: 8px 16px; line-height: 1; transition: color 0.2s;"></button>
                </div>
                <div id="loginError" style="display: none; color: #ff6b6b; margin-bottom: 16px; padding: 12px; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 4px;"></div>
                <form id="loginForm" onsubmit="handleLogin(event)">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Username</label>
                        <input type="text" id="loginUsername" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Password</label>
                        <input type="password" id="loginPassword" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <button type="submit" class="btn" style="width: 100%; padding: 14px; font-size: 16px;">Login</button>
                    <div style="text-align: center; margin-top: 16px; color: #a1a1a6;">
                        Don't have an account? <a href="#" onclick="event.preventDefault(); closeLoginModal(); showRegisterModal();" style="color: var(--primary-color); text-decoration: none;">Sign up</a>
                    </div>
                </form>
            </div>
        </div>

        <!-- Register Modal -->
        <div id="registerModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; padding: 20px;">
            <div style="max-width: 450px; width: 90%; background: #0f0f1e; border: 4px solid var(--secondary-color, #ff00ff); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--secondary-glow, rgba(255, 0, 255, 0.5));" onclick="event.stopPropagation()">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-family: 'Press Start 2P', cursive; font-size: 18px; color: var(--secondary-color, #ff00ff); margin: 0;">Sign Up</h2>
                    <button onclick="closeRegisterModal()" style="background: none; border: none; color: #ff00ff; font-size: 40px; cursor: pointer; padding: 8px 16px; line-height: 1; transition: color 0.2s;"></button>
                </div>
                <div id="registerError" style="display: none; color: #ff6b6b; margin-bottom: 16px; padding: 12px; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 4px;"></div>
                <form id="registerForm" onsubmit="handleRegister(event)">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Username</label>
                        <input type="text" id="registerUsername" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Email</label>
                        <input type="email" id="registerEmail" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Password</label>
                        <input type="password" id="registerPassword" class="search-input" required minlength="6" style="width: 100%; padding: 12px;">
                    </div>
                    <button type="submit" class="btn" style="width: 100%; padding: 14px; font-size: 16px;">Create Account</button>
                    <div style="text-align: center; margin-top: 16px; color: #a1a1a6;">
                        Already have an account? <a href="#" onclick="event.preventDefault(); closeRegisterModal(); showLoginModal();" style="color: var(--secondary-color); text-decoration: none;">Login</a>
                    </div>
                </form>
            </div>
        </div>

        <!-- Friends Modal -->
        <div id="friendsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; padding: 40px; overflow-y: auto;">
            <div style="max-width: 700px; margin: 0 auto; background: #0f0f1e; border: 4px solid #00d9ff; padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px rgba(0, 217, 255, 0.5);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-family: 'Press Start 2P', cursive; font-size: 18px; color: #00d9ff; margin: 0;">Friends</h2>
                    <button onclick="closeFriendsModal()" style="background: none; border: none; color: #ff00ff; font-size: 40px; cursor: pointer; padding: 8px 16px; line-height: 1; transition: color 0.2s;"></button>
                </div>

                <!-- Friend Requests -->
                <div id="friendRequestsSection" style="margin-bottom: 24px;">
                    <h3 style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 20px; margin-bottom: 12px;">Friend Requests</h3>
                    <div id="friendRequestsList"></div>
                </div>

                <!-- Add Friend -->
                <div style="margin-bottom: 24px;">
                    <h3 style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 20px; margin-bottom: 12px;">Add Friend</h3>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="friendSearchInput" class="search-input" placeholder="Search username..." oninput="searchFriends()" style="flex: 1; padding: 12px;">
                    </div>
                    <div id="friendSearchResults" style="margin-top: 12px;"></div>
                </div>

                <!-- My Friends -->
                <div>
                    <h3 style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 20px; margin-bottom: 12px;">My Friends</h3>
                    <div id="friendsList"></div>
                </div>
            </div>
        </div>

        <div class="popular-section">
            <div class="tabs">
                <button class="tab active" onclick="showTab('continue-watching')" id="continueWatchingTab">Continue Watching</button>
                <button class="tab" onclick="showTab('watchlist')" id="watchlistTab">My Watchlist</button>
                <button class="tab" onclick="showTab('statistics')" id="statisticsTab">Stats</button>
                <button class="tab" onclick="showTab('movies')" id="moviesTab">Movies</button>
                <button class="tab" onclick="showTab('tv-shows')" id="tvShowsTab">TV Shows</button>
                <button class="tab" onclick="showTab('recommendations')" id="recommendationsTab">Recommendations</button>
                <button class="tab" onclick="showTab('sports')" id="sportsTab">Live Sports</button>
                <button class="tab" onclick="showTab('channels')" id="channelsTab">Live Channels</button>
            </div>

            <!-- Content Type Filters (shown for Movies/TV Shows tabs) -->
            <div id="contentTypeFilters" style="display: none; margin-top: 16px; text-align: center; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button class="bg-animation-toggle active" onclick="setContentFilter('popular')" id="popularFilterBtn">
                     Popular
                </button>
                <button class="bg-animation-toggle" onclick="setContentFilter('trending')" id="trendingFilterBtn">
                     Trending
                </button>
                <button class="bg-animation-toggle" onclick="setContentFilter('now-playing')" id="nowPlayingFilterBtn">
                     Now Playing
                </button>
                <button class="bg-animation-toggle" onclick="setContentFilter('upcoming')" id="upcomingFilterBtn" style="display: none;">
                     Upcoming
                </button>
                <button class="bg-animation-toggle" onclick="toggleGenreModal()" id="genreFilterBtn">
                     Filter by Genre
                </button>
                <button class="bg-animation-toggle" onclick="toggleLanguageModal()" id="languageFilterBtn">
                     Filter by Language
                </button>
            </div>

            <!-- Active Filters Display -->
            <div id="activeFiltersDisplay" style="display: none; margin-top: 12px; text-align: center; font-family: 'VT323', monospace; font-size: 18px;">
                <span id="activeGenreDisplay" style="display: none; color: var(--primary-color, #00ff9f); text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5)); margin-right: 16px;">
                    GENRE: <span id="genreName" style="color: var(--accent-color, #00d9ff);"></span>
                    <button onclick="clearGenreFilter()" style="background: none; border: none; color: var(--secondary-color, #ff00ff); cursor: pointer; font-family: 'VT323', monospace; font-size: 18px; margin-left: 4px;"></button>
                </span>
                <span id="activeLanguageDisplay" style="display: none; color: var(--primary-color, #00ff9f); text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));">
                    LANGUAGE: <span id="languageName" style="color: var(--accent-color, #00d9ff);"></span>
                    <button onclick="clearLanguageFilter()" style="background: none; border: none; color: var(--secondary-color, #ff00ff); cursor: pointer; font-family: 'VT323', monospace; font-size: 18px; margin-left: 4px;"></button>
                </span>
            </div>

            <!-- Genre Filter Button (legacy - now integrated into contentTypeFilters) -->
            <div id="genreFilterContainer" style="display: none; margin-top: 16px; text-align: center;">
                <button class="bg-animation-toggle" onclick="toggleGenreModal()">
                     Filter by Genre
                </button>
            </div>

            <!-- Genre Modal Popup -->
            <div id="genreModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 2147483647; align-items: center; justify-content: center; padding: 20px;" onclick="closeGenreModal()">
                <div style="max-width: 600px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> SELECT GENRE</h2>
                        <button onclick="closeGenreModal()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>
                    <div id="genreList" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Genres will be loaded dynamically -->
                    </div>
                </div>
            </div>

            <!-- Language Modal Popup -->
            <div id="languageModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 2147483647; align-items: center; justify-content: center; padding: 20px;" onclick="closeLanguageModal()">
                <div style="max-width: 500px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> SELECT LANGUAGE</h2>
                        <button onclick="closeLanguageModal()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>
                    <div id="languageList" style="display: flex; flex-direction: column; gap: 8px;">
                        <button class="btn btn-primary" onclick="filterByLanguage(null)" style="width: 100%; padding: 12px; text-align: left;">All Languages</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('en')" style="width: 100%; padding: 12px; text-align: left;">English</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('ar')" style="width: 100%; padding: 12px; text-align: left;">Arabic</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('ko')" style="width: 100%; padding: 12px; text-align: left;">Korean</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('ja')" style="width: 100%; padding: 12px; text-align: left;">Japanese</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('zh')" style="width: 100%; padding: 12px; text-align: left;">Chinese</button>
                    </div>
                </div>
            </div>

            <!-- Season Panel -->
            <div id="seasonPanel" class="bg-effects-panel" style="position: absolute; display: none; width: 180px; max-height: 400px; overflow-y: auto; z-index: 2147483647;">
                <div class="bg-effects-title">
                    <span style="width: 24px;"></span>
                    <span class="title-text">SELECT SEASON</span>
                    <button class="panel-close-btn" onclick="document.getElementById('seasonPanel').style.display='none'"></button>
                </div>
                <div id="seasonList" style="display: flex; flex-direction: column; gap: 6px;">
                    <!-- Seasons will be loaded dynamically -->
                </div>
            </div>

            <!-- Episode Panel -->
            <div id="episodePanel" class="bg-effects-panel" style="position: absolute; display: none; width: 400px; max-height: 400px; overflow-y: auto; z-index: 2147483647;">
                <div class="bg-effects-title">
                    <span style="width: 24px;"></span>
                    <span class="title-text">SELECT EPISODE</span>
                    <button class="panel-close-btn" onclick="document.getElementById('episodePanel').style.display='none'"></button>
                </div>
                <div id="episodeList" style="display: flex; flex-direction: column; gap: 6px;">
                    <!-- Episodes will be loaded dynamically -->
                </div>
            </div>

            <!-- Watchlist Panel -->
            <div id="watchlistPanel" class="bg-effects-panel" style="position: absolute; display: none; width: 300px; max-height: 400px; overflow-y: auto; z-index: 2147483647;">
                <div class="bg-effects-title">
                    <span style="width: 24px;"></span>
                    <span class="title-text" id="watchlistPanelTitle">ADD TO WATCHLIST</span>
                    <button class="panel-close-btn" onclick="document.getElementById('watchlistPanel').style.display='none'; window.pendingWatchlistPanelItem=null;"></button>
                </div>
                <div id="watchlistPanelList" style="display: flex; flex-direction: column; gap: 6px;">
                    <!-- Watchlists will be loaded dynamically -->
                </div>
                <div id="watchlistPanelCreate" style="margin-top: 12px; padding-top: 12px; border-top: 2px solid rgba(255, 255, 255, 0.1);">
                    <input type="text" id="newWatchlistNamePanel" placeholder="New watchlist name..."
                           style="font-family: 'VT323', monospace; width: 100%; padding: 10px; background: var(--bg-dark, #0f0f1e); border: 2px solid var(--primary-color, #00ff9f); color: var(--primary-color, #00ff9f); font-size: 16px; margin-bottom: 8px; border-radius: 4px;">
                    <button onclick="createWatchlistFromPanel()" class="effects-btn" style="width: 100%; padding: 10px; font-size: 16px;">Create New List</button>
                </div>
            </div>

            <div id="contentResults" class="content-results"></div>
            <div id="continueWatchingDisplay" class="horizontal-scroll-container" style="display: none;"></div>
            <div id="watchlistDisplay" class="horizontal-scroll-container" style="display: none;"></div>
            <div id="statisticsDisplay" style="display: none; padding: 20px;"></div>
            <div id="sportsDisplay" style="display: none; padding: 20px;">
                <!-- Sports Search -->
                <div style="margin-bottom: 24px;">
                    <div style="position: relative; display: flex; gap: 8px; align-items: center;">
                        <input type="text" id="sportsSearchInput" class="search-input"
                               placeholder="Search matches, teams, sports..."
                               autocomplete="off"
                               oninput="searchSportsMatches()"
                               onkeypress="if(event.key === 'Enter') searchSportsMatches()"
                               style="flex: 1;">
                        <button onclick="clearSportsSearch()" class="btn btn-secondary" style="padding: 12px 24px; font-size: 20px; display: none; white-space: nowrap;" id="clearSportsSearchBtn">
                            Clear
                        </button>
                    </div>
                </div>

                <!-- Sports Filters -->
                <div id="sportsFilters" style="margin-bottom: 24px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;">
                    <button class="bg-animation-toggle" onclick="toggleLiveFilter()" id="liveSportsBtn">
                         Live Now
                    </button>
                    <div id="sportTypeButtons" style="display: contents;"></div>
                </div>

                <!-- Sports Matches Grid -->
                <div id="sportsMatches" class="content-results" style="margin-top: 24px;"></div>
            </div>
            <div id="channelsDisplay" style="display: none; padding: 20px;">
                <!-- Channels Search -->
                <div style="margin-bottom: 24px;">
                    <div style="position: relative; display: flex; gap: 8px; align-items: center;">
                        <input type="text" id="channelsSearchInput" class="search-input"
                               placeholder="Search channels..."
                               autocomplete="off"
                               oninput="searchChannels()"
                               onkeypress="if(event.key === 'Enter') searchChannels()"
                               style="flex: 1;">
                        <button onclick="clearChannelsSearch()" class="btn btn-secondary" style="padding: 12px 24px; font-size: 20px; display: none; white-space: nowrap;" id="clearChannelsSearchBtn">
                            Clear
                        </button>
                    </div>
                </div>

                <!-- Country Filters -->
                <div id="countryFilters" style="margin-bottom: 24px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center;">
                    <div id="countryFilterButtons" style="display: contents;"></div>
                </div>

                <!-- Channels Grid -->
                <div id="liveChannels" class="content-results" style="margin-top: 24px;"></div>
            </div>
            <div id="loadingIndicator" class="loading" style="display: none;">
                <div>Loading content...</div>
            </div>
        </div>
    </div>

    <!-- Watchparty Sidebar (Outside Container) -->
    <div id="watchpartySidebar" class="watchparty-sidebar">
        <div class="watchparty-header">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                <div class="watchparty-title">
                    Watchparty
                </div>
                <div style="display: flex; align-items: center; gap: 6px; flex: 1; justify-content: center;">
                    <span class="watchparty-room-code" id="watchpartyRoomCodeLabel">Code:</span>
                    <div class="room-code-display" id="watchpartyRoomCode" onclick="copyRoomCode()" title="Click to copy">------</div>
                </div>
                <button class="watchparty-close" onclick="event.stopPropagation(); leaveWatchparty();"></button>
            </div>

            <!-- Leave Watchparty Confirmation Popup -->
            <div id="leaveWatchpartyModal" style="display: none; position: absolute; top: 40px; right: 0; background: #0f0f1e; border: 3px solid var(--secondary-color, #ff00ff); padding: 16px; box-shadow: 0 0 0 3px #1a1a2e, 0 0 20px rgba(255, 0, 255, 0.7), inset 0 0 15px rgba(255, 0, 255, 0.1); border-radius: 8px; z-index: 100000; min-width: 200px; max-width: 250px;">
                <div style="text-align: center; margin-bottom: 12px;">
                    <h3 style="margin: 0 0 8px 0; font-family: 'Press Start 2P', cursive; color: var(--secondary-color, #ff00ff); font-size: 12px; font-weight: 400; text-shadow: 1px 1px 0 var(--accent-color, #00d9ff);">Leave Party?</h3>
                    <p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; color: var(--accent-color, #00d9ff); font-size: 13px; line-height: 1.4; margin: 0;">
                        Exit the watchparty?
                    </p>
                </div>

                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button onclick="event.stopPropagation(); confirmLeaveWatchparty();" class="btn" style="width: 100%; padding: 10px; background: var(--secondary-color, #ff00ff); border-color: var(--secondary-color, #ff00ff); font-size: 13px;">
                        Yes, Leave
                    </button>
                    <button onclick="event.stopPropagation(); closeLeaveWatchpartyModal();" class="btn btn-secondary" style="width: 100%; padding: 10px; font-size: 13px;">
                        Cancel
                    </button>
                </div>
            </div>

            <button class="copy-room-code" onclick="copyRoomCode()" style="display: none;">Copy Room Code</button>
        </div>

        <div class="watchparty-users">
            <div class="watchparty-users-title">Watching (<span id="userCount">0</span>)</div>
            <div id="watchpartyUserList"></div>
        </div>

        <div class="watchparty-chat">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <div id="replyIndicator" class="reply-indicator" style="display: none;">
                    <span id="replyingToText"></span>
                    <button onclick="cancelReply()"></button>
                </div>
                <div class="chat-input-wrapper">
                    <input type="text" id="chatInput" class="chat-input" placeholder="Type a message..." onkeypress="handleChatKeypress(event)">
                    <button class="chat-send-btn" onclick="sendChatMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Define global functions FIRST for onclick handlers
        console.log('[INIT] Script loading...');

        // These must be defined early for onclick handlers to work
        window.showTab = function(tabName) { console.log('showTab called but not initialized'); };
        window.showLoginModal = function() { console.log('showLoginModal called but not initialized'); };
        window.showRegisterModal = function() { console.log('showRegisterModal called but not initialized'); };
        window.logout = function() { console.log('logout called but not initialized'); };
        window.searchContent = function() { console.log('searchContent called but not initialized'); };
        window.showFriendsModal = function() { console.log('showFriendsModal called but not initialized'); };

        const API_BASE_URL = `${window.location.origin}/api`;
        let currentContentUrl = '';
        let currentContentType = 'movie';
        let currentContentId = null;
        let currentContentData = null;
        let episodeCache = {}; // Cache for episode data: { tvId: { seasonNumber: seasonData } }
        let searchResults = [];
        let movieGenresList = [];
        let tvGenresList = [];
        let currentTab = null; // No tab active by default
        let currentGenreId = null;
        let currentPage = 1;
        let currentMediaType = 'movie'; // 'movie' or 'tv'
        let currentContentFilter = 'popular'; // 'popular', 'trending', 'now-playing', 'upcoming'
        let currentLanguage = null; // null = all languages, 'en', 'ar', 'ko', 'ja', 'zh'

        // Video source preference: 'vidsrc', 'vidking', or 'superembed'
        let videoSource = localStorage.getItem('videoSource') || 'vidsrc';

        // ============= WATCHPARTY VARIABLES =============
        let socket = null;
        let watchpartyActive = false;
        let watchpartyRoomCode = null;
        let isHost = false;
        let username = null;
        let watchpartyUsers = [];

        // User color system for chat - vibrant colors matching app design
        const userColors = [
            '#FF6B6B', // Coral Red
            '#4ECDC4', // Turquoise
            '#45B7D1', // Sky Blue
            '#FFA07A', // Light Salmon
            '#98D8C8', // Mint
            '#F7DC6F', // Sunny Yellow
            '#BB8FCE', // Lavender
            '#85C1E2', // Powder Blue
            '#F8B739', // Golden
            '#5DADE2', // Bright Blue
            '#58D68D', // Emerald
            '#EC7063', // Pink Red
            '#AF7AC5', // Purple
            '#52BE80', // Green
            '#EB984E', // Orange
        ];
        let userColorMap = {}; // Maps username to color

        // ============= END WATCHPARTY VARIABLES =============

        // Multiple watchlists support
        // Initialize from localStorage only as fallback for non-authenticated users
        let watchlists = { 'My Watchlist': [] }; // No localStorage - loaded from DB when authenticated
        let currentWatchlistName = localStorage.getItem('streamingSite_currentWatchlist') || 'My Watchlist';

        // Legacy support - migrate old single watchlist to new format
        const oldWatchlist = JSON.parse(localStorage.getItem('streamingSite_watchlist') || '[]');
        if (oldWatchlist.length > 0 && !watchlists['My Watchlist']) {
            watchlists['My Watchlist'] = oldWatchlist;
            localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
            localStorage.removeItem('streamingSite_watchlist');
        }

        // Initialize from localStorage only as fallback for non-authenticated users
        let watchHistory = []; // No localStorage - loaded from DB when authenticated
        let channelFavourites = []; // No localStorage - loaded from DB when authenticated

        // Flag to track if data is loaded from database
        let isDataLoadedFromDB = false;

        // TMDB Genre mappings
        const movieGenres = {
            28: "Action", 12: "Adventure", 16: "Animation", 35: "Comedy", 80: "Crime",
            99: "Documentary", 18: "Drama", 10751: "Family", 14: "Fantasy", 36: "History",
            27: "Horror", 10402: "Music", 9648: "Mystery", 10749: "Romance", 878: "Sci-Fi",
            10770: "TV Movie", 53: "Thriller", 10752: "War", 37: "Western"
        };

        const tvGenres = {
            10759: "Action & Adventure", 16: "Animation", 35: "Comedy", 80: "Crime",
            99: "Documentary", 18: "Drama", 10751: "Family", 10762: "Kids", 9648: "Mystery",
            10763: "News", 10764: "Reality", 10765: "Sci-Fi & Fantasy", 10766: "Soap",
            10767: "Talk", 10768: "War & Politics", 37: "Western"
        };

        function getGenreNames(genreIds, isTV) {
            const genreMap = isTV ? tvGenres : movieGenres;
            return genreIds.map(id => genreMap[id]).filter(Boolean).slice(0, 3);
        }

        let autocompleteTimeout;

        /* ---------- Ratings (You + Friends) helpers ---------- */

        function ensureOmdbDom(){
          // Return the existing ratings grid used by IMDb/RT/Metacritic (do not create new wrappers here)
          return document.querySelector('#omdbRatings .ratings-container')
              || document.querySelector('.omdb-ratings .ratings-container')
              || document.querySelector('.ratings-container')
              || null;
        }

        function hostRatingsBox(){
          return ensureOmdbDom();
        }

        function getAuthToken(){
          return (window.authToken)
              || localStorage.getItem('jwt')
              || localStorage.getItem('token')
              || localStorage.getItem('access_token');
        }

        async function baseRequest(path, opt = {}){
          const headers = Object.assign({'Content-Type':'application/json'}, opt.headers || {});
          const token = getAuthToken();
          if (token) headers['Authorization'] = 'Bearer ' + token;
          const url = path.startsWith('/api') ? path : `${API_BASE_URL}${path.startsWith('/') ? '' : '/'}${path}`;
          const res = await fetch(url, Object.assign({ headers, credentials: 'include' }, opt));
          if (!res.ok) {
            const text = await res.text().catch(()=> '');
            const err = new Error(text || ('HTTP ' + res.status));
            err.status = res.status;
            throw err;
          }
          return res.status === 204 ? null : res.json();
        }

        function ensurePill(container){
          if (!container) return null;
          let pill = document.getElementById('userRatingPill');
          if (pill && pill.parentElement !== container) {
            pill.remove();
            pill = null;
          }
          if (pill) return pill;

          pill = document.createElement('div');
          pill.className = 'rating-item user-pill';
          pill.id = 'userRatingPill';
          pill.innerHTML = `
            <div class="rating-source">You</div>
            <div class="rating-value" id="userRatingValue"></div>
            <div style="display:flex; align-items:center; gap:8px; margin-top:4px;">
              <input id="userRatingInput" type="number" min="1" max="10" step="0.1" placeholder="110" />
              <button class="post-btn" id="postUserRatingBtn">Post</button>
            </div>
          `;
          container.appendChild(pill);
          const btn = pill.querySelector('#postUserRatingBtn');
          btn.addEventListener('click', postUserRating);
          return pill;
        }

        async function getFriendUsernames(){
          try {
            const r = await baseRequest('/friends', { method: 'GET' });
            // Handle both array and object formats
            let friendsList = [];
            if (Array.isArray(r)) {
              friendsList = r;
            } else if (r && Array.isArray(r.friends)) {
              friendsList = r.friends;
            }
            return friendsList.map(f => f.username || f);
          } catch(_) {
            return [];
          }
        }

        async function postUserRating(){
          if (!currentContentId || !currentContentType) { showError('Select a title first'); return; }

          const input = document.getElementById('userRatingInput');
          const val = parseFloat(input && input.value);
          if (isNaN(val) || val < 1 || val > 10) { showError('Please enter a value from 1 to 10'); return; }

          try {
            await baseRequest(`/ratings/${currentContentType}/${currentContentId}`, {
              method: 'POST',
              body: JSON.stringify({ rating: val })
            });
            await refreshRatingsUI();
          } catch(e) {
            if (e && (e.status === 401 || /401/.test(String(e.message||'')))) {
              if (window.showLoginModal) showLoginModal(); else alert('Please log in');
            } else {
              console.error(e); showError('Failed to save rating');
            }
          }
        }

        async function refreshRatingsUI(){
          const container = hostRatingsBox();
          if (!container || !currentContentId || !currentContentType) return;

          // Ensure "You" tile exists
          ensurePill(container);

          let data = { ratings_by_user: {} };
          try {
            data = await baseRequest(`/ratings/${currentContentType}/${currentContentId}`, { method: 'GET' });
          } catch(e) {
            console.warn('ratings fetch failed', e);
          }

          const cu = (window.currentUser) || ( () => { try { return JSON.parse(localStorage.getItem('currentUser')||'null'); } catch(_) { return null; } })();
          const me = (cu && (cu.username || cu.name)) || null;

          // Update "You" tile UI
          const input = document.getElementById('userRatingInput');
          const btn = document.getElementById('postUserRatingBtn');
          const youValEl = document.getElementById('userRatingValue');
          const yourVal = me ? data.ratings_by_user?.[me] : null;

          if (input) input.value = (yourVal || '');
          if (btn) btn.textContent = yourVal ? 'Update' : 'Post';
          if (youValEl) youValEl.textContent = (yourVal ? `${yourVal}/10` : '');

          // Remove any previously rendered friend tiles to avoid duplication
          container.querySelectorAll('.friend-rating-item').forEach(n => n.remove());

          // Render friend ratings as tiles
          try {
            const friends = await getFriendUsernames();
            const friendEntries = Object.entries(data.ratings_by_user || {})
              .filter(([u,_]) => (!me || u !== me) && friends.includes(u));

            if (friendEntries.length) {
              for (const [u, v] of friendEntries) {
                const tile = document.createElement('div');
                tile.className = 'rating-item friend-rating-item';
                tile.innerHTML = `
                  <div class="rating-source">@${u}</div>
                  <div class="rating-value">${v}/10</div>
                `;
                container.appendChild(tile);
              }
            } else {
              // Optional placeholder to indicate friend area
              const placeholder = document.createElement('div');
              placeholder.className = 'rating-item friend-rating-item';
              placeholder.style.opacity = '0.7';
              placeholder.innerHTML = `
                <div class="rating-source">Friends</div>
                <div class="rating-value"></div>
              `;
              container.appendChild(placeholder);
            }
          } catch(e) {
            console.warn('friends fetch failed', e);
          }
        }

        function clearRatingsUI() {
          const container = hostRatingsBox();
          if (!container) return;

          // Clear friend rating tiles
          container.querySelectorAll('.friend-rating-item').forEach(n => n.remove());

          // Reset "You" tile to default state
          const input = document.getElementById('userRatingInput');
          const btn = document.getElementById('postUserRatingBtn');
          const youValEl = document.getElementById('userRatingValue');

          if (input) input.value = '';
          if (btn) btn.textContent = 'Post';
          if (youValEl) youValEl.textContent = '';
        }

        /* ---------- end Ratings (You + Friends) helpers ---------- */

        // Track which content has been refreshed (shared with later definition)
        let __earlyLastRefreshedContentId = null;

        function setupUserRatingsPill(){
            const box = ensureOmdbDom() || hostRatingsBox();
            console.debug('[ratings] setupUserRatingsPill: container?', !!box, { currentContentType, currentContentId });
            if (!box) return;
            ensurePill(box);

            // Only refresh if we have valid content info and haven't already refreshed for this content
            if (currentContentType && currentContentId) {
                const contentKey = `${currentContentType}_${currentContentId}`;
                if (__earlyLastRefreshedContentId !== contentKey) {
                    __earlyLastRefreshedContentId = contentKey;
                    console.debug('[ratings] Refreshing for:', contentKey);
                    try { refreshRatingsUI(); } catch(e){ console.error(e); }
                } else {
                    console.debug('[ratings] Already refreshed for:', contentKey);
                }
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            // Don't load any content by default - wait for user to click a tab
            // Hide all content sections initially
            document.getElementById('contentResults').style.display = 'none';
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            const sportsDisplay = document.getElementById('sportsDisplay');
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            const channelsDisplay = document.getElementById('channelsDisplay');
            if (channelsDisplay) channelsDisplay.style.display = 'none';

            // Remove any active tab styling
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Hide genre filter and content type filters initially
            const genreContainer = document.getElementById('genreFilterContainer');
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (genreContainer) genreContainer.style.display = 'none';
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            const searchInput = document.getElementById('searchInput');

            // Add autocomplete on typing
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();

                clearTimeout(autocompleteTimeout);

                if (query.length < 2) {
                    hideAutocomplete();
                    return;
                }

                autocompleteTimeout = setTimeout(() => {
                    fetchAutocomplete(query);
                }, 300);
            });

            // Hide autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-container')) {
                    hideAutocomplete();
                }
            });

            // Add enter key support for search
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    hideAutocomplete();
                    searchContent();
                }
            });

            // Add hover listener for OMDB ratings tooltips
            document.addEventListener('mouseover', function(e) {
                const card = e.target.closest('.content-card, .continue-item');
                if (card && card.dataset.id) {
                    const tooltip = card.querySelector('.omdb-ratings-tooltip');
                    if (tooltip && !tooltip.dataset.loaded) {
                        loadOMDBRatings(card.dataset.id, card.dataset.type, tooltip);
                    }
                }
            });

            // Setup mobile keyboard handlers for chat
            setupMobileChatHandlers();

            // Setup infinite scroll for popular/trending sections
            setupInfiniteScroll();

        });

        async function fetchAutocomplete(query) {
            try {
                const endpoint = `${API_BASE_URL}/search/multi`;
                const params = new URLSearchParams({ query });

                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    showAutocomplete(data.results.slice(0, 5));
                } else {
                    hideAutocomplete();
                }
            } catch (error) {
                console.error('Autocomplete error:', error);
                hideAutocomplete();
            }
        }

        function showAutocomplete(results) {
            const autocompleteDiv = document.getElementById('searchAutocomplete');

            autocompleteDiv.innerHTML = results.map(item => {
                const isTV = item.content_type === 'tv' || item.media_type === 'tv' || item.name;
                const itemTitle = isTV ? (item.name || item.title) : (item.title || item.name);
                const year = isTV ?
                    (item.first_air_date ? item.first_air_date.substring(0, 4) : 'Unknown') :
                    (item.release_date ? item.release_date.substring(0, 4) : 'Unknown');
                const posterUrl = item.poster_url || 'https://via.placeholder.com/40x60/333/fff?text=No';
                const type = isTV ? 'tv' : 'movie';

                return `
                    <div class="autocomplete-item" onclick="selectAutocompleteItem(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${type}')">
                        <img src="${posterUrl}" alt="${itemTitle}" class="autocomplete-poster"
                             onerror="this.src='https://via.placeholder.com/40x60/333/fff?text=No'">
                        <div class="autocomplete-info">
                            <div class="autocomplete-title">${itemTitle}</div>
                            <div class="autocomplete-meta">${type.toUpperCase()}  ${year}</div>
                        </div>
                    </div>
                `;
            }).join('');

            autocompleteDiv.style.display = 'block';
        }

        function hideAutocomplete() {
            document.getElementById('searchAutocomplete').style.display = 'none';
        }

        function selectAutocompleteItem(id, title, type) {
            document.getElementById('searchInput').value = title;
            hideAutocomplete();

            // Directly play the selected content
            playContent(id, title, type);
        }

        async function loadOMDBRatings(id, type, tooltip) {
            try {
                tooltip.dataset.loaded = 'loading';

                const endpoint = type === 'tv' ? `${API_BASE_URL}/tv/${id}` : `${API_BASE_URL}/movie/${id}`;
                const response = await fetch(endpoint);
                const data = await response.json();

                if (data.error || !data.omdb_ratings || data.omdb_ratings.length === 0) {
                    tooltip.innerHTML = '<div class="tooltip-loading">No ratings available</div>';
                    tooltip.dataset.loaded = 'true';
                    return;
                }

                // Extract IMDb and Rotten Tomatoes ratings
                const imdbRating = data.omdb_imdb_rating || 'N/A';
                const imdbVotes = data.omdb_imdb_votes || '';
                let rtRating = 'N/A';

                data.omdb_ratings.forEach(rating => {
                    if (rating.Source === 'Rotten Tomatoes') {
                        rtRating = rating.Value;
                    }
                });

                // Get runtime and content rating
                const runtime = data.omdb_runtime || data.runtime || '';
                const contentRating = data.omdb_rated || data.content_rating || data.certification || '';

                // Format vote count if available
                const voteCountText = imdbVotes ? `<div style="font-family: 'VT323', monospace; font-size: 15px; color: #888; margin-top: 2px;">Rated by ${imdbVotes} users</div>` : '';

                // Build runtime row if available
                const runtimeRow = runtime ? `
                    <div class="tooltip-rating-row" style="margin-top: 4px;">
                        <span class="tooltip-rating-source">Runtime</span>
                        <span class="tooltip-rating-value">${runtime}</span>
                    </div>
                ` : '';

                // Build content rating row if available
                const contentRatingRow = contentRating ? `
                    <div class="tooltip-rating-row" style="margin-top: 4px;">
                        <span class="tooltip-rating-source">Rating</span>
                        <span class="tooltip-rating-value">${contentRating}</span>
                    </div>
                ` : '';

                tooltip.innerHTML = `
                    <div class="tooltip-rating-row">
                        <span class="tooltip-rating-source">IMDb</span>
                        <span class="tooltip-rating-value">${imdbRating}</span>
                    </div>
                    ${voteCountText}
                    <div class="tooltip-rating-row" style="margin-top: ${voteCountText ? '4px' : '0'};">
                        <span class="tooltip-rating-source">Rotten Tomatoes</span>
                        <span class="tooltip-rating-value">${rtRating}</span>
                    </div>
                    ${runtimeRow}
                    ${contentRatingRow}
                `;
                tooltip.dataset.loaded = 'true';
            } catch (error) {
                console.error('Error loading OMDB ratings:', error);
                tooltip.innerHTML = '<div class="tooltip-loading">Failed to load</div>';
                tooltip.dataset.loaded = 'true';
            }
        }

        async function openImdb(id, title, type) {
            // Open window immediately to avoid popup blocker
            const imdbWindow = window.open('about:blank', '_blank');

            try {
                showStatus('Fetching IMDb link...');

                // Fetch full details from TMDB which includes external IDs
                const endpoint = type === 'tv' ? `${API_BASE_URL}/tv/${id}` : `${API_BASE_URL}/movie/${id}`;
                const response = await fetch(endpoint);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                // Try to get IMDb ID from external_ids or direct imdb_id field
                let imdbId = data.imdb_id || (data.external_ids && data.external_ids.imdb_id);

                if (imdbId) {
                    // Direct link to IMDb title page
                    imdbWindow.location.href = `https://www.imdb.com/title/${imdbId}/`;
                    showStatus('Opened IMDb page');
                } else {
                    // Fallback to search if IMDb ID not available
                    imdbWindow.location.href = `https://www.imdb.com/find/?q=${encodeURIComponent(title)}&s=tt`;
                    showStatus('Opened IMDb search');
                }

                setTimeout(() => hideStatus(), 2000);
            } catch (error) {
                console.error('IMDb link error:', error);
                // Fallback to search on error
                imdbWindow.location.href = `https://www.imdb.com/find/?q=${encodeURIComponent(title)}&s=tt`;
                showError('Could not fetch IMDb ID, opened search instead');
                setTimeout(() => hideError(), 3000);
            }
        }

        function showStatus(message, type = 'info') {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = message;
            statusBar.style.display = 'block';

            // Handle different types
            if (type === 'warning') {
                statusBar.style.background = 'rgba(255, 149, 0, 0.2)';
                statusBar.style.borderColor = 'rgba(255, 149, 0, 0.6)';
                statusBar.style.color = '#fff';
            } else {
                statusBar.style.background = 'rgba(0, 122, 255, 0.2)';
                statusBar.style.borderColor = 'rgba(0, 122, 255, 0.6)';
                statusBar.style.color = '#fff';
            }
        }

        function hideStatus() {
            document.getElementById('statusBar').style.display = 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        window.searchContent = async function() {
            const query = document.getElementById('searchInput').value.trim();

            if (!query) {
                showError('Please enter a title');
                return;
            }

            hideError();
            showLoading();
            showStatus(`Searching for "${query}"...`);

            try {
                const params = new URLSearchParams({ query });
                const endpoint = `${API_BASE_URL}/search/multi`;

                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.error || !data.results || data.results.length === 0) {
                    throw new Error(data.error || 'No results found');
                }

                searchResults = data.results;
                displayContent(searchResults, 'Search Results');
                showTab('search-results');

            } catch (error) {
                console.error('Search error:', error);
                showError(`Search failed: ${error.message}`);
                displayContent([], 'No Results');
            } finally {
                hideLoading();
            }
        }

        // Infinite scroll state
        let isLoadingMore = false;
        let currentCategory = null;
        let hasMorePages = true;

        async function loadPopularMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'popular-movies';
           

            try {
                let url = `${API_BASE_URL}/popular?page=${page}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Popular Movies');
                }

            } catch (error) {
                console.error('Popular movies error:', error);
                showError(`Failed to load popular movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Popular Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadPopularTVShows(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'popular-tv';

            try {
                let url = `${API_BASE_URL}/tv/popular?page=${page}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Popular TV Shows');
                }

            } catch (error) {
                console.error('Popular TV shows error:', error);
                showError(`Failed to load popular TV shows: ${error.message}`);
                if (!append) {
                    displayContent([], 'Popular TV Shows');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadTrendingMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'trending-movies';
           
    
    

            try {
                let url = `${API_BASE_URL}/trending?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Trending Movies');
                }

            } catch (error) {
                console.error('Trending movies error:', error);
                showError(`Failed to load trending movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Trending Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadTrendingTVShows(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'trending-tv';
           

            try {
                let url = `${API_BASE_URL}/tv/trending?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Trending TV Shows');
                }

            } catch (error) {
                console.error('Trending TV shows error:', error);
                showError(`Failed to load trending TV shows: ${error.message}`);
                if (!append) {
                    displayContent([], 'Trending TV Shows');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadNowPlayingMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'now-playing-movies';
      

            try {
                let url = `${API_BASE_URL}/movies/now-playing?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Now Playing Movies');
                }

            } catch (error) {
                console.error('Now playing movies error:', error);
                showError(`Failed to load now playing movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Now Playing Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadNowPlayingTVShows(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'now-playing-tv';
           

            try {
                let url = `${API_BASE_URL}/tv/now-playing?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Now Playing TV Shows');
                }

            } catch (error) {
                console.error('Now playing TV shows error:', error);
                showError(`Failed to load now playing TV shows: ${error.message}`);
                if (!append) {
                    displayContent([], 'Now Playing TV Shows');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadUpcomingMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'upcoming-movies';
        

            try {
                let url = `${API_BASE_URL}/movies/upcoming?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Upcoming Movies');
                }

            } catch (error) {
                console.error('Upcoming movies error:', error);
                showError(`Failed to load upcoming movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Upcoming Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        function displayContent(items, title) {
            const resultsDiv = document.getElementById('contentResults');

            if (!items || items.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px;">
                        <h3>No content found</h3>
                        <p>Try different search terms or browse popular content</p>
                    </div>
                `;
                return;
            }

            resultsDiv.innerHTML = items.map(item => {
                const posterUrl = item.poster_url || 'https://via.placeholder.com/200x300/333/fff?text=No+Poster';
                const isTV = item.content_type === 'tv' || item.media_type === 'tv' || item.name;
                const itemTitle = isTV ? (item.name || item.title) : (item.title || item.name);
                const year = isTV ?
                    (item.first_air_date ? item.first_air_date.substring(0, 4) : 'Unknown') :
                    (item.release_date ? item.release_date.substring(0, 4) : 'Unknown');
                const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';

                const isInWatchlist = isItemInWatchlist(item.id, isTV ? 'tv' : 'movie');

                // Get genre names from genre_ids
                const genreNames = getGenreNames(item.genre_ids || [], isTV);
                const genreDisplay = genreNames.length > 0 ? genreNames.join('  ') : 'Genre not available';

                // Get watch progress for this item
                const watchProgress = getWatchProgress(item.id, isTV ? 'tv' : 'movie');
                const progressBarHtml = watchProgress > 0 ? `
                    <div class="card-progress-bar">
                        <div class="card-progress-fill" style="width: ${watchProgress}%"></div>
                    </div>
                ` : '';

                // Get rating and runtime if available
                // Debug: log to see what fields are available
                if (!window._itemFieldsLogged) {
                    console.log('Item fields:', Object.keys(item));
                    console.log('Sample item:', item);
                    window._itemFieldsLogged = true;
                }

                return `
                    <div class="content-card" data-id="${item.id}" data-type="${isTV ? 'tv' : 'movie'}"
                         onclick="playContent(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')">
                        <button type="button" class="watchlist-btn ${isInWatchlist ? 'added' : ''}"
                                onclick="event.stopPropagation(); event.preventDefault(); toggleWatchlist(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}', '${posterUrl}', '${year}', ${item.vote_average || 0}, event); return false;"
                                title="${isInWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
                            ${isInWatchlist ? '' : ''}
                        </button>
                        <div class="content-type-badge ${isTV ? 'tv-badge' : 'movie-badge'}">
                            ${isTV ? 'TV' : 'Movie'}
                        </div>
                        <button class="imdb-btn" onclick="event.stopPropagation(); openImdb(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')" title="View on IMDb">
                            IMDb
                        </button>
                        ${progressBarHtml}
                        <img src="${posterUrl}" alt="${itemTitle}" class="content-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="content-info">
                            <div class="content-title">${itemTitle}</div>
                            <div class="content-year">${year}</div>
                            <div class="content-genres">${genreDisplay}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function appendContent(items) {
            const resultsDiv = document.getElementById('contentResults');

            if (!items || items.length === 0) {
                hasMorePages = false;
                return;
            }

            const newItems = items.map(item => {
                const posterUrl = item.poster_url || 'https://via.placeholder.com/200x300/333/fff?text=No+Poster';
                const isTV = item.content_type === 'tv' || item.media_type === 'tv' || item.name;
                const itemTitle = isTV ? (item.name || item.title) : (item.title || item.name);
                const year = isTV ?
                    (item.first_air_date ? item.first_air_date.substring(0, 4) : 'Unknown') :
                    (item.release_date ? item.release_date.substring(0, 4) : 'Unknown');
                const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';

                const isInWatchlist = isItemInWatchlist(item.id, isTV ? 'tv' : 'movie');

                // Get genre names from genre_ids
                const genreNames = getGenreNames(item.genre_ids || [], isTV);
                const genreDisplay = genreNames.length > 0 ? genreNames.join('  ') : 'Genre not available';

                // Get watch progress for this item
                const watchProgress = getWatchProgress(item.id, isTV ? 'tv' : 'movie');
                const progressBarHtml = watchProgress > 0 ? `
                    <div class="card-progress-bar">
                        <div class="card-progress-fill" style="width: ${watchProgress}%"></div>
                    </div>
                ` : '';

                // Get rating and runtime if available
                // Debug: log to see what fields are available
                if (!window._itemFieldsLogged) {
                    console.log('Item fields:', Object.keys(item));
                    console.log('Sample item:', item);
                    window._itemFieldsLogged = true;
                }

                return `
                    <div class="content-card" data-id="${item.id}" data-type="${isTV ? 'tv' : 'movie'}"
                         onclick="playContent(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')">
                        <button type="button" class="watchlist-btn ${isInWatchlist ? 'added' : ''}"
                                onclick="event.stopPropagation(); event.preventDefault(); toggleWatchlist(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}', '${posterUrl}', '${year}', ${item.vote_average || 0}, event); return false;"
                                title="${isInWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
                            ${isInWatchlist ? '' : ''}
                        </button>
                        <div class="content-type-badge ${isTV ? 'tv-badge' : 'movie-badge'}">
                            ${isTV ? 'TV' : 'Movie'}
                        </div>
                        <button class="imdb-btn" onclick="event.stopPropagation(); openImdb(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')" title="View on IMDb">
                            IMDb
                        </button>
                        ${progressBarHtml}
                        <img src="${posterUrl}" alt="${itemTitle}" class="content-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="content-info">
                            <div class="content-title">${itemTitle}</div>
                            <div class="content-year">${year}</div>
                            <div class="content-genres">${genreDisplay}</div>
                        </div>
                    </div>
                `;
            }).join('');

            resultsDiv.insertAdjacentHTML('beforeend', newItems);
        }

        // Infinite scroll detection
        function setupInfiniteScroll() {
            let scrollTimeout;

            const scrollHandler = () => {
                // Clear any pending scroll checks
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }

                // Debounce scroll events
                scrollTimeout = setTimeout(() => {
                    // Only load more if we're in a popular/trending category
                    const validCategories = ['popular-movies', 'popular-tv', 'trending-movies', 'trending-tv'];
                    if (!validCategories.includes(currentCategory)) {
                        return;
                    }

                    // Check if we're near the bottom of the page
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const scrollHeight = document.documentElement.scrollHeight;
                    const clientHeight = window.innerHeight;

                    // Only trigger if scrolled near bottom (300px threshold) and not already loading
                    if (scrollHeight - scrollTop - clientHeight < 300 && !isLoadingMore && hasMorePages) {
                        isLoadingMore = true;
                        currentPage++;

                        // Load more based on current category
                        if (currentCategory === 'popular-movies') {
                            loadPopularMovies(currentPage, true);
                        } else if (currentCategory === 'popular-tv') {
                            loadPopularTVShows(currentPage, true);
                        } else if (currentCategory === 'trending-movies') {
                            loadTrendingMovies(currentPage, true);
                        } else if (currentCategory === 'trending-tv') {
                            loadTrendingTVShows(currentPage, true);
                        }
                    }
                }, 100); // 100ms debounce
            };

            window.addEventListener('scroll', scrollHandler);
        }

        async function playContent(contentId, contentTitle, contentType) {

            hideError();

            // Clear old ratings immediately to prevent showing wrong data
            clearRatingsUI();
            __earlyLastRefreshedContentId = null;

            // Scroll to player section immediately
            const playerSection = document.querySelector('.player-section');
            if (playerSection) {
                playerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            try {
                // If comments section is open and we're switching content, restart polling
                const commentsSection = document.getElementById('commentsSection');
                const commentsWereVisible = commentsSection && commentsSection.style.display === 'block';

                currentContentId = contentId;
                currentContentType = contentType;

                // Restart comments polling if comments were visible
                if (commentsWereVisible && authToken) {
                    if (commentsPollingInterval) {
                        clearInterval(commentsPollingInterval);
                    }
                    commentsPollingInterval = setInterval(() => {
                        displayComments(contentId);
                    }, 3000);
                    // Refresh comments immediately for new content
                    displayComments(contentId);
                }

                let endpoint;
                if (contentType === 'tv') {
                    endpoint = `${API_BASE_URL}/tv/${contentId}`;
                } else {
                    endpoint = `${API_BASE_URL}/movie/${contentId}`;
                }

                const response = await fetch(endpoint);
                const data = await response.json();

                // If content not found, try the opposite type
                if (data.error && (data.error.includes('not found') || data.error.includes('404'))) {
                    console.log(`Content not found as ${contentType}, trying opposite type...`);
                    const oppositeType = contentType === 'tv' ? 'movie' : 'tv';
                    const oppositeEndpoint = oppositeType === 'tv' ? `${API_BASE_URL}/tv/${contentId}` : `${API_BASE_URL}/movie/${contentId}`;

                    const oppositeResponse = await fetch(oppositeEndpoint);
                    const oppositeData = await oppositeResponse.json();

                    if (oppositeData.error) {
                        throw new Error(`Content with ID ${contentId} not found as movie or TV show.`);
                    }

                    // Update content type to the correct one
                    currentContentType = oppositeType;
                    currentContentData = oppositeData;
                    console.log(`Found content as ${oppositeType} instead.`);
                } else if (data.error) {
                    throw new Error(data.error);
                } else {
                    currentContentData = data;
                }

                // Update current content display
                const currentContent = document.getElementById('currentContent');
                const tvControls = document.getElementById('tvControls');

                const titleEl = document.getElementById('currentTitle');
                const yearEl = document.getElementById('currentYear');
                const ratingEl = document.getElementById('currentRating');
                const overviewEl = document.getElementById('currentOverview');

                if (titleEl) titleEl.textContent = currentContentType === 'tv' ? currentContentData.name : currentContentData.title;
                if (yearEl) yearEl.textContent = currentContentType === 'tv' ?
                    (currentContentData.first_air_date ? currentContentData.first_air_date.substring(0, 4) : 'Unknown') :
                    (currentContentData.release_date ? currentContentData.release_date.substring(0, 4) : 'Unknown');
                if (ratingEl) ratingEl.textContent = ` ${currentContentData.vote_average ? currentContentData.vote_average.toFixed(1) : 'N/A'}/10`;
                if (overviewEl) overviewEl.textContent = currentContentData.overview || 'No description available';

                const posterEl = document.getElementById('currentPoster');
                if (posterEl) {
                    if (currentContentData.poster_url) {
                        posterEl.src = currentContentData.poster_url;
                        posterEl.style.display = 'block';
                    } else {
                        posterEl.style.display = 'none';
                    }
                }

                // Load backdrop image
                const backdropEl = document.getElementById('backdropImage');
                console.log('Backdrop element:', backdropEl);
                console.log('Backdrop URL:', currentContentData.backdrop_url);
                if (backdropEl && currentContentData.backdrop_url) {
                    backdropEl.style.backgroundImage = `url(${currentContentData.backdrop_url})`;
                    backdropEl.classList.add('loaded');
                    console.log('Backdrop loaded:', backdropEl.style.backgroundImage);
                } else if (backdropEl) {
                    backdropEl.style.backgroundImage = '';
                    backdropEl.classList.remove('loaded');
                    console.log('Backdrop cleared or not available');
                }

                // Populate OMDB data if available
                const omdbRatingsEl = document.getElementById('omdbRatings');
                const omdbDetailsEl = document.getElementById('omdbDetails');

                if (omdbRatingsEl && currentContentData.omdb_ratings && currentContentData.omdb_ratings.length > 0) {
                    // Parse ratings
                    const imdbRating = currentContentData.omdb_imdb_rating || 'N/A';
                    let rtRating = 'N/A';
                    let metacriticRating = 'N/A';

                    currentContentData.omdb_ratings.forEach(rating => {
                        if (rating.Source === 'Rotten Tomatoes') {
                            rtRating = rating.Value;
                        } else if (rating.Source === 'Metacritic') {
                            metacriticRating = rating.Value;
                        }
                    });

                    const imdbEl = document.getElementById('imdbRating');
                    const rtEl = document.getElementById('rtRating');
                    const metacriticEl = document.getElementById('metacriticRating');

                    if (imdbEl) imdbEl.textContent = imdbRating;
                    if (rtEl) rtEl.textContent = rtRating;
                    if (metacriticEl) metacriticEl.textContent = metacriticRating;
                    omdbRatingsEl.style.display = 'flex';
                } else if (omdbRatingsEl) {
                    omdbRatingsEl.style.display = 'none';
                }

                // Populate OMDB details if available
                if (omdbDetailsEl && (currentContentData.tmdb_cast || currentContentData.omdb_actors || currentContentData.omdb_director || currentContentData.omdb_genre || currentContentData.omdb_rated || currentContentData.omdb_runtime || currentContentData.omdb_awards)) {
                    const actorsEl = document.getElementById('omdbActors');
                    const castSection = document.getElementById('castSection');
                    const castGrid = document.getElementById('castGrid');
                    const directorEl = document.getElementById('omdbDirector');
                    const genreEl = document.getElementById('omdbGenre');
                    const ratedEl = document.getElementById('omdbRated');
                    const runtimeEl = document.getElementById('omdbRuntime');
                    const awardsEl = document.getElementById('omdbAwards');

                    // Display TMDB cast with images if available
                    if (castSection && castGrid && currentContentData.tmdb_cast && currentContentData.tmdb_cast.length > 0) {
                        castGrid.innerHTML = '';
                        currentContentData.tmdb_cast.forEach(actor => {
                            const castMember = document.createElement('div');
                            castMember.className = 'cast-member';

                            if (actor.profile_url) {
                                const img = document.createElement('img');
                                img.src = actor.profile_url;
                                img.alt = actor.name;
                                img.className = 'cast-member-image';
                                castMember.appendChild(img);
                            } else {
                                const placeholder = document.createElement('div');
                                placeholder.className = 'cast-member-image placeholder';
                                placeholder.textContent = actor.name.charAt(0);
                                castMember.appendChild(placeholder);
                            }

                            const nameDiv = document.createElement('div');
                            nameDiv.className = 'cast-member-name';
                            nameDiv.textContent = actor.name;
                            nameDiv.title = actor.name;
                            castMember.appendChild(nameDiv);

                            if (actor.character) {
                                const characterDiv = document.createElement('div');
                                characterDiv.className = 'cast-member-character';
                                characterDiv.textContent = actor.character;
                                characterDiv.title = actor.character;
                                castMember.appendChild(characterDiv);
                            }

                            castGrid.appendChild(castMember);
                        });
                        castSection.style.display = 'block';
                        actorsEl.style.display = 'none';
                    } else if (actorsEl && currentContentData.omdb_actors) {
                        // Fallback to OMDB text if no TMDB cast
                        const span = actorsEl.querySelector('span');
                        if (span) span.textContent = currentContentData.omdb_actors;
                        actorsEl.style.display = 'block';
                        if (castSection) castSection.style.display = 'none';
                    } else {
                        if (actorsEl) actorsEl.style.display = 'none';
                        if (castSection) castSection.style.display = 'none';
                    }

                    if (directorEl) {
                        if (currentContentData.omdb_director && currentContentData.omdb_director !== 'N/A') {
                            const span = directorEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_director;
                            directorEl.style.display = 'block';
                        } else {
                            directorEl.style.display = 'none';
                        }
                    }

                    if (genreEl) {
                        if (currentContentData.omdb_genre) {
                            const span = genreEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_genre;
                            genreEl.style.display = 'block';
                        } else {
                            genreEl.style.display = 'none';
                        }
                    }

                    if (ratedEl) {
                        if (currentContentData.omdb_rated && currentContentData.omdb_rated !== 'N/A') {
                            const span = ratedEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_rated;
                            ratedEl.style.display = 'block';
                        } else {
                            ratedEl.style.display = 'none';
                        }
                    }

                    if (runtimeEl) {
                        if (currentContentData.omdb_runtime) {
                            const span = runtimeEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_runtime;
                            runtimeEl.style.display = 'block';
                        } else {
                            runtimeEl.style.display = 'none';
                        }
                    }

                    if (awardsEl) {
                        if (currentContentData.omdb_awards && currentContentData.omdb_awards !== 'N/A') {
                            const span = awardsEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_awards;
                            awardsEl.style.display = 'block';
                        } else {
                            awardsEl.style.display = 'none';
                        }
                    }

                    omdbDetailsEl.style.display = 'block';
                } else if (omdbDetailsEl) {
                    omdbDetailsEl.style.display = 'none';
                }

                currentContent.style.display = 'flex';

                // Initialize player background effects
                // initPlayerBackgroundEffects();

                // Show the player section
                document.getElementById('playerSection').style.display = 'block';

                // Check if there's existing watch progress
                const existingProgress = watchHistory.find(
                    item => item.id === contentId && item.type === currentContentType
                );

                if (currentContentType === 'tv') {
                    // Setup TV show controls
                    tvControls.style.display = 'block';
                    await setupSeasonEpisodeSelectors(currentContentData);

                    // If there's progress and it's a TV show, resume from last episode
                    if (existingProgress && existingProgress.progress > 5 && existingProgress.progress < 95) {
                        const resumeSeason = existingProgress.season || 1;
                        const resumeEpisode = existingProgress.episode || 1;


                        // Set current season and episode to resume position
                        currentSelectedSeason = resumeSeason;
                        currentSelectedEpisode = resumeEpisode;
                        document.getElementById('seasonButtonText').textContent = `Season ${resumeSeason}`;
                        await updateEpisodeSelector(resumeSeason);
                        document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(resumeEpisode, resumeSeason);

                        playTVEpisode(contentId, resumeSeason, resumeEpisode);
                    } else {
                        playTVEpisode(contentId, 1, 1);
                    }
                } else {
                    // Play movie
                    tvControls.style.display = 'none';

                    if (existingProgress && existingProgress.progress > 5 && existingProgress.progress < 95) {
                    }

                    playMovie(contentId);
                }

                // Add to watch history
                addToWatchHistory(contentId, contentTitle, contentType, data);

                // Update player watchlist button
                updatePlayerWatchlistButton(contentId, currentContentType);

                // Update video source button
                updateVideoSourceButton();

                // Refresh user ratings UI to show friends' ratings
                setTimeout(() => {
                    setupUserRatingsPill();
                }, 500);

            } catch (error) {
                console.error('Play content error:', error);
                showError(`Failed to load content: ${error.message}`);
            }
        }

        function updatePlayerWatchlistButton(id, type) {
            const btn = document.getElementById('playerWatchlistBtn');
            const btnText = document.getElementById('playerWatchlistBtnText');

            if (!btn || !btnText) return;

            // Check if in any watchlist
            const inLists = Object.keys(watchlists).filter(listName =>
                watchlists[listName].some(item => item.id === id && item.type === type)
            );

            btn.style.display = 'inline-block';

            if (inLists.length > 0) {
                btnText.textContent = ` In Watchlist (${inLists.length})`;
            } else {
                btnText.textContent = ' Add to Watchlist';
            }
        }

        window.togglePlayerWatchlist = function() {
            if (!currentContentId || !currentContentType) return;

            const panel = document.getElementById('watchlistPanel');
            if (!panel) {
                console.error('Watchlist panel not found');
                return;
            }

            const isVisible = panel.style.display === 'flex';

            if (isVisible) {
                panel.style.display = 'none';
            } else {
                // Get poster URL and other data from currentContentData
                const posterUrl = currentContentData?.poster_url || '';
                const year = currentContentType === 'tv' ?
                    (currentContentData?.first_air_date ? currentContentData.first_air_date.substring(0, 4) : '') :
                    (currentContentData?.release_date ? currentContentData.release_date.substring(0, 4) : '');
                const rating = currentContentData?.vote_average || 0;
                const title = currentContentType === 'tv' ? currentContentData?.name : currentContentData?.title;

                // Store current item data
                window.pendingWatchlistPanelItem = {
                    id: currentContentId,
                    title: title,
                    type: currentContentType,
                    posterUrl: posterUrl,
                    year: year,
                    rating: rating,
                    addedAt: new Date().toISOString()
                };

                // Check if item is in any watchlist
                const inLists = Object.keys(watchlists).filter(listName =>
                    watchlists[listName].some(item => item.id === currentContentId && item.type === currentContentType)
                );

                // Update panel content
                updateWatchlistPanel(inLists);

                // Position panel below the watchlist button
                const watchlistButton = document.getElementById('playerWatchlistBtn');
                if (!watchlistButton) {
                    console.error('Watchlist button not found');
                    return;
                }

                const rect = watchlistButton.getBoundingClientRect();
                console.log('Button position:', rect);

                // Calculate position - ensure it's within viewport
                let top = rect.bottom + window.scrollY + 5;
                let left = rect.left + window.scrollX;

                // Adjust if too close to right edge
                const panelWidth = 300;
                if (left + panelWidth > window.innerWidth) {
                    left = rect.right + window.scrollX - panelWidth;
                }

                panel.style.top = `${top}px`;
                panel.style.left = `${left}px`;
                panel.style.display = 'flex';

                console.log('Panel displayed at:', panel.style.top, panel.style.left);
            }
        }

        function updateWatchlistPanel(inLists) {
            const panel = document.getElementById('watchlistPanel');
            const title = document.getElementById('watchlistPanelTitle');
            const list = document.getElementById('watchlistPanelList');
            const createSection = document.getElementById('watchlistPanelCreate');

            if (inLists.length > 0) {
                // Item is in watchlists - show removal options
                title.textContent = 'REMOVE FROM WATCHLIST';
                createSection.style.display = 'none';

                list.innerHTML = inLists.map(listName => `
                    <button onclick="removeFromWatchlistPanel('${listName.replace(/'/g, "\\'")}'); event.stopPropagation();"
                            class="effects-btn"
                            style="width: 100%; padding: 12px; background: rgba(255, 59, 48, 0.15); border-color: rgba(255, 59, 48, 0.5);">
                        Remove from ${listName}
                    </button>
                `).join('');
            } else {
                // Item not in any watchlist - show add options
                title.textContent = 'ADD TO WATCHLIST';
                createSection.style.display = 'block';

                const listNames = Object.keys(watchlists);
                if (listNames.length === 0) {
                    watchlists['My Watchlist'] = [];
                    localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
                }

                list.innerHTML = Object.keys(watchlists).map(listName => `
                    <button onclick="addToWatchlistPanel('${listName.replace(/'/g, "\\'")}'); event.stopPropagation();"
                            class="effects-btn"
                            style="width: 100%; padding: 12px;">
                        ${listName}
                    </button>
                `).join('');
            }
        }

        async function addToWatchlistPanel(listName) {
            console.log('[addToWatchlistPanel] Called with listName:', listName);
            const item = window.pendingWatchlistPanelItem;
            console.log('[addToWatchlistPanel] Item:', item);
            console.log('[addToWatchlistPanel] authToken:', authToken ? 'exists' : 'null');

            if (!item) {
                console.log('[addToWatchlistPanel] No item, returning');
                return;
            }

            // Require authentication - no localStorage fallback
            if (!authToken) {
                showError('Please login to use watchlist');
                showLoginModal();
                const panel = document.getElementById('watchlistPanel');
                if (panel) panel.style.display = 'none';
                window.pendingWatchlistPanelItem = null;
                return;
            }

            // Save to database only
            console.log('[addToWatchlistPanel] User authenticated, calling API with list:', listName);
            try {
                await addToWatchlistAPI(item.id, item.type, item.title, item.posterUrl, listName);
                console.log('[addToWatchlistPanel] API call successful');
            } catch (error) {
                console.error('[addToWatchlistPanel] API call failed:', error);
                showError('Failed to add to watchlist');
            }

            // Close panel
            const panel = document.getElementById('watchlistPanel');
            if (panel) panel.style.display = 'none';
            window.pendingWatchlistPanelItem = null;
        }

        async function removeFromWatchlistPanel(listName) {
            const item = window.pendingWatchlistPanelItem;
            if (!item) return;

            // Require authentication - no localStorage fallback
            if (!authToken) {
                showError('Please login to use watchlist');
                showLoginModal();
                const panel = document.getElementById('watchlistPanel');
                if (panel) panel.style.display = 'none';
                window.pendingWatchlistPanelItem = null;
                return;
            }

            // Remove from database only
            try {
                await removeFromWatchlistAPI(item.id);
            } catch (error) {
                showError('Failed to remove from watchlist');
            }

            // Close panel
            const panel = document.getElementById('watchlistPanel');
            if (panel) panel.style.display = 'none';
            window.pendingWatchlistPanelItem = null;
        }

        function createWatchlistFromPanel() {
            const input = document.getElementById('newWatchlistNamePanel');
            const listName = input.value.trim();

            if (!listName) {
                showError('Please enter a watchlist name');
                return;
            }

            // Require authentication
            if (!authToken) {
                showError('Please login to create watchlists');
                showLoginModal();
                return;
            }

            if (watchlists[listName]) {
                showError('Watchlist already exists');
                return;
            }

            // Create list in memory (will be saved to DB when first item is added)
            watchlists[listName] = [];
            input.value = '';


            // Add current item to the new list
            if (window.pendingWatchlistPanelItem) {
                addToWatchlistPanel(listName);
            } else {
                // Just refresh the panel
                updateWatchlistPanel([]);
            }
        }

        let currentSeasons = [];
        let currentSelectedSeason = 1;
        let currentSelectedEpisode = 1;

        async function setupSeasonEpisodeSelectors(tvData) {
            // Store seasons data
            currentSeasons = tvData.seasons ? tvData.seasons.filter(s => s.season_number > 0) : [];

            // Set first season as default
            if (currentSeasons.length > 0) {
                currentSelectedSeason = currentSeasons[0].season_number;
                document.getElementById('seasonButtonText').textContent = `Season ${currentSelectedSeason}`;
                await updateEpisodeSelector(currentSelectedSeason);
            }
        }

        window.toggleSeasonPanel = function() {
            const panel = document.getElementById('seasonPanel');
            const episodePanel = document.getElementById('episodePanel');

            if (panel) {
                const isVisible = panel.style.display === 'flex';

                if (isVisible) {
                    panel.style.display = 'none';
                } else {
                    // Close episode panel if open
                    if (episodePanel) episodePanel.style.display = 'none';

                    // Position panel below the season button
                    const seasonButton = document.getElementById('seasonButton');
                    const rect = seasonButton.getBoundingClientRect();
                    panel.style.top = `${rect.bottom + window.scrollY + 5}px`;
                    panel.style.left = `${rect.left + window.scrollX}px`;
                    panel.style.display = 'flex';

                    // Populate seasons
                    const seasonList = document.getElementById('seasonList');
                    seasonList.innerHTML = '';

                    currentSeasons.forEach(season => {
                        const button = document.createElement('button');
                        button.className = 'effects-btn';
                        button.textContent = `Season ${season.season_number}`;
                        button.onclick = () => selectSeason(season.season_number);
                        seasonList.appendChild(button);
                    });
                }
            }
        }

        async function selectSeason(seasonNumber) {
            currentSelectedSeason = seasonNumber;
            document.getElementById('seasonButtonText').textContent = `Season ${seasonNumber}`;

            // Close panel
            const panel = document.getElementById('seasonPanel');
            if (panel) panel.style.display = 'none';

            await updateEpisodeSelector(seasonNumber);
        }

        window.toggleEpisodePanel = function() {
            const panel = document.getElementById('episodePanel');
            const seasonPanel = document.getElementById('seasonPanel');

            if (panel) {
                const isVisible = panel.style.display === 'flex';

                if (isVisible) {
                    panel.style.display = 'none';
                } else {
                    // Close season panel if open
                    if (seasonPanel) seasonPanel.style.display = 'none';

                    // Position panel below the episode button
                    const episodeButton = document.getElementById('episodeButton');
                    const rect = episodeButton.getBoundingClientRect();
                    panel.style.top = `${rect.bottom + window.scrollY + 5}px`;
                    panel.style.left = `${rect.left + window.scrollX}px`;
                    panel.style.display = 'flex';
                }
            }
        }

        // Helper function to format episode button text
        function getEpisodeButtonText(episodeNumber, seasonNumber = currentSelectedSeason) {
            const cacheKey = `${currentContentId}_${seasonNumber}`;
            const seasonData = episodeCache[cacheKey];

            if (seasonData && seasonData.episodes) {
                const episode = seasonData.episodes.find(ep => ep.episode_number === episodeNumber);
                if (episode) {
                    const episodeName = episode.name || 'Untitled';
                    let ratingParts = [];

                    if (episode.omdb_imdb_rating && episode.omdb_imdb_rating !== 'N/A') {
                        ratingParts.push(`IMDb ${episode.omdb_imdb_rating}`);
                    }
                    if (episode.omdb_ratings && Array.isArray(episode.omdb_ratings)) {
                        const rtRating = episode.omdb_ratings.find(r => r.Source === 'Rotten Tomatoes');
                        if (rtRating && rtRating.Value) {
                            ratingParts.push(`RT ${rtRating.Value}`);
                        }
                    }

                    let buttonText = `E${episodeNumber}: ${episodeName}`;
                    if (ratingParts.length > 0) {
                        buttonText += ` (${ratingParts.join(', ')})`;
                    }
                    return buttonText;
                }
            }

            // Fallback
            return `Episode ${episodeNumber}`;
        }

        function selectEpisode(episodeNumber, episodeTitle, episodeRating = null, episodeOverview = null) {
            currentSelectedEpisode = episodeNumber;

            // Build episode button text with title and rating
            let buttonText = `E${episodeNumber}: ${episodeTitle || `Episode ${episodeNumber}`}`;
            if (episodeRating) {
                buttonText += ` (${episodeRating})`;
            }

            document.getElementById('episodeButtonText').textContent = buttonText;

            // Update episode description
            const descriptionSection = document.getElementById('episodeDescription');
            const descriptionText = document.getElementById('episodeDescriptionText');

            if (episodeOverview && episodeOverview.trim() !== '') {
                descriptionText.textContent = episodeOverview;
                descriptionSection.style.display = 'block';
            } else {
                descriptionSection.style.display = 'none';
            }

            // Close panel
            const panel = document.getElementById('episodePanel');
            if (panel) panel.style.display = 'none';

            if (currentContentId) {
                playTVEpisode(currentContentId, currentSelectedSeason, episodeNumber);
            }
        }

        async function updateEpisodeSelector(seasonNumber) {
            const episodeList = document.getElementById('episodeList');
            episodeList.innerHTML = '<div style="text-align: center; color: var(--primary-color, #00ff9f); padding: 20px;">Loading episodes...</div>';

            try {
                // Check cache first
                const cacheKey = `${currentContentId}_${seasonNumber}`;
                let seasonData;

                if (episodeCache[cacheKey]) {
                    // Use cached data (already has ratings)
                    seasonData = episodeCache[cacheKey];
                } else {
                    // Fetch episode details from TMDB WITHOUT ratings for fast display
                    const response = await fetch(`${API_BASE_URL}/tv/${currentContentId}/season/${seasonNumber}?quick=true`);
                    seasonData = await response.json();

                    // Don't cache quick data - we'll cache the full data with ratings later
                }

                episodeList.innerHTML = '';

                if (seasonData.episodes && seasonData.episodes.length > 0) {
                    // Display all episodes immediately WITHOUT ratings
                    const episodeButtons = {};

                    seasonData.episodes.forEach(episode => {
                        const button = document.createElement('button');
                        button.className = 'effects-btn';

                        const episodeNum = `E${episode.episode_number}`;
                        const episodeName = episode.name || 'Untitled';

                        // Initially display without ratings
                        button.textContent = `${episodeNum}: ${episodeName}`;
                        button.style.textAlign = 'left';
                        button.setAttribute('data-episode-num', episode.episode_number);
                        button.onclick = () => selectEpisode(episode.episode_number, episodeName, null, episode.overview);

                        episodeList.appendChild(button);
                        episodeButtons[episode.episode_number] = button;
                    });

                    // Set first episode as default if not already set
                    if (currentSelectedEpisode === 1 || !currentSelectedEpisode) {
                        const firstEp = seasonData.episodes[0];
                        currentSelectedEpisode = firstEp.episode_number;

                        document.getElementById('episodeButtonText').textContent = `E${firstEp.episode_number}: ${firstEp.name || 'Untitled'}`;

                        // Update episode description for first episode
                        const descriptionSection = document.getElementById('episodeDescription');
                        const descriptionText = document.getElementById('episodeDescriptionText');

                        if (firstEp.overview && firstEp.overview.trim() !== '') {
                            descriptionText.textContent = firstEp.overview;
                            descriptionSection.style.display = 'block';
                        } else {
                            descriptionSection.style.display = 'none';
                        }
                    }

                    // Now lazy load ratings for each episode in the background
                    if (!episodeCache[cacheKey]) {
                        // Only fetch ratings if not already cached
                        loadEpisodeRatingsInBackground(seasonNumber, seasonData.episodes, episodeButtons);
                    }
                } else {
                    // Fallback to simple numbering if API fails
                    const selectedSeason = currentContentData?.seasons?.find(s => s.season_number == seasonNumber);
                    const episodeCount = selectedSeason?.episode_count || 10;

                    for (let i = 1; i <= episodeCount; i++) {
                        const button = document.createElement('button');
                        button.className = 'effects-btn';
                        button.textContent = `Episode ${i}`;
                        button.onclick = () => selectEpisode(i, `Episode ${i}`);
                        episodeList.appendChild(button);
                    }

                    if (currentSelectedEpisode === 1 || !currentSelectedEpisode) {
                        currentSelectedEpisode = 1;
                        document.getElementById('episodeButtonText').textContent = 'Episode 1';
                    }
                }
            } catch (error) {
                console.error('Error fetching episodes:', error);

                // Fallback to simple numbering
                const selectedSeason = currentContentData?.seasons?.find(s => s.season_number == seasonNumber);
                const episodeCount = selectedSeason?.episode_count || 10;

                episodeList.innerHTML = '';
                for (let i = 1; i <= episodeCount; i++) {
                    const button = document.createElement('button');
                    button.className = 'effects-btn';
                    button.textContent = `Episode ${i}`;
                    button.onclick = () => selectEpisode(i, `Episode ${i}`);
                    episodeList.appendChild(button);
                }

                if (currentSelectedEpisode === 1 || !currentSelectedEpisode) {
                    currentSelectedEpisode = 1;
                    document.getElementById('episodeButtonText').textContent = 'Episode 1';
                }
            }
        }

        async function loadEpisodeRatingsInBackground(seasonNumber, episodes, episodeButtons) {
            // Fetch ratings for each episode individually
            const ratingPromises = episodes.map(async (episode) => {
                try {
                    const response = await fetch(
                        `${API_BASE_URL}/tv/${currentContentId}/season/${seasonNumber}/episode/${episode.episode_number}/rating`
                    );
                    const ratingData = await response.json();

                    if (ratingData.imdb_rating && ratingData.imdb_rating !== 'N/A') {
                        // Update the episode button with rating
                        const button = episodeButtons[episode.episode_number];
                        if (button) {
                            const episodeNum = `E${episode.episode_number}`;
                            const episodeName = episode.name || 'Untitled';

                            let ratingParts = [];
                            ratingParts.push(`IMDb ${ratingData.imdb_rating}`);

                            if (ratingData.ratings && Array.isArray(ratingData.ratings)) {
                                const rtRating = ratingData.ratings.find(r => r.Source === 'Rotten Tomatoes');
                                if (rtRating && rtRating.Value) {
                                    ratingParts.push(`RT ${rtRating.Value}`);
                                }
                            }

                            const displayRating = ` (${ratingParts.join(', ')})`;
                            button.textContent = `${episodeNum}: ${episodeName}${displayRating}`;

                            // Update the onclick to include rating text
                            const ratingText = ratingParts.join(', ');
                            button.onclick = () => selectEpisode(episode.episode_number, episodeName, ratingText, episode.overview);
                        }

                        // Also update the selected episode button text if it's the current episode
                        if (episode.episode_number === currentSelectedEpisode) {
                            const episodeButtonText = document.getElementById('episodeButtonText');
                            if (episodeButtonText) {
                                const episodeNum = `E${episode.episode_number}`;
                                const episodeName = episode.name || 'Untitled';
                                let ratingParts = [];
                                ratingParts.push(`IMDb ${ratingData.imdb_rating}`);
                                if (ratingData.ratings && Array.isArray(ratingData.ratings)) {
                                    const rtRating = ratingData.ratings.find(r => r.Source === 'Rotten Tomatoes');
                                    if (rtRating && rtRating.Value) {
                                        ratingParts.push(`RT ${rtRating.Value}`);
                                    }
                                }
                                episodeButtonText.textContent = `${episodeNum}: ${episodeName} (${ratingParts.join(', ')})`;
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching rating for episode ${episode.episode_number}:`, error);
                }
            });

            // Wait for all ratings to load, then cache the full season data
            await Promise.all(ratingPromises);

            // Now fetch the full season data with ratings to cache it
            try {
                const response = await fetch(`${API_BASE_URL}/tv/${currentContentId}/season/${seasonNumber}`);
                const fullSeasonData = await response.json();
                const cacheKey = `${currentContentId}_${seasonNumber}`;
                episodeCache[cacheKey] = fullSeasonData;
            } catch (error) {
                console.error('Error caching full season data:', error);
            }
        }

        async function playMovie(movieId, startTime = null) {
            console.log(`[Play Movie] Starting playMovie(${movieId}, startTime: ${startTime})`);
            console.log(`[Play Movie] Current video source: ${videoSource}`);
            console.log(`[Play Movie] Watchparty active: ${watchpartyActive}, Is host: ${isHost}`);

            try {
                const response = await fetch(`${API_BASE_URL}/stream/${movieId}`);
                const data = await response.json();

                console.log('[Play Movie] API Response:', data); // Debug: see full API response

                if (data.error) {
                    throw new Error(data.error);
                }

                // Determine URL and type based on selected video source
                let streamUrl, streamType;
                const tmdbId = currentContentData?.id || movieId;

                if (videoSource === 'superembed') {
                    streamUrl = `${window.location.origin}/se_player.php?video_id=${tmdbId}&tmdb=1`;
                    streamType = 'embed';
                    console.log('SuperEmbed URL:', streamUrl);
                } else if (videoSource === 'vidking') {
                    streamUrl = `https://www.vidking.net/embed/movie/${tmdbId}`;
                    streamType = 'embed';
                    console.log('VidKing URL:', streamUrl);
                } else {
                    // VidSrc - Use stream extraction from API
                    streamUrl = data.stream_url || data.vidsrc_url;
                    streamType = data.stream_type || 'embed';
                    console.log('VidSrc URL:', streamUrl);
                    console.log('Stream type:', streamType);

                    // Additional check to ensure URL is valid
                    if (!streamUrl) {
                        console.error('No stream URL found in API response');
                        throw new Error('No stream URL available');
                    }
                }

                currentContentUrl = streamUrl;

                // Show the player section
                const playerSection = document.getElementById('playerSection');
                if (playerSection) {
                    playerSection.style.display = 'block';
                }

                // Load with appropriate player (video element for direct, iframe for embed)
                loadPlayerContent(streamUrl, startTime, streamType);

                // Broadcast content change to watchparty if host
                if (watchpartyActive && isHost && socket) {
                    socket.emit('sync_content', {
                        content: {
                            id: movieId,
                            title: data.title,
                            type: 'movie'
                        }
                    });
                }

            } catch (error) {
                console.error('Play movie error:', error);
                showError(`Failed to load movie: ${error.message}`);
            }
        }

        async function playTVEpisode(tvId, season, episode, startTime = null) {
            try {
                const response = await fetch(`${API_BASE_URL}/tv/stream/${tvId}?season=${season}&episode=${episode}`);
                const data = await response.json();

                console.log('API Response:', data); // Debug: see full API response

                if (data.error) {
                    throw new Error(data.error);
                }

                // Determine URL and type based on selected video source
                let streamUrl, streamType;
                const tmdbId = currentContentData?.id || tvId;

                if (videoSource === 'superembed') {
                    streamUrl = `${window.location.origin}/se_player.php?video_id=${tmdbId}&tmdb=1&s=${season}&e=${episode}`;
                    streamType = 'embed';
                    console.log('SuperEmbed URL:', streamUrl);
                } else if (videoSource === 'vidking') {
                    streamUrl = `https://www.vidking.net/embed/tv/${tmdbId}/${season}/${episode}`;
                    streamType = 'embed';
                    console.log('VidKing URL:', streamUrl);
                } else {
                    // VidSrc - Use stream extraction from API
                    streamUrl = data.stream_url || data.vidsrc_url;
                    streamType = data.stream_type || 'embed';
                    console.log('VidSrc URL:', streamUrl);
                    console.log('Stream type:', streamType);

                    // Additional check to ensure URL is valid
                    if (!streamUrl) {
                        console.error('No stream URL found in API response');
                        throw new Error('No stream URL available');
                    }
                }

                currentContentUrl = streamUrl;

                // Show the player section
                const playerSection = document.getElementById('playerSection');
                if (playerSection) {
                    playerSection.style.display = 'block';
                }

                // Load with appropriate player (video element for direct, iframe for embed)
                loadPlayerContent(streamUrl, startTime, streamType);

                // Show next episode button and check if there's a next episode
                updateNextEpisodeButton();

                // Update watch history with the current episode
                if (currentContentData && currentContentId) {
                    const title = currentContentData.name || currentContentData.title;
                    addToWatchHistory(currentContentId, title, 'tv', currentContentData, season, episode);
                }

                // Broadcast content change to watchparty if host
                if (watchpartyActive && isHost && socket) {
                    socket.emit('sync_content', {
                        content: {
                            id: tvId,
                            title: data.title,
                            type: 'tv',
                            season: season,
                            episode: episode
                        }
                    });
                }

            } catch (error) {
                console.error('Play TV episode error:', error);
                showError(`Failed to load episode: ${error.message}`);
            }
        }

        // New dropdown-based source selector functions
        window.toggleSourceMenu = function() {
            const dropdown = document.getElementById('sourceMenuDropdown');
            dropdown.classList.toggle('show');

            // Update checkmarks
            updateSourceCheckmarks();

            // Dismiss hint when user clicks source button
            dismissSourceHint();
        }

        function closeSourceMenu() {
            const dropdown = document.getElementById('sourceMenuDropdown');
            dropdown.classList.remove('show');
        }

        function updateSourceCheckmarks() {
            ['vidsrc', 'vidking', 'superembed'].forEach(source => {
                const check = document.getElementById(`${source}-check`);
                if (check) {
                    check.style.display = source === videoSource ? 'inline' : 'none';
                }
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const sourceContainer = document.getElementById('sourceMenuContainer');
            const dropdown = document.getElementById('sourceMenuDropdown');
            if (sourceContainer && dropdown && !sourceContainer.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // Legacy function for compatibility (now uses dropdown)
        window.showSourceSelector = function() {
            toggleSourceMenu();
        }

        // Legacy function for compatibility
        function closeSourceSelector() {
            closeSourceMenu();
        }

        function selectVideoSource(source) {
            videoSource = source;
            localStorage.setItem('videoSource', videoSource);
            updateVideoSourceButton();

            // Close modal
            closeSourceSelector();

            // Get current playback position before switching sources
            let currentTime = 0;
            const playerVideo = document.getElementById('playerVideo');
            if (playerVideo && playerVideo.style.display !== 'none' && !isNaN(playerVideo.currentTime)) {
                currentTime = Math.floor(playerVideo.currentTime);
                console.log(`[Source Switch] Preserving playback position: ${currentTime}s`);
            }

            // Reload current content with new source, preserving playback position
            if (currentContentId) {
                if (currentContentType === 'movie') {
                    playMovie(currentContentId, currentTime);
                } else if (currentContentType === 'tv' && currentSelectedSeason && currentSelectedEpisode) {
                    playTVEpisode(currentContentId, currentSelectedSeason, currentSelectedEpisode, currentTime);
                }
            }

            const sourceNames = {
                'vidsrc': 'VidSrc',
                'vidking': 'VidKing',
                'superembed': 'SuperEmbed'
            };

            // Show different message if in watchparty
            if (watchpartyActive) {
                // showStatus(`Switched to ${sourceNames[source]} (only affects your view)`);
            } else {
                // showStatus(`Switched to ${sourceNames[source]}`);
            }
        }

        function updateVideoSourceButton() {
            const container = document.getElementById('sourceMenuContainer');
            const btnText = document.getElementById('videoSourceBtnText');

            if (!container || !btnText) return;

            // Show container when content is loaded
            container.style.display = 'inline-block';

            // Update text to show current source
            const sourceNames = {
                'vidsrc': 'VidSrc',
                'vidking': 'VidKing',
                'superembed': 'SuperEmbed'
            };
            btnText.textContent = `Source: ${sourceNames[videoSource] || 'VidSrc'}`;

            // Update checkmarks
            updateSourceCheckmarks();

            // Hide sports source button when playing movies/TV
            const sportsSourceBtn = document.getElementById('sportsSourceBtn');
            if (sportsSourceBtn) sportsSourceBtn.style.display = 'none';

            // Show hint if user hasn't dismissed it
            showSourceHint();
        }

        // Source tooltip hint - simple implementation
        // Track if hint has been shown in this session only (not persisted)
        let sourceHintShownThisSession = false;

        function showSourceHint() {
            // Only show once per page load/session
            if (sourceHintShownThisSession) {
                return;
            }

            const hint = document.getElementById('sourceTooltipHint');
            if (hint) {
                sourceHintShownThisSession = true;
                // Show after 1 second delay
                setTimeout(() => {
                    hint.classList.add('active');
                }, 1000);
            }
        }

        window.dismissSourceHint = function() {
            const hint = document.getElementById('sourceTooltipHint');
            if (hint) {
                hint.classList.remove('active');
            }
        }

        function updateNextEpisodeButton() {
            const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');

            if (currentContentType === 'tv' && currentContentData) {
                // Get cached episode data for current season
                const cacheKey = `${currentContentId}_${currentSelectedSeason}`;
                const seasonData = episodeCache[cacheKey];
                const maxEpisode = seasonData?.episodes?.length || 0;

                // Check if there's a next episode in current season or next season
                const hasNextEpisode = currentSelectedEpisode < maxEpisode || currentSelectedSeason < currentSeasons.length;

                nextEpisodeBtn.style.display = hasNextEpisode ? 'inline-block' : 'none';
            } else {
                nextEpisodeBtn.style.display = 'none';
            }
        }

        window.playNextEpisode = async function() {
            if (currentContentType !== 'tv' || !currentContentData) {
                showError('Not playing a TV show');
                return;
            }

            // Get cached episode data for current season
            const cacheKey = `${currentContentId}_${currentSelectedSeason}`;
            const seasonData = episodeCache[cacheKey];
            const maxEpisode = seasonData?.episodes?.length || 0;

            // Try to go to next episode
            if (currentSelectedEpisode < maxEpisode) {
                // Next episode in same season
                currentSelectedEpisode++;
                document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(currentSelectedEpisode);
            } else if (currentSelectedSeason < currentSeasons.length) {
                // First episode of next season
                currentSelectedSeason++;
                document.getElementById('seasonButtonText').textContent = `Season ${currentSelectedSeason}`;

                // Update episode selector for new season
                await updateEpisodeSelector(currentSelectedSeason);

                currentSelectedEpisode = 1;
                document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(1, currentSelectedSeason);
            } else {
                // showStatus('No more episodes available');
                return;
            }

            // Update episode description for the next episode
            const newCacheKey = `${currentContentId}_${currentSelectedSeason}`;
            const newSeasonData = episodeCache[newCacheKey];
            if (newSeasonData && newSeasonData.episodes) {
                const nextEpisode = newSeasonData.episodes.find(ep => ep.episode_number === currentSelectedEpisode);
                if (nextEpisode) {
                    const descriptionSection = document.getElementById('episodeDescription');
                    const descriptionText = document.getElementById('episodeDescriptionText');

                    if (nextEpisode.overview && nextEpisode.overview.trim() !== '') {
                        descriptionText.textContent = nextEpisode.overview;
                        descriptionSection.style.display = 'block';
                    } else {
                        descriptionSection.style.display = 'none';
                    }
                }
            }

            // Play the next episode
            playTVEpisode(currentContentId, currentSelectedSeason, currentSelectedEpisode);
        }

        function loadPlayerContent(url, startTime = null, streamType = 'embed') {
            const playerIframe = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');
            const placeholder = document.getElementById('playerPlaceholder');

            console.log('Loading player with URL:', url);
            console.log('Stream type:', streamType);

            // Defensive check: ensure URL is valid
            if (!url) {
                console.error('loadPlayerContent called with undefined/null URL');
                showError('Failed to load stream - no URL provided');
                return;
            }

            // Check if it's a direct stream (.m3u8) or embed
            if (streamType === 'direct' || url.includes('.m3u8')) {
                console.log('Using VIDEO element for direct stream');

                // Hide iframe and placeholder
                if (playerIframe) playerIframe.style.display = 'none';
                if (placeholder) placeholder.style.display = 'none';

                // Show video element, comments button, and stop button
                if (playerVideo) {
                    playerVideo.style.display = 'block';
                    const commentsBtn = document.getElementById('commentsBtn');
                    if (commentsBtn && authToken) commentsBtn.style.display = 'inline-block';
                    const stopBtn = document.getElementById('stopBtn');
                    if (stopBtn) stopBtn.style.display = 'inline-block';

                    // Check if HLS.js is supported
                    if (Hls.isSupported()) {
                        // Destroy existing HLS instance if any
                        if (window.hls) {
                            window.hls.destroy();
                        }

                        // Create new HLS instance
                        window.hls = new Hls({
                            enableWorker: true,
                            lowLatencyMode: false,
                            backBufferLength: 90,
                            maxBufferLength: 30,
                            maxMaxBufferLength: 600
                        });

                        // Load the source
                        window.hls.loadSource(url);
                        window.hls.attachMedia(playerVideo);

                        // Handle events
                        window.hls.on(Hls.Events.MANIFEST_PARSED, function() {
                            console.log('HLS manifest parsed, ready to play');

                            // Seek to start time if provided
                            if (startTime !== null && startTime > 0) {
                                playerVideo.currentTime = startTime;
                            }

                            playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                        });

                        // Setup watchparty sync listeners for movies/TV
                        videoSyncListenersAttached = false; // Reset flag
                        setupVideoSyncListeners(playerVideo);

                        window.hls.on(Hls.Events.ERROR, function(event, data) {
                            console.error('HLS error:', data);
                            if (data.fatal) {
                                switch(data.type) {
                                    case Hls.ErrorTypes.NETWORK_ERROR:
                                        showError('Network error - trying to recover...');
                                        window.hls.startLoad();
                                        break;
                                    case Hls.ErrorTypes.MEDIA_ERROR:
                                        showError('Media error - trying to recover...');
                                        window.hls.recoverMediaError();
                                        break;
                                    default:
                                        showError('Fatal error - cannot play this stream. Try switching sources.');
                                        window.hls.destroy();
                                        break;
                                }
                            }
                        });
                    }
                    // Check if the browser supports HLS natively (Safari)
                    else if (playerVideo.canPlayType('application/vnd.apple.mpegurl')) {
                        playerVideo.src = url;

                        if (startTime !== null && startTime > 0) {
                            playerVideo.addEventListener('loadedmetadata', function() {
                                playerVideo.currentTime = startTime;
                                playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                            }, { once: true });
                        } else {
                            playerVideo.addEventListener('loadedmetadata', function() {
                                playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                            }, { once: true });
                        }

                        // Setup watchparty sync listeners
                        videoSyncListenersAttached = false;
                        setupVideoSyncListeners(playerVideo);
                    } else {
                        showError('HLS playback not supported in this browser');
                    }
                }

                // showStatus('Loading direct stream with full sync support...');

            } else {
                console.log('Using IFRAME for embed');

                // Hide video element
                if (playerVideo) {
                    playerVideo.style.display = 'none';
                    playerVideo.pause();
                    playerVideo.src = '';
                }

                // Destroy HLS instance
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }

                // Detect Safari (but not Chrome)
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

                if (isSafari) {
                    // Show Safari subtitle info
                }

                playerIframe.src = url;
                playerIframe.style.display = 'block';
                placeholder.style.display = 'none';

                // Show comments button and stop button
                const commentsBtn = document.getElementById('commentsBtn');
                if (commentsBtn && authToken) commentsBtn.style.display = 'inline-block';
                const stopBtn = document.getElementById('stopBtn');
                if (stopBtn) stopBtn.style.display = 'inline-block';

                console.log('Player iframe src set to:', playerIframe.src);

                // For iframe embeds, we need to manually track play/pause since we can't access iframe internals
                // But we CAN receive sync commands from others
                if (watchpartyActive) {
                    console.log('[Watchparty] Iframe loaded - can receive sync but cannot auto-send');
                    console.warn('[Watchparty]  For best watchparty experience, use VidSrc source (direct stream)');
                    showStatus(' Limited sync with this source - Switch to VidSrc for full sync', 'warning');
                } else {
                }
            }

            // Prevent iframe from auto-fullscreening on mobile
            preventAutoFullscreen();

            // Start tracking watch progress
            startProgressTracking();
        }

        // Prevent VidKing player from auto-fullscreening on mobile
        function preventAutoFullscreen() {
            // Listen for fullscreen change events
            const fullscreenChangeHandler = () => {
                const player = document.getElementById('contentPlayer');
                const container = document.querySelector('.player-container');

                // If iframe went fullscreen but container didn't, exit iframe fullscreen
                if (document.fullscreenElement === player && !container.contains(document.fullscreenElement)) {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                }

                // Manage watchparty panel and sidebar based on fullscreen state
                if (watchpartyActive) {
                    const isFullscreen = document.fullscreenElement ||
                                        document.webkitFullscreenElement ||
                                        document.mozFullScreenElement ||
                                        document.msFullscreenElement;

                    const panel = document.getElementById('watchpartyPanel');
                    const sidebar = document.getElementById('watchpartySidebar');

                    if (isFullscreen) {
                        // When entering fullscreen: move sidebar into player-container
                        // Check if the container itself is fullscreen OR if it contains the fullscreen element
                        const containerIsFullscreen = isFullscreen === container ||
                                                     (container && container.contains(isFullscreen));

                        if (sidebar && containerIsFullscreen) {
                            sidebar.classList.add('fullscreen-mode');
                            // Only append if not already in container
                            if (!container.contains(sidebar)) {
                                container.appendChild(sidebar);
                            }
                        }
                    } else {
                        // When exiting fullscreen: move sidebar back out and remove class
                        if (sidebar) {
                            sidebar.classList.remove('fullscreen-mode');
                            // Move sidebar back to its original position (outside container, after script tag)
                            const containerDiv = document.querySelector('.container');
                            if (containerDiv && containerDiv.parentNode && container.contains(sidebar)) {
                                // Insert after the container div
                                containerDiv.parentNode.insertBefore(sidebar, containerDiv.nextSibling);
                            }
                        }

                        if (panel) {
                            // When exiting fullscreen and in a watchparty, hide the panel
                            // (chat is shown in sidebar instead)
                            panel.classList.remove('active');
                        }
                    }
                }
            };

            document.addEventListener('fullscreenchange', fullscreenChangeHandler);
            document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
            document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
            document.addEventListener('MSFullscreenChange', fullscreenChangeHandler);
        }

        // Progress tracking system
        let progressTrackingInterval = null;

        function startProgressTracking() {
            // Clear any existing tracking
            if (progressTrackingInterval) {
                clearInterval(progressTrackingInterval);
            }

            // Save progress every 10 seconds
            progressTrackingInterval = setInterval(() => {
                saveCurrentProgress();
            }, 10000);

            // Also save on page unload
            window.addEventListener('beforeunload', saveCurrentProgress);
        }

        function saveCurrentProgress() {
            if (!currentContentId || !currentContentType) return;

            // Find the item in watch history
            const existingIndex = watchHistory.findIndex(
                item => item.id === currentContentId && item.type === currentContentType
            );

            if (existingIndex === -1) return;

            // Since we can't access iframe video element, we'll use a simpler approach:
            // Mark as "in progress" after 10 seconds of viewing
            const now = new Date();
            const item = watchHistory[existingIndex];
            const viewingTime = (now - new Date(item.lastWatched)) / 1000; // seconds

            // Estimate progress based on viewing time (rough approximation)
            // Average movie is ~120 minutes, average episode is ~45 minutes
            const estimatedDuration = currentContentType === 'tv' ? 2700 : 7200; // seconds
            const estimatedProgress = Math.min(95, (viewingTime / estimatedDuration) * 100);

            watchHistory[existingIndex].progress = Math.max(item.progress, estimatedProgress);
            watchHistory[existingIndex].lastWatched = now.toISOString();

            localStorage.setItem('streamingSite_watchHistory', JSON.stringify(watchHistory));
        }

        function stopProgressTracking() {
            if (progressTrackingInterval) {
                clearInterval(progressTrackingInterval);
                progressTrackingInterval = null;
            }
            saveCurrentProgress();
        }

        window.stopPlayback = function() {
            const player = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');
            const placeholder = document.getElementById('playerPlaceholder');
            const currentContent = document.getElementById('currentContent');

            // Stop progress tracking and save final state
            stopProgressTracking();

            player.src = 'about:blank';
            player.style.display = 'none';

            // Stop video player and destroy HLS instance
            if (playerVideo) {
                playerVideo.pause();
                playerVideo.src = '';
                playerVideo.style.display = 'none';
            }
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }

            placeholder.style.display = 'flex';
            currentContent.style.display = 'none';

            // Clear backdrop image
            const backdropEl = document.getElementById('backdropImage');
            if (backdropEl) {
                backdropEl.style.backgroundImage = '';
                backdropEl.classList.remove('loaded');
            }

            // Clear player background effects
            clearPlayerBackgroundEffects();

            // Hide sports source button
            const sportsSourceBtn = document.getElementById('sportsSourceBtn');
            if (sportsSourceBtn) sportsSourceBtn.style.display = 'none';

            // Clear sports match data
            currentSportsMatch = null;
            currentSportsSourceIndex = 0;

            currentContentUrl = '';
            currentContentId = null;
            currentContentData = null;

            // Reset ratings refresh trackers for next content
            if (typeof __lastRefreshedContentId !== 'undefined') {
                __lastRefreshedContentId = null;
            }
            if (typeof __earlyLastRefreshedContentId !== 'undefined') {
                __earlyLastRefreshedContentId = null;
            }

            // Reset source hint for next content load
            sourceHintShownThisSession = false;

            // Hide stop button
            const stopBtn = document.getElementById('stopBtn');
            if (stopBtn) stopBtn.style.display = 'none';

            // Hide player section
            const playerSection = document.getElementById('playerSection');
            if (playerSection) playerSection.style.display = 'none';

            // Broadcast stop to watchparty if host
            if (watchpartyActive && isHost && socket) {
                socket.emit('sync_stop');
            }
        }

        window.toggleFullscreen = function() {
            const container = document.querySelector('.player-container');

            if (!container) {
                console.error('Player container not found');
                return;
            }

            // Always use container for fullscreen (more reliable across devices)
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.webkitCurrentFullScreenElement) {
                console.log('Attempting to enter fullscreen...');
                // Try to enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen()
                        .then(() => {
                            console.log('Fullscreen entered successfully');
                        })
                        .catch(err => {
                            console.error('Fullscreen request failed:', err);
                        });
                } else if (container.webkitRequestFullscreen) {
                    try {
                        container.webkitRequestFullscreen();
                        console.log('Webkit fullscreen requested');
                    } catch (err) {
                        console.error('Webkit fullscreen failed:', err);
                    }
                } else if (container.mozRequestFullScreen) {
                    try {
                        container.mozRequestFullScreen();
                        console.log('Mozilla fullscreen requested');
                    } catch (err) {
                        console.error('Mozilla fullscreen failed:', err);
                    }
                } else if (container.msRequestFullscreen) {
                    try {
                        container.msRequestFullscreen();
                        console.log('MS fullscreen requested');
                    } catch (err) {
                        console.error('MS fullscreen failed:', err);
                    }
                } else {
                }
            } else {
                console.log('Attempting to exit fullscreen...');
                // Try to exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen()
                        .then(() => {
                            console.log('Exited fullscreen successfully');
                        })
                        .catch(err => {
                            console.error('Exit fullscreen failed:', err);
                        });
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        window.copyCurrentUrl = function() {
            if (currentContentUrl) {
                navigator.clipboard.writeText(currentContentUrl).then(() => {
                }).catch(() => {
                    showError('Failed to copy URL');
                });
            } else {
                showError('No content is currently loaded');
            }
        }


        function clearResults() {
            document.getElementById('contentResults').innerHTML = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('yearInput').value = '';
            hideStatus();
            hideError();
        }

        window.showTab = function(tabName) {
            console.log('[showTab] Called with:', tabName);
            currentTab = tabName;
            currentGenreId = null; // Reset genre filter
            currentPage = 1; // Reset page

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Hide all sections
            document.getElementById('contentResults').style.display = 'none';
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            document.getElementById('sportsDisplay').style.display = 'none';
            document.getElementById('channelsDisplay').style.display = 'none';

            const genreContainer = document.getElementById('genreFilterContainer');
            const genreDropdown = document.getElementById('genreDropdown');
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (genreContainer) genreContainer.style.display = 'none';
            if (genreDropdown) genreDropdown.classList.remove('active');
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            if (tabName === 'continue-watching') {
                document.getElementById('continueWatchingTab').classList.add('active');
                document.getElementById('continueWatchingDisplay').style.display = 'grid';
                displayContinueWatchingInResults();
            } else if (tabName === 'watchlist') {
                document.getElementById('watchlistTab').classList.add('active');
                document.getElementById('watchlistDisplay').style.display = 'grid';
                displayWatchlistInResults();
            } else if (tabName === 'statistics') {
                document.getElementById('statisticsTab').classList.add('active');
                document.getElementById('statisticsDisplay').style.display = 'block';
                displayStatistics();
            } else if (tabName === 'search-results') {
                document.querySelector('.tab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
            } else if (tabName === 'recommendations') {
                document.getElementById('recommendationsTab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
                loadRecommendations();
            } else if (tabName === 'movies') {
                document.getElementById('moviesTab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
                currentMediaType = 'movie';
                currentContentFilter = 'popular'; // Default to popular

                // Show content type filters
                const contentTypeFilters = document.getElementById('contentTypeFilters');
                if (contentTypeFilters) {
                    contentTypeFilters.style.display = 'flex';
                    // Show Upcoming button for movies
                    document.getElementById('upcomingFilterBtn').style.display = 'inline-block';
                    // Reset filter buttons
                    document.querySelectorAll('#contentTypeFilters .bg-animation-toggle').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.getElementById('popularFilterBtn').classList.add('active');
                    loadGenres('movie');
                }
                loadPopularMovies();
            } else if (tabName === 'tv-shows') {
                document.getElementById('tvShowsTab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
                currentMediaType = 'tv';
                currentContentFilter = 'popular'; // Default to popular

                // Show content type filters
                const contentTypeFilters = document.getElementById('contentTypeFilters');
                if (contentTypeFilters) {
                    contentTypeFilters.style.display = 'flex';
                    // Hide Upcoming button for TV shows
                    document.getElementById('upcomingFilterBtn').style.display = 'none';
                    // Reset filter buttons
                    document.querySelectorAll('#contentTypeFilters .bg-animation-toggle').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.getElementById('popularFilterBtn').classList.add('active');
                    loadGenres('tv');
                }
                loadPopularTVShows();
            } else if (tabName === 'sports') {
                document.getElementById('sportsTab').classList.add('active');
                document.getElementById('sportsDisplay').style.display = 'block';
                loadSportsData();
            } else if (tabName === 'channels') {
                document.getElementById('channelsTab').classList.add('active');
                document.getElementById('channelsDisplay').style.display = 'block';
                loadLiveChannels();
            }
        }

        // Set content filter (Popular/Trending/Now Playing/Upcoming)
        function setContentFilter(filter) {
            currentContentFilter = filter;
            currentGenreId = null; // Reset genre filter
            currentPage = 1; // Reset page

            // Update filter button states
            document.querySelectorAll('#contentTypeFilters .bg-animation-toggle').forEach(btn => {
                btn.classList.remove('active');
            });

            // Activate the selected filter button
            if (filter === 'popular') {
                document.getElementById('popularFilterBtn').classList.add('active');
            } else if (filter === 'trending') {
                document.getElementById('trendingFilterBtn').classList.add('active');
            } else if (filter === 'now-playing') {
                document.getElementById('nowPlayingFilterBtn').classList.add('active');
            } else if (filter === 'upcoming') {
                document.getElementById('upcomingFilterBtn').classList.add('active');
            }

            // Load content based on media type and filter
            if (currentMediaType === 'movie') {
                if (filter === 'popular') {
                    loadPopularMovies();
                } else if (filter === 'trending') {
                    loadTrendingMovies();
                } else if (filter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (filter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (filter === 'popular') {
                    loadPopularTVShows();
                } else if (filter === 'trending') {
                    loadTrendingTVShows();
                } else if (filter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        // Genre filtering functions
        async function loadGenres(type) {
            try {
                const endpoint = type === 'movie' ? '/genres/movies' : '/genres/tv';
                const response = await fetch(`${API_BASE_URL}${endpoint}`);
                const data = await response.json();

                if (type === 'movie') {
                    movieGenresList = data.genres || [];
                } else {
                    tvGenresList = data.genres || [];
                }

                displayGenres(type);
            } catch (error) {
                console.error('Error loading genres:', error);
            }
        }

        function displayGenres(type) {
            const genreList = document.getElementById('genreList');
            const genres = type === 'movie' ? movieGenresList : tvGenresList;

            genreList.innerHTML = `
                <button class="effects-btn" onclick="selectGenre(null, '${type}')" style="width: 100%; padding: 12px;">
                    All Genres
                </button>
            `;

            genres.forEach(genre => {
                const button = document.createElement('button');
                button.className = 'effects-btn';
                button.style.width = '100%';
                button.style.padding = '12px';
                button.textContent = genre.name;
                button.onclick = () => selectGenre(genre.id, type);
                genreList.appendChild(button);
            });
        }

        function toggleGenreModal() {
            const modal = document.getElementById('genreModal');
            if (modal) {
                modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
            }
        }

        function closeGenreModal() {
            const modal = document.getElementById('genreModal');
            if (modal) modal.style.display = 'none';
        }

        function toggleLanguageModal() {
            const modal = document.getElementById('languageModal');
            if (modal) {
                modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
            }
        }

        function closeLanguageModal() {
            const modal = document.getElementById('languageModal');
            if (modal) modal.style.display = 'none';
        }

        async function filterByLanguage(languageCode) {
            currentLanguage = languageCode;
            currentPage = 1; // Reset page
            closeLanguageModal();

            // Map language codes to names
            const languageNames = {
                'en': 'English',
                'ar': 'Arabic',
                'ko': 'Korean',
                'ja': 'Japanese',
                'zh': 'Chinese'
            };

            // Update display
            const languageName = languageCode ? languageNames[languageCode] : '';

            // If a genre is already selected, reload with both filters
            if (currentGenreId !== null) {
                const genreName = (currentMediaType === 'movie' ? movieGenresList : tvGenresList).find(g => g.id === currentGenreId)?.name || 'Selected Genre';
                updateActiveFiltersDisplay(genreName, languageName);

                // Load genre-filtered content with language
                await loadContentWithFilters(currentMediaType, currentGenreId);
                return;
            }

            updateActiveFiltersDisplay(null, languageName);

            // Reload current content with language filter
            if (currentMediaType === 'movie') {
                if (currentContentFilter === 'popular') {
                    loadPopularMovies();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingMovies();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (currentContentFilter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (currentContentFilter === 'popular') {
                    loadPopularTVShows();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingTVShows();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        async function loadContentWithFilters(type, genreId) {
            // This function loads content with both genre and language filters applied
            try {
                const endpoint = type === 'movie' ? '/discover/movies' : '/discover/tv';
                let url = `${API_BASE_URL}${endpoint}?genre=${genreId}&page=${currentPage}`;

                // Add language filter if selected
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }

                console.log('Loading content with URL:', url);  // Debug log

                const response = await fetch(url);
                const data = await response.json();

                const genreName = (type === 'movie' ? movieGenresList : tvGenresList).find(g => g.id === genreId)?.name || 'Selected Genre';

                // Map language codes to names for display
                const languageNames = {
                    'en': 'English',
                    'ar': 'Arabic',
                    'ko': 'Korean',
                    'ja': 'Japanese',
                    'zh': 'Chinese'
                };
                const languageName = currentLanguage ? languageNames[currentLanguage] : null;

                updateActiveFiltersDisplay(genreName, languageName);
                displayContent(data.results || [], `${genreName} ${type === 'movie' ? 'Movies' : 'TV Shows'}`);
            } catch (error) {
                console.error('Error loading filtered content:', error);
                displayContent([], 'Error loading content');
            }
        }

        async function selectGenre(genreId, type) {
            currentGenreId = genreId;
            currentPage = 1;
            closeGenreModal();

            if (genreId === null) {
                updateActiveFiltersDisplay();
                // Load all content (popular or trending based on current tab)
                if (currentTab === 'popular-movies') {
                    loadPopularMovies();
                } else if (currentTab === 'popular-tv') {
                    loadPopularTVShows();
                } else if (currentTab === 'trending-movies') {
                    loadTrendingMovies();
                } else if (currentTab === 'trending-tv') {
                    loadTrendingTVShows();
                }
            } else {
                // Load genre-filtered content with current language filter
                await loadContentWithFilters(type, genreId);
            }
        }

        function updateActiveFiltersDisplay(genreName = null, languageName = null) {
            const activeFiltersDiv = document.getElementById('activeFiltersDisplay');
            const activeGenreSpan = document.getElementById('activeGenreDisplay');
            const activeLanguageSpan = document.getElementById('activeLanguageDisplay');
            const genreNameSpan = document.getElementById('genreName');
            const languageNameSpan = document.getElementById('languageName');

            // Update genre display
            if (genreName !== null) {
                if (genreName) {
                    genreNameSpan.textContent = genreName;
                    activeGenreSpan.style.display = 'inline';
                } else {
                    activeGenreSpan.style.display = 'none';
                }
            }

            // Update language display
            if (languageName !== null) {
                if (languageName) {
                    languageNameSpan.textContent = languageName;
                    activeLanguageSpan.style.display = 'inline';
                } else {
                    activeLanguageSpan.style.display = 'none';
                }
            }

            // Show/hide the entire filters display
            const hasActiveFilters = activeGenreSpan.style.display !== 'none' || activeLanguageSpan.style.display !== 'none';
            activeFiltersDiv.style.display = hasActiveFilters ? 'block' : 'none';
        }

        function clearGenreFilter() {
            currentGenreId = null;
            currentPage = 1;
            updateActiveFiltersDisplay('');

            // Reload current content
            if (currentMediaType === 'movie') {
                if (currentContentFilter === 'popular') {
                    loadPopularMovies();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingMovies();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (currentContentFilter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (currentContentFilter === 'popular') {
                    loadPopularTVShows();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingTVShows();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        function clearLanguageFilter() {
            currentLanguage = null;
            currentPage = 1;
            updateActiveFiltersDisplay(null, '');

            // Reload current content
            if (currentMediaType === 'movie') {
                if (currentContentFilter === 'popular') {
                    loadPopularMovies();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingMovies();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (currentContentFilter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (currentContentFilter === 'popular') {
                    loadPopularTVShows();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingTVShows();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        // Recommendations function - loads based on currently playing content, or aggregate if nothing playing
        async function loadRecommendations() {
            // If something is currently playing, show recommendations for that specific item
            if (currentContentId && currentContentType) {
                try {
                    const endpoint = currentContentType === 'movie'
                        ? `/recommendations/movies/${currentContentId}`
                        : `/recommendations/tv/${currentContentId}`;

                    const response = await fetch(`${API_BASE_URL}${endpoint}`);
                    const data = await response.json();

                    const title = currentContentData?.title || currentContentData?.name || 'This Content';
                    displayContent(data.results || [], `Similar to "${title}"`);
                } catch (error) {
                    console.error('Error loading recommendations:', error);
                    displayContent([], 'Error loading recommendations');
                }
                return;
            }

            // Otherwise, show aggregate recommendations from watch history + watchlist
            const allWatchlists = Object.values(watchlists).flat();
            const recentHistory = watchHistory.slice(0, 10); // Last 10 watched
            const allItems = [...recentHistory, ...allWatchlists];

            if (allItems.length === 0) {
                displayContent([], 'Watch something first to get recommendations!');
                return;
            }

            try {
                // Collect recommendations from multiple sources
                const recommendationPromises = allItems.slice(0, 5).map(item => {
                    const endpoint = item.type === 'movie'
                        ? `/recommendations/movies/${item.id}`
                        : `/recommendations/tv/${item.id}`;
                    return fetch(`${API_BASE_URL}${endpoint}`)
                        .then(res => res.json())
                        .catch(() => ({ results: [] }));
                });

                const recommendationSets = await Promise.all(recommendationPromises);

                // Combine and deduplicate recommendations
                const allRecommendations = [];
                const seenIds = new Set();

                recommendationSets.forEach(set => {
                    (set.results || []).forEach(item => {
                        const itemId = item.id;
                        if (!seenIds.has(itemId)) {
                            seenIds.add(itemId);
                            allRecommendations.push(item);
                        }
                    });
                });

                // Sort by vote average (popularity)
                allRecommendations.sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));

                displayContent(allRecommendations.slice(0, 20), 'Recommended For You');
            } catch (error) {
                console.error('Error loading recommendations:', error);
                displayContent([], 'Error loading recommendations');
            }
        }

        // Auto-load recommendations when playing content (just triggers a reload if on recommendations tab)
        async function autoLoadRecommendations() {
            // If user is on recommendations tab, reload it with new data
            if (currentTab === 'recommendations') {
                await loadRecommendations();
            }
        }

        // Watchlist functionality
        // Store current item being added to watchlist
        let pendingWatchlistItem = null;
        let watchlistScrollPosition = 0;

        function toggleWatchlist(id, title, type, posterUrl, year, rating, event) {
            const panel = document.getElementById('watchlistPanel');
            if (!panel) return;

            // Store current item data
            window.pendingWatchlistPanelItem = {
                id: id,
                title: title,
                type: type,
                posterUrl: posterUrl,
                year: year,
                rating: rating,
                addedAt: new Date().toISOString()
            };

            // Check if item is in any watchlist
            const inLists = Object.keys(watchlists).filter(listName =>
                watchlists[listName].some(item => item.id === id && item.type === type)
            );

            // Update panel content
            updateWatchlistPanel(inLists);

            // Position panel near the clicked button
            const button = event.target;
            const rect = button.getBoundingClientRect();

            // Position below button, but adjust if too close to bottom
            const spaceBelow = window.innerHeight - rect.bottom;
            const panelHeight = 400; // max-height of panel

            if (spaceBelow < panelHeight && rect.top > panelHeight) {
                // Position above button if not enough space below
                panel.style.top = `${rect.top + window.scrollY - panelHeight - 5}px`;
            } else {
                // Position below button
                panel.style.top = `${rect.bottom + window.scrollY + 5}px`;
            }

            panel.style.left = `${rect.left + window.scrollX}px`;
            panel.style.display = 'flex';
        }

        function showWatchlistModal(event) {
            const modal = document.getElementById('watchlistModal');
            const content = document.getElementById('watchlistPanelContent');
            const title = document.getElementById('watchlistModalTitle');
            const createSection = document.getElementById('watchlistCreateSection');

            if (!modal || !content) {
                console.error('Watchlist modal elements not found');
                return;
            }

            // Save current scroll position
            watchlistScrollPosition = window.pageYOffset || document.documentElement.scrollTop;

            // Update title and show create section
            title.textContent = ' ADD TO WATCHLIST';
            createSection.style.display = 'block';

            const listNames = Object.keys(watchlists);

            if (listNames.length === 0) {
                watchlists['My Watchlist'] = [];
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
            }

            content.innerHTML = Object.keys(watchlists).map(listName => `
                <button onclick="addToSpecificWatchlist('${listName.replace(/'/g, "\\'")}')" class="effects-btn" style="width: 100%; padding: 12px;">
                    ${listName}
                </button>
            `).join('');

            // Show modal
            modal.style.display = 'flex';

            // Scroll to modal
            modal.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Add escape key handler
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeWatchlistModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        function showWatchlistRemovalModal(id, title, type, inLists, event) {
            const modal = document.getElementById('watchlistModal');
            const content = document.getElementById('watchlistPanelContent');
            const modalTitle = document.getElementById('watchlistModalTitle');
            const createSection = document.getElementById('watchlistCreateSection');

            // Save current scroll position
            watchlistScrollPosition = window.pageYOffset || document.documentElement.scrollTop;

            // Update title and hide create section
            modalTitle.textContent = ' REMOVE FROM WATCHLIST';
            createSection.style.display = 'none';

            content.innerHTML = inLists.map(listName => `
                <button onclick="removeFromSpecificWatchlist('${listName.replace(/'/g, "\\'")}', ${id}, '${type}')" class="effects-btn" style="width: 100%; padding: 12px; background: rgba(255, 59, 48, 0.15); border-color: #FF453A; color: #FF453A;">
                    ${listName}
                </button>
            `).join('');

            // Show modal
            modal.style.display = 'flex';

            // Scroll to modal
            modal.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Add escape key handler
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeWatchlistModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        async function addToSpecificWatchlist(listName) {
            if (!pendingWatchlistItem) return;

            // If user is logged in, use API
            if (authToken) {
                try {
                    await addToWatchlistAPI(
                        pendingWatchlistItem.id,
                        pendingWatchlistItem.type,
                        pendingWatchlistItem.title,
                        pendingWatchlistItem.posterUrl,
                        listName
                    );
                    closeWatchlistModal();
                    updateWatchlistButtons();

                    // Update player watchlist button if currently playing this content
                    if (currentContentId === pendingWatchlistItem.id && currentContentType === pendingWatchlistItem.type) {
                        updatePlayerWatchlistButton(currentContentId, currentContentType);
                    }
                } catch (error) {
                    showError('Failed to add to watchlist');
                }
            } else {
                // Fallback to localStorage for non-authenticated users
                watchlists[listName].push(pendingWatchlistItem);
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

                closeWatchlistModal();
                updateWatchlistButtons();

                // Update player watchlist button if currently playing this content
                if (currentContentId === pendingWatchlistItem.id && currentContentType === pendingWatchlistItem.type) {
                    updatePlayerWatchlistButton(currentContentId, currentContentType);
                }

                // If currently viewing this watchlist, refresh it
                if (currentWatchlistName === listName) {
                    displayWatchlistInResults();
                }
            }
        }

        async function removeFromSpecificWatchlist(listName, id, type) {
            // If user is logged in, use API
            if (authToken) {
                try {
                    await removeFromWatchlistAPI(id);
                    closeWatchlistModal();
                    updateWatchlistButtons();

                    // Update player watchlist button if currently playing this content
                    if (currentContentId === id && currentContentType === type) {
                        updatePlayerWatchlistButton(currentContentId, currentContentType);
                    }
                } catch (error) {
                    showError('Failed to remove from watchlist');
                }
            } else {
                // Fallback to localStorage for non-authenticated users
                const index = watchlists[listName].findIndex(item => item.id === id && item.type === type);
                if (index > -1) {
                    const item = watchlists[listName][index];
                    watchlists[listName].splice(index, 1);
                    localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

                    // showStatus(`Removed "${item.title}" from ${listName}`);
                    closeWatchlistModal();
                    updateWatchlistButtons();

                    // Update player watchlist button if currently playing this content
                    if (currentContentId === id && currentContentType === type) {
                        updatePlayerWatchlistButton(currentContentId, currentContentType);
                    }

                    // If currently viewing this watchlist, refresh it
                    if (currentWatchlistName === listName) {
                        displayWatchlistInResults();
                    }
                }
            }
        }

        function createNewWatchlist() {
            const input = document.getElementById('newWatchlistName');
            const name = input.value.trim();

            if (!name) {
                showError('Please enter a watchlist name');
                return;
            }

            if (watchlists[name]) {
                showError('A watchlist with this name already exists');
                return;
            }

            watchlists[name] = [];
            localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

            // showStatus(`Created new watchlist: ${name}`);
            input.value = '';

            // If we have a pending item, add it to the new list
            if (pendingWatchlistItem) {
                addToSpecificWatchlist(name);
            } else {
                showWatchlistModal();
            }
        }

        function closeWatchlistModal() {
            const modal = document.getElementById('watchlistModal');
            if (modal) modal.style.display = 'none';
            pendingWatchlistItem = null;

            // Restore scroll position
            window.scrollTo({ top: watchlistScrollPosition, behavior: 'smooth' });
        }

        function updateWatchlistButtons() {
            const watchlistBtns = document.querySelectorAll(`.watchlist-btn`);
            watchlistBtns.forEach(btn => {
                const btnParent = btn.closest('.content-card');
                if (btnParent) {
                    const onclickAttr = btnParent.getAttribute('onclick');
                    const match = onclickAttr?.match(/playContent\((\d+),/);
                    if (match) {
                        const id = parseInt(match[1]);
                        const isInList = isItemInAnyWatchlist(id);
                        btn.textContent = isInList ? '' : '';
                        btn.className = isInList ? 'watchlist-btn added' : 'watchlist-btn';
                        btn.title = isInList ? 'In Watchlist' : 'Add to Watchlist';
                    }
                }
            });
        }

        function isItemInWatchlist(id, type) {
            return isItemInAnyWatchlist(id, type);
        }

        function isItemInAnyWatchlist(id, type) {
            return Object.values(watchlists).some(list =>
                list.some(item => item.id === id && (!type || item.type === type))
            );
        }

        function getWatchProgress(id, type) {
            const item = watchHistory.find(item => item.id === id && item.type === type);
            return item ? Math.round(item.progress) : 0;
        }

        function updateWatchlist() {
            // This function is no longer used, kept for backwards compatibility
        }

        let currentWatchlistFilter = 'all'; // 'all', 'movie', 'tv'
        let isShowingSpecificList = false; // Track if a specific watchlist is selected

        function displayWatchlistInResults() {
            const watchlistDisplay = document.getElementById('watchlistDisplay');
            const listNames = Object.keys(watchlists);

            if (listNames.length === 0 || !watchlists[currentWatchlistName]) {
                currentWatchlistName = listNames[0] || 'My Watchlist';
            }

            const currentList = watchlists[currentWatchlistName] || [];

            // Watchlist selector
            const watchlistSelector = `
                <div style="grid-column: 1 / -1; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 16px;">
                        ${listNames.map(listName => `
                            <button onclick="switchWatchlist('${listName.replace(/'/g, "\\'")}')"
                                    class="btn ${(isShowingSpecificList && currentWatchlistName === listName) ? '' : 'btn-secondary'}"
                                    style="padding: 12px 24px;">
                                ${listName} (${watchlists[listName].length})
                            </button>
                        `).join('')}
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="showManageWatchlistsModal()" class="btn btn-secondary" style="padding: 8px 16px; font-size: 14px;">
                            Manage Lists
                        </button>
                    </div>
                </div>
            `;

            // Get items based on whether a specific list is selected
            let allItems = [];
            if (isShowingSpecificList) {
                // Show only items from the selected watchlist
                allItems = currentList;
            } else {
                // Get all items from all lists (removing duplicates by id+type)
                const seenItems = new Set();
                listNames.forEach(listName => {
                    watchlists[listName].forEach(item => {
                        const key = `${item.id}_${item.type}`;
                        if (!seenItems.has(key)) {
                            seenItems.add(key);
                            allItems.push(item);
                        }
                    });
                });
            }

            // Filter based on current filter
            let filteredWatchlist = allItems;
            if (currentWatchlistFilter === 'movie') {
                filteredWatchlist = allItems.filter(item => item.type === 'movie');
            } else if (currentWatchlistFilter === 'tv') {
                filteredWatchlist = allItems.filter(item => item.type === 'tv');
            }

            if (filteredWatchlist.length === 0) {
                watchlistDisplay.innerHTML = watchlistSelector + `
                    <div style="text-align: center; color: #666; padding: 40px; grid-column: 1 / -1;">
                        <h3>No ${currentWatchlistFilter === 'movie' ? 'movies' : currentWatchlistFilter === 'tv' ? 'TV shows' : 'items'} found</h3>
                        <p>Add ${currentWatchlistFilter === 'movie' ? 'movies' : currentWatchlistFilter === 'tv' ? 'TV shows' : 'content'} to your watchlists</p>
                    </div>
                `;
                return;
            }

            const filterButtons = `
                <div style="grid-column: 1 / -1; margin-bottom: 20px; display: flex; gap: 10px; justify-content: center;">
                    <button onclick="filterWatchlist('all')" class="btn ${(!isShowingSpecificList && currentWatchlistFilter === 'all') ? '' : 'btn-secondary'}" style="padding: 12px 24px;">All</button>
                    <button onclick="filterWatchlist('movie')" class="btn ${(!isShowingSpecificList && currentWatchlistFilter === 'movie') ? '' : 'btn-secondary'}" style="padding: 12px 24px;">Movies</button>
                    <button onclick="filterWatchlist('tv')" class="btn ${(!isShowingSpecificList && currentWatchlistFilter === 'tv') ? '' : 'btn-secondary'}" style="padding: 12px 24px;">TV Shows</button>
                </div>
            `;

            const items = filteredWatchlist.map(item => {
                return `
                    <div class="continue-item content-card" data-id="${item.id}" data-type="${item.type}" onclick="playContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}')">
                        <button class="watchlist-remove-btn" onclick="event.stopPropagation(); removeFromSpecificWatchlist('${currentWatchlistName.replace(/'/g, "\\'")}', ${item.id}, '${item.type}')" title="Remove from Watchlist"></button>
                        <div class="continue-episode-badge">${item.type === 'tv' ? 'TV' : 'MOVIE'}</div>
                        <img src="${item.posterUrl}" alt="${item.title}" class="continue-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="continue-info">
                            <div class="continue-title">${item.title}</div>
                            <div class="continue-progress">${item.year}</div>
                            <div class="continue-last-watched"> ${item.rating}/10</div>
                        </div>
                    </div>
                `;
            }).join('');

            watchlistDisplay.innerHTML = watchlistSelector + filterButtons + items;
        }

        function switchWatchlist(listName) {
            currentWatchlistName = listName;
            isShowingSpecificList = true; // Show only this specific list
            currentWatchlistFilter = 'all'; // Reset filter
            localStorage.setItem('streamingSite_currentWatchlist', listName);
            displayWatchlistInResults();
        }

        function showManageWatchlistsModal() {
            const modal = document.getElementById('watchlistModal');
            const content = document.getElementById('watchlistModalContent');

            if (!modal || !content) {
                console.error('Watchlist modal elements not found');
                return;
            }

            const listNames = Object.keys(watchlists);

            content.innerHTML = `
                <div style="margin-bottom: 16px; color: #a1a1a6; font-size: 14px;">
                    Manage your watchlists:
                </div>
                <div style="display: grid; gap: 12px;">
                    ${listNames.map(listName => `
                        <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(58, 58, 60, 0.12); border-radius: 12px;">
                            <span style="flex: 1; color: #f5f5f7; font-weight: 500;">${listName}</span>
                            <span style="color: #a1a1a6; font-size: 14px;">${watchlists[listName].length} items</span>
                            ${listName !== 'My Watchlist' ? `
                                <button onclick="deleteWatchlist('${listName.replace(/'/g, "\\'")}')"
                                        class="btn btn-secondary"
                                        style="padding: 6px 12px; font-size: 13px; background: rgba(255, 59, 48, 0.15); border-color: rgba(255, 59, 48, 0.3); color: white;">
                                    Delete
                                </button>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
            `;

            modal.style.display = 'flex';
        }

        function deleteWatchlist(listName) {
            if (confirm(`Are you sure you want to delete "${listName}"? This will remove all ${watchlists[listName].length} items in it.`)) {
                delete watchlists[listName];
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

                // Switch to first available watchlist
                const remaining = Object.keys(watchlists);
                if (remaining.length > 0) {
                    switchWatchlist(remaining[0]);
                }

                // showStatus(`Deleted watchlist: ${listName}`);
                closeWatchlistModal();
                displayWatchlistInResults();
            }
        }

        function filterWatchlist(filter) {
            currentWatchlistFilter = filter;
            isShowingSpecificList = false; // Show all lists when using filter
            displayWatchlistInResults();
        }

        // Statistics Dashboard
        function resetAllStats() {
            if (confirm('Are you sure you want to reset all viewing statistics? This will clear your watch history but keep your watchlists. This action cannot be undone.')) {
                watchHistory = [];
                localStorage.setItem('streamingSite_watchHistory', JSON.stringify(watchHistory));
                // showStatus('All viewing statistics have been reset');
                displayStatistics();
            }
        }

        function displayStatistics() {
            const statsDisplay = document.getElementById('statisticsDisplay');

            // Calculate statistics
            const totalMovies = watchHistory.filter(item => item.type === 'movie').length;
            const totalTV = watchHistory.filter(item => item.type === 'tv').length;
            const totalWatchlist = Object.values(watchlists).reduce((sum, list) => sum + list.length, 0);

            // Calculate viewing patterns
            const movieProgress = watchHistory.filter(item => item.type === 'movie' && item.progress > 0);
            const tvProgress = watchHistory.filter(item => item.type === 'tv' && item.progress > 0);

            // Recent activity (last 7 days)
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
            const recentItems = watchHistory.filter(item =>
                new Date(item.lastWatched) > oneWeekAgo
            );

            // Top rated from watch history
            const topRated = [...watchHistory]
                .sort((a, b) => (parseFloat(b.rating) || 0) - (parseFloat(a.rating) || 0))
                .slice(0, 5);

            // Most watched (highest progress)
            const mostWatched = [...watchHistory]
                .sort((a, b) => (b.progress || 0) - (a.progress || 0))
                .slice(0, 5);

            statsDisplay.innerHTML = `
                <div style="max-width: 1200px; margin: 0 auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                        <h2 style="font-size: 2.5rem; font-weight: 600; margin: 0; background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                            Your Viewing Statistics
                        </h2>
                        <button onclick="resetAllStats()" class="btn btn-secondary" style="padding: 12px 24px; background: rgba(255, 59, 48, 0.2); border: 1px solid rgba(255, 59, 48, 0.4);">
                            Reset All Stats
                        </button>
                    </div>

                    <!-- Overview Cards -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 40px;">
                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">Total Movies Watched</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #007AFF, #5856D6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${totalMovies}
                            </div>
                        </div>

                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">Total TV Shows Watched</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #5856D6, #AF52DE); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${totalTV}
                            </div>
                        </div>

                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">In Your Watchlist</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #AF52DE, #FF2D55); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${totalWatchlist}
                            </div>
                        </div>

                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">Recent Activity (7 days)</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #FF2D55, #FF9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${recentItems.length}
                            </div>
                        </div>
                    </div>

                    <!-- Charts Section -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 24px; margin-bottom: 40px;">
                        <!-- Movie vs TV Distribution -->
                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;">Content Distribution</h3>
                            <div style="display: flex; align-items: center; justify-content: center; gap: 40px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 48px; font-weight: 700; color: #007AFF;">${totalMovies > 0 ? Math.round((totalMovies / (totalMovies + totalTV)) * 100) : 0}%</div>
                                    <div style="color: #a1a1a6; margin-top: 8px;">Movies</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 48px; font-weight: 700; color: #5856D6;">${totalTV > 0 ? Math.round((totalTV / (totalMovies + totalTV)) * 100) : 0}%</div>
                                    <div style="color: #a1a1a6; margin-top: 8px;">TV Shows</div>
                                </div>
                            </div>
                        </div>

                        <!-- Completion Rate -->
                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;">Average Progress</h3>
                            <div style="text-align: center;">
                                <div style="font-size: 56px; font-weight: 700; background: linear-gradient(135deg, #34C759, #30D158); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                    ${watchHistory.length > 0 ? Math.round(watchHistory.reduce((sum, item) => sum + (item.progress || 0), 0) / watchHistory.length) : 0}%
                                </div>
                                <div style="color: #a1a1a6; margin-top: 8px;">Overall Completion Rate</div>
                            </div>
                        </div>
                    </div>

                    <!-- Top Rated -->
                    <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 24px;">
                        <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;"> Top Rated Content You've Watched</h3>
                        <div style="display: grid; gap: 12px;">
                            ${topRated.length > 0 ? topRated.map((item, index) => `
                                <div style="display: flex; align-items: center; gap: 15px; padding: 12px; background: rgba(58, 58, 60, 0.12); border-radius: 12px; cursor: pointer;" onclick="playContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}')">
                                    <div style="font-size: 20px; font-weight: 700; color: #FFD60A; min-width: 30px;">#${index + 1}</div>
                                    <img src="${item.posterUrl}" style="width: 50px; height: 75px; object-fit: cover; border-radius: 8px;" onerror="this.src='https://via.placeholder.com/50x75/333/fff?text=?'">
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; color: #f5f5f7;">${item.title}</div>
                                        <div style="font-size: 14px; color: #a1a1a6;">${item.type.toUpperCase()}  ${item.year}</div>
                                    </div>
                                    <div style="font-size: 18px; font-weight: 700; color: #FFD60A;"> ${item.rating}</div>
                                </div>
                            `).join('') : '<div style="text-align: center; color: #666; padding: 20px;">No rated content yet</div>'}
                        </div>
                    </div>

                    <!-- Most Watched -->
                    <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                        <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;"> Most Progress Made</h3>
                        <div style="display: grid; gap: 12px;">
                            ${mostWatched.length > 0 ? mostWatched.map((item, index) => `
                                <div style="display: flex; align-items: center; gap: 15px; padding: 12px; background: rgba(58, 58, 60, 0.12); border-radius: 12px; cursor: pointer;" onclick="playContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}')">
                                    <div style="font-size: 20px; font-weight: 700; color: #007AFF; min-width: 30px;">#${index + 1}</div>
                                    <img src="${item.posterUrl}" style="width: 50px; height: 75px; object-fit: cover; border-radius: 8px;" onerror="this.src='https://via.placeholder.com/50x75/333/fff?text=?'">
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; color: #f5f5f7;">${item.title}</div>
                                        <div style="font-size: 14px; color: #a1a1a6;">${item.type.toUpperCase()}  ${item.year}</div>
                                    </div>
                                    <div style="min-width: 80px;">
                                        <div style="height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="height: 100%; width: ${Math.round(item.progress)}%; background: linear-gradient(90deg, #007AFF, #5856D6);"></div>
                                        </div>
                                        <div style="font-size: 12px; color: #a1a1a6; margin-top: 4px; text-align: center;">${Math.round(item.progress)}%</div>
                                    </div>
                                </div>
                            `).join('') : '<div style="text-align: center; color: #666; padding: 20px;">No viewing progress yet</div>'}
                        </div>
                    </div>
                </div>
            `;
        }

        function removeFromWatchlist(id, type) {
            const index = watchlist.findIndex(item => item.id === id && item.type === type);
            if (index > -1) {
                const item = watchlist[index];
                watchlist.splice(index, 1);
                localStorage.setItem('streamingSite_watchlist', JSON.stringify(watchlist));
                displayWatchlistInResults();
            }
        }

        // Watch history functionality
        async function addToWatchHistory(id, title, type, data, season = null, episode = null) {
            console.log('[addToWatchHistory] Called:', { id, title, type, authToken: authToken ? 'exists' : 'null' });

            // For TV shows, get the current season/episode from selectors if not provided
            let currentSeason = season;
            let currentEpisode = episode;

            if (type === 'tv' && (!currentSeason || !currentEpisode)) {
                const seasonSelect = document.getElementById('seasonSelect');
                const episodeSelect = document.getElementById('episodeSelect');
                if (seasonSelect && episodeSelect) {
                    currentSeason = parseInt(seasonSelect.value) || 1;
                    currentEpisode = parseInt(episodeSelect.value) || 1;
                } else {
                    currentSeason = 1;
                    currentEpisode = 1;
                }
            }

            const posterUrl = data.poster_url || 'https://via.placeholder.com/60x90/333/fff?text=No+Poster';

            // Require authentication - no localStorage fallback
            if (!authToken) {
                console.log('[addToWatchHistory] No auth, continue watching disabled');
                return;
            }

            // Save to database only
            console.log('[addToWatchHistory] Calling API to save to DB');
            try {
                await updateContinueWatchingAPI(id, type, title, posterUrl, 0, currentSeason, currentEpisode);
                console.log('[addToWatchHistory] Saved to DB successfully');
                // Reload from database to keep data in sync
                await loadContinueWatching();
            } catch (error) {
                console.error('[addToWatchHistory] Failed to save to DB:', error);
            }
        }

        function updateContinueWatching() {
            // This function is no longer used, kept for backwards compatibility
        }

        function displayContinueWatchingInResults() {
            const continueWatchingDisplay = document.getElementById('continueWatchingDisplay');

            // Only display if continue-watching tab is active
            if (currentTab !== 'continue-watching') {
                return; // Data is loaded but not displayed until tab is clicked
            }

            // Filter out items with >90% progress and sort by most recently watched
            const filteredHistory = watchHistory
                .filter(item => item.progress < 90)
                .sort((a, b) => new Date(b.lastWatched) - new Date(a.lastWatched));

            if (filteredHistory.length === 0) {
                continueWatchingDisplay.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px; grid-column: 1 / -1;">
                        <h3>No items in Continue Watching</h3>
                        <p>Login & Start watching movies and TV shows to see them here</p>
                    </div>
                `;
                return;
            }

            continueWatchingDisplay.innerHTML = filteredHistory.map(item => {
                return `
                    <div class="continue-item content-card" data-id="${item.id}" data-type="${item.type}" onclick="resumeContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}', ${item.season || 1}, ${item.episode || 1}, ${item.progress || 0})">
                        <button class="watchlist-remove-btn" onclick="event.stopPropagation(); removeFromHistory(${item.id}, '${item.type}')" title="Remove from Continue Watching"></button>
                        ${item.type === 'tv' ? `<div class="continue-episode-badge">S${item.season}E${item.episode}</div>` : ''}
                        <img src="${item.posterUrl}" alt="${item.title}" class="continue-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="continue-info">
                            <div class="continue-title">${item.title}</div>
                            <div class="continue-progress">${item.type.toUpperCase()}  ${item.year}</div>
                            <div class="continue-last-watched">Watched ${new Date(item.lastWatched).toLocaleDateString()}</div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${item.progress}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function removeFromHistory(id, type) {
            // Require authentication
            if (!authToken) {
                showError('Please login to manage watch history');
                return;
            }

            try {
                // Remove from database
                await apiRequest(`/continue-watching/${id}`, {
                    method: 'DELETE'
                });

                // Reload from database
                await loadContinueWatching();
            } catch (error) {
                console.error('Failed to remove from continue watching:', error);
                showError('Failed to remove from continue watching');
            }
        }

        async function resumeContent(id, title, type, season, episode, progress) {
            hideError();

            // Scroll to player section immediately
            const playerSection = document.querySelector('.player-section');
            if (playerSection) {
                playerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            try {
                currentContentId = id;
                currentContentType = type;

                let endpoint;
                if (type === 'tv') {
                    endpoint = `${API_BASE_URL}/tv/${id}`;
                } else {
                    endpoint = `${API_BASE_URL}/movie/${id}`;
                }

                const response = await fetch(endpoint);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                currentContentData = data;

                // Update current content display
                const currentContent = document.getElementById('currentContent');
                const tvControls = document.getElementById('tvControls');

                const titleEl = document.getElementById('currentTitle');
                const yearEl = document.getElementById('currentYear');
                const ratingEl = document.getElementById('currentRating');
                const overviewEl = document.getElementById('currentOverview');

                if (titleEl) titleEl.textContent = type === 'tv' ? data.name : data.title;
                if (yearEl) yearEl.textContent = type === 'tv' ?
                    (data.first_air_date ? data.first_air_date.substring(0, 4) : 'Unknown') :
                    (data.release_date ? data.release_date.substring(0, 4) : 'Unknown');
                if (ratingEl) ratingEl.textContent = ` ${data.vote_average ? data.vote_average.toFixed(1) : 'N/A'}/10`;
                if (overviewEl) overviewEl.textContent = data.overview || 'No description available';

                const posterEl = document.getElementById('currentPoster');
                if (posterEl) {
                    if (data.poster_url) {
                        posterEl.src = data.poster_url;
                        posterEl.style.display = 'block';
                    } else {
                        posterEl.style.display = 'none';
                    }
                }

                // Load backdrop image
                const backdropEl = document.getElementById('backdropImage');
                console.log('Resume - Backdrop element:', backdropEl);
                console.log('Resume - Backdrop URL:', data.backdrop_url);
                if (backdropEl && data.backdrop_url) {
                    backdropEl.style.backgroundImage = `url(${data.backdrop_url})`;
                    backdropEl.classList.add('loaded');
                    console.log('Resume - Backdrop loaded:', backdropEl.style.backgroundImage);
                } else if (backdropEl) {
                    backdropEl.style.backgroundImage = '';
                    backdropEl.classList.remove('loaded');
                    console.log('Resume - Backdrop cleared or not available');
                }

                // Populate OMDB data if available
                const omdbRatingsEl = document.getElementById('omdbRatings');
                const omdbDetailsEl = document.getElementById('omdbDetails');

                if (omdbRatingsEl && data.omdb_ratings && data.omdb_ratings.length > 0) {
                    const imdbRating = data.omdb_imdb_rating || 'N/A';
                    let rtRating = 'N/A';
                    let metacriticRating = 'N/A';

                    data.omdb_ratings.forEach(rating => {
                        if (rating.Source === 'Rotten Tomatoes') {
                            rtRating = rating.Value;
                        } else if (rating.Source === 'Metacritic') {
                            metacriticRating = rating.Value;
                        }
                    });

                    const imdbEl = document.getElementById('imdbRating');
                    const rtEl = document.getElementById('rtRating');
                    const metacriticEl = document.getElementById('metacriticRating');

                    if (imdbEl) imdbEl.textContent = imdbRating;
                    if (rtEl) rtEl.textContent = rtRating;
                    if (metacriticEl) metacriticEl.textContent = metacriticRating;
                    omdbRatingsEl.style.display = 'flex';
                } else if (omdbRatingsEl) {
                    omdbRatingsEl.style.display = 'none';
                }

                // Populate OMDB details if available
                if (omdbDetailsEl && (currentContentData.tmdb_cast || currentContentData.omdb_actors || currentContentData.omdb_director || currentContentData.omdb_genre || currentContentData.omdb_rated || currentContentData.omdb_runtime || currentContentData.omdb_awards)) {
                    const actorsEl = document.getElementById('omdbActors');
                    const castSection = document.getElementById('castSection');
                    const castGrid = document.getElementById('castGrid');
                    const directorEl = document.getElementById('omdbDirector');
                    const genreEl = document.getElementById('omdbGenre');
                    const ratedEl = document.getElementById('omdbRated');
                    const runtimeEl = document.getElementById('omdbRuntime');
                    const awardsEl = document.getElementById('omdbAwards');

                    // Display TMDB cast with images if available
                    if (castSection && castGrid && currentContentData.tmdb_cast && currentContentData.tmdb_cast.length > 0) {
                        castGrid.innerHTML = '';
                        currentContentData.tmdb_cast.forEach(actor => {
                            const castMember = document.createElement('div');
                            castMember.className = 'cast-member';

                            if (actor.profile_url) {
                                const img = document.createElement('img');
                                img.src = actor.profile_url;
                                img.alt = actor.name;
                                img.className = 'cast-member-image';
                                castMember.appendChild(img);
                            } else {
                                const placeholder = document.createElement('div');
                                placeholder.className = 'cast-member-image placeholder';
                                placeholder.textContent = actor.name.charAt(0);
                                castMember.appendChild(placeholder);
                            }

                            const nameDiv = document.createElement('div');
                            nameDiv.className = 'cast-member-name';
                            nameDiv.textContent = actor.name;
                            nameDiv.title = actor.name;
                            castMember.appendChild(nameDiv);

                            if (actor.character) {
                                const characterDiv = document.createElement('div');
                                characterDiv.className = 'cast-member-character';
                                characterDiv.textContent = actor.character;
                                characterDiv.title = actor.character;
                                castMember.appendChild(characterDiv);
                            }

                            castGrid.appendChild(castMember);
                        });
                        castSection.style.display = 'block';
                        actorsEl.style.display = 'none';
                    } else if (actorsEl && currentContentData.omdb_actors) {
                        // Fallback to OMDB text if no TMDB cast
                        const span = actorsEl.querySelector('span');
                        if (span) span.textContent = currentContentData.omdb_actors;
                        actorsEl.style.display = 'block';
                        if (castSection) castSection.style.display = 'none';
                    } else {
                        if (actorsEl) actorsEl.style.display = 'none';
                        if (castSection) castSection.style.display = 'none';
                    }

                    if (directorEl) {
                        if (currentContentData.omdb_director && currentContentData.omdb_director !== 'N/A') {
                            const span = directorEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_director;
                            directorEl.style.display = 'block';
                        } else {
                            directorEl.style.display = 'none';
                        }
                    }

                    if (genreEl) {
                        if (currentContentData.omdb_genre) {
                            const span = genreEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_genre;
                            genreEl.style.display = 'block';
                        } else {
                            genreEl.style.display = 'none';
                        }
                    }

                    if (ratedEl) {
                        if (currentContentData.omdb_rated && currentContentData.omdb_rated !== 'N/A') {
                            const span = ratedEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_rated;
                            ratedEl.style.display = 'block';
                        } else {
                            ratedEl.style.display = 'none';
                        }
                    }

                    if (runtimeEl) {
                        if (currentContentData.omdb_runtime) {
                            const span = runtimeEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_runtime;
                            runtimeEl.style.display = 'block';
                        } else {
                            runtimeEl.style.display = 'none';
                        }
                    }

                    if (awardsEl) {
                        if (currentContentData.omdb_awards && currentContentData.omdb_awards !== 'N/A') {
                            const span = awardsEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_awards;
                            awardsEl.style.display = 'block';
                        } else {
                            awardsEl.style.display = 'none';
                        }
                    }

                    omdbDetailsEl.style.display = 'block';
                } else if (omdbDetailsEl) {
                    omdbDetailsEl.style.display = 'none';
                }

                currentContent.style.display = 'flex';

                // Initialize player background effects
                // initPlayerBackgroundEffects();

                // Show the player section
                document.getElementById('playerSection').style.display = 'block';

                if (type === 'tv') {
                    // Setup TV show controls and set to last watched episode
                    tvControls.style.display = 'block';
                    await setupSeasonEpisodeSelectors(data);

                    // Set the current season and episode to the last watched
                    currentSelectedSeason = season;
                    currentSelectedEpisode = episode;
                    document.getElementById('seasonButtonText').textContent = `Season ${season}`;
                    await updateEpisodeSelector(season);
                    document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(episode, season);

                    playTVEpisode(id, season, episode, progress);
                } else {
                    // Play movie
                    tvControls.style.display = 'none';
                    playMovie(id, progress);
                }

                // Update watch history with current time
                updateWatchHistoryItem(id, title, type, data, season, episode, progress);

                // Update player watchlist button
                updatePlayerWatchlistButton(id, type);

                // Update video source button
                updateVideoSourceButton();

            } catch (error) {
                console.error('Resume content error:', error);
                showError(`Failed to resume content: ${error.message}`);
            }
        }

        async function updateWatchHistoryItem(id, title, type, data, season, episode, progress) {
            const historyItem = {
                id: id,
                title: title,
                type: type,
                posterUrl: data.poster_url || 'https://via.placeholder.com/60x90/333/fff?text=No+Poster',
                year: type === 'tv' ?
                    (data.first_air_date ? data.first_air_date.substring(0, 4) : 'Unknown') :
                    (data.release_date ? data.release_date.substring(0, 4) : 'Unknown'),
                rating: data.vote_average ? data.vote_average.toFixed(1) : 'N/A',
                lastWatched: new Date().toISOString(),
                progress: progress || 0,
                season: season || 1,
                episode: episode || 1
            };

            // If user is logged in, use API
            if (authToken) {
                try {
                    await updateContinueWatchingAPI(
                        id,
                        type,
                        title,
                        historyItem.posterUrl,
                        progress,
                        season,
                        episode
                    );
                    // Reload from database to keep data in sync
                    await loadContinueWatching();
                } catch (error) {
                    console.error('Failed to update continue watching:', error);
                }
            } else {
                // Fallback to localStorage for non-authenticated users
                const existingIndex = watchHistory.findIndex(item => item.id === id && item.type === type);
                if (existingIndex > -1) {
                    watchHistory[existingIndex] = historyItem;
                } else {
                    watchHistory.unshift(historyItem);
                    watchHistory = watchHistory.slice(0, 20);
                }
                localStorage.setItem('streamingSite_watchHistory', JSON.stringify(watchHistory));
                updateContinueWatching();
            }
        }

        // Auto-hide status messages after 5 seconds
        setInterval(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar.style.display === 'block') {
                setTimeout(() => hideStatus(), 5000);
            }
        }, 1000);

        // Subtitle functionality
        let currentSubtitles = [];
        let activeSubtitleUrl = null;

        async function loadSubtitles() {
            if (!currentContentId || !currentContentData) {
                showError('Please load a movie or TV show first');
                return;
            }

            // Show subtitle modal
            document.getElementById('subtitleModal').style.display = 'block';

            // Get language selection
            const language = document.getElementById('subtitleLanguage').value;

            // Build request parameters
            const params = new URLSearchParams({
                tmdb_id: currentContentId,
                type: currentContentType,
                language: language
            });

            if (currentContentType === 'tv') {
                const season = document.getElementById('seasonSelect')?.value || 1;
                const episode = document.getElementById('episodeSelect')?.value || 1;
                params.append('season', season);
                params.append('episode', episode);
            }

            try {

                const response = await fetch(`${API_BASE_URL}/subtitles/search?${params}`);
                const data = await response.json();

                currentSubtitles = data.subtitles || [];

                if (currentSubtitles.length === 0) {
                    document.getElementById('subtitleList').innerHTML = `
                        <div style="text-align: center; color: #666; padding: 40px;">
                            <h3>No subtitles found</h3>
                            <p>Try a different language or paste a custom subtitle URL below</p>
                        </div>
                    `;
                } else {
                    displaySubtitleList(currentSubtitles);
                    // showStatus(`Found ${currentSubtitles.length} subtitles`);
                }

            } catch (error) {
                console.error('Subtitle search error:', error);
                showError('Failed to search for subtitles');
                document.getElementById('subtitleList').innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px;">
                        <h3>Error loading subtitles</h3>
                        <p>Please try again or paste a custom subtitle URL below</p>
                    </div>
                `;
            }
        }

        function displaySubtitleList(subtitles) {
            const listDiv = document.getElementById('subtitleList');

            listDiv.innerHTML = subtitles.map((sub, index) => {
                const downloads = parseInt(sub.SubDownloadsCnt || 0);
                const rating = parseFloat(sub.SubRating || 0);
                const fileName = sub.SubFileName || 'Unknown';
                const downloadUrl = sub.SubDownloadLink || sub.ZipDownloadLink;
                const isSearchPage = sub.IsSearchPage === true;
                const source = sub.Source || 'Unknown';

                const buttonText = isSearchPage ? 'Open Search' : 'Load';
                const buttonAction = isSearchPage ? `openSubtitleSearch('${downloadUrl}', '${source}')` : `selectSubtitle('${downloadUrl}')`;

                return `
                    <div style="background: rgba(58, 58, 60, 0.12); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 16px; margin-bottom: 12px; transition: all 0.3s;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #fff; margin-bottom: 4px;">
                                    ${fileName}
                                    ${isSearchPage ? '<span style="color: #007AFF; font-size: 11px; margin-left: 8px;"> Search Page</span>' : ''}
                                </div>
                                <div style="color: #888; font-size: 13px; margin-bottom: 4px;">
                                    Source: ${source} | Downloads: ${downloads.toLocaleString()} | Rating: ${''.repeat(Math.round(rating))}
                                </div>
                                ${isSearchPage ? '<div style="color: #666; font-size: 12px; font-style: italic;">Opens search page - download manually</div>' : ''}
                            </div>
                            <button class="btn" style="padding: 8px 16px; margin-left: 12px;" onclick="event.stopPropagation(); ${buttonAction}">
                                ${buttonText}
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function openSubtitleSearch(url, source) {
            // Open the search page in a new tab
            window.open(url, '_blank');
            showStatus(`Opened ${source} search page. Download subtitle and paste URL below.`);
        }

        async function selectSubtitle(downloadUrl) {
            try {
                showStatus('Processing subtitle...');

                // Use our proxy endpoint to handle CORS and format conversion
                const proxyUrl = `${API_BASE_URL}/subtitles/proxy?url=${encodeURIComponent(downloadUrl)}`;

                // Test if subtitle is accessible
                try {
                    const testResponse = await fetch(proxyUrl);
                    if (!testResponse.ok) {
                        throw new Error('Subtitle not accessible');
                    }
                } catch (err) {
                    showError('Could not load subtitle from that URL. Try a different one or use a direct .srt/.vtt link.');
                    return;
                }

                activeSubtitleUrl = proxyUrl;

                // Store subtitle preference
                localStorage.setItem('lastSubtitleUrl', downloadUrl);

                // Show success message with download option
                const modalContent = document.querySelector('#subtitleModal > div');
                modalContent.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 64px; margin-bottom: 20px;"></div>
                        <h2 style="color: #fff; margin-bottom: 16px;">Subtitle Ready!</h2>
                        <p style="color: #a1a1a6; margin-bottom: 32px;">Due to browser security, subtitles can't display in embedded players.<br/>Here are your options:</p>

                        <div style="background: rgba(58, 58, 60, 0.12); border-radius: 12px; padding: 24px; margin-bottom: 20px; text-align: left;">
                            <h3 style="color: #007AFF; margin-bottom: 16px;">Option 1: Download Subtitle File</h3>
                            <p style="color: #ccc; margin-bottom: 16px; font-size: 14px;">Download and add manually to your video player</p>
                            <a href="${proxyUrl}" download="subtitle.vtt" class="btn" style="display: inline-block; margin-bottom: 8px;">
                                 Download Subtitle File
                            </a>
                            <p style="color: #666; font-size: 12px; margin-top: 8px;">Use with VLC, MPV, or any video player</p>
                        </div>

                        <div style="background: rgba(58, 58, 60, 0.12); border-radius: 12px; padding: 24px; margin-bottom: 20px; text-align: left;">
                            <h3 style="color: #007AFF; margin-bottom: 16px;">Option 2: Copy Subtitle URL</h3>
                            <input type="text" value="${proxyUrl}" readonly
                                   style="width: 100%; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px; margin-bottom: 12px;"
                                   onclick="this.select()">
                            <button onclick="navigator.clipboard.writeText('${proxyUrl}'); showStatus('Copied to clipboard!');" class="btn btn-secondary">
                                Copy URL
                            </button>
                            <p style="color: #666; font-size: 12px; margin-top: 8px;">Paste in VLC, MPV, or HTML5 video player</p>
                        </div>

                        <div style="background: rgba(58, 58, 60, 0.12); border-radius: 12px; padding: 24px; margin-bottom: 32px; text-align: left;">
                            <h3 style="color: #007AFF; margin-bottom: 16px;">Option 3: Use with External Player</h3>
                            <p style="color: #ccc; margin-bottom: 16px; font-size: 14px;">
                                1. Click "Copy URL" to copy the video URL<br/>
                                2. Open the URL in your external player along with the subtitle URL above
                            </p>
                        </div>

                        <button onclick="closeSubtitleModal(); location.reload();" class="btn" style="margin-right: 10px;">
                             Back to Subtitles
                        </button>
                        <button onclick="closeSubtitleModal();" class="btn btn-secondary">
                            Close
                        </button>
                    </div>
                `;

                showStatus(' Subtitle processed and ready!');
                console.log('Subtitle VTT URL:', proxyUrl);

            } catch (error) {
                console.error('Subtitle load error:', error);
                showError('Failed to load subtitle. Make sure it\'s a direct download link (.srt or .vtt file).');
            }
        }

        async function loadCustomSubtitle() {
            const url = document.getElementById('customSubtitleUrl').value.trim();

            if (!url) {
                showError('Please enter a subtitle URL');
                return;
            }

            try {
                // Validate URL
                new URL(url);

                // Use proxy to load it
                await selectSubtitle(url);

            } catch (error) {
                showError('Invalid URL');
            }
        }

        function closeSubtitleModal() {
            document.getElementById('subtitleModal').style.display = 'none';
        }

        // Close modal when clicking outside
        document.getElementById('subtitleModal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeSubtitleModal();
            }
        });

        // Open video with subtitle player
        function openWithSubtitles() {
            if (!currentContentUrl) {
                showError('Please load a movie or TV show first');
                return;
            }

            const subtitlePlayerUrl = `/video_player_with_subtitles.html?video=${encodeURIComponent(currentContentUrl)}`;
            window.open(subtitlePlayerUrl, '_blank', 'width=1280,height=720');
            showStatus(' Opened subtitle player! Click " Get Subtitles" to find subtitles, then paste the URL in the new window.');
        }

        // ============= WATCHPARTY FUNCTIONS =============

        let serverUrl = window.location.origin;

        async function initSocket() {
            if (socket && socket.connected) return socket;

            // Use the current page's origin for Socket.IO connection
            // This works for both localhost and ngrok
            serverUrl = window.location.origin;
            console.log('Connecting Socket.IO to:', serverUrl);

            socket = io(serverUrl, {
                path: '/socket.io/',
                transports: ['polling', 'websocket'],
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5,
                timeout: 10000
            });

            // Wait for connection
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.error('Socket connection timeout after 10s');
                    reject(new Error('Socket connection timeout'));
                }, 10000);

                socket.on('connect', () => {
                    clearTimeout(timeout);
                    console.log('Socket connected successfully, ID:', socket.id);
                    setupSocketListeners();
                    resolve(socket);
                });

                socket.on('connect_error', (error) => {
                    clearTimeout(timeout);
                    console.error('Socket connection error:', error);
                    reject(error);
                });
            });
        }

        function setupSocketListeners() {

            socket.on('connected', (data) => {
                console.log('Socket connected:', data.sid);
            });

            socket.on('party_created', (data) => {
                watchpartyActive = true;
                watchpartyRoomCode = data.room_code;
                isHost = true;
                watchpartyUsers = data.users;
                showWatchpartySidebar();
                updateWatchpartyUI(data);
                closeWatchpartyMenu();
                // showStatus(`Watchparty created! Room code: ${data.room_code}`);

                // Re-setup video sync listeners for already-playing content
                const playerVideo = document.getElementById('playerVideo');
                if (playerVideo && playerVideo.style.display !== 'none') {
                    console.log('[Party Created] Re-attaching sync listeners to active video');
                    videoSyncListenersAttached = false; // Reset flag to allow re-attachment
                    setupVideoSyncListeners(playerVideo);
                } else {
                    console.log('[Party Created] No active video to attach sync listeners');
                }
            });

            socket.on('party_joined', (data) => {
                console.log('[Party Joined] Received data:', data);

                watchpartyActive = true;
                watchpartyRoomCode = data.room_code;
                isHost = data.is_host;
                watchpartyUsers = data.users;
                showWatchpartySidebar();
                updateWatchpartyUI(data);
                closeWatchpartyMenu();
                // showStatus(`Joined watchparty: ${data.room_code}`);

                // Re-setup video sync listeners if joining as host
                if (isHost) {
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        console.log('[Party Joined as Host] Re-attaching sync listeners to active video');
                        videoSyncListenersAttached = false; // Reset flag to allow re-attachment
                        setupVideoSyncListeners(playerVideo);
                    } else {
                        console.log('[Party Joined as Host] No active video to attach sync listeners');
                    }
                }

                // Sync content if joining as guest
                console.log('[Party Joined] Is host:', isHost, 'Content:', data.content);
                if (!isHost && data.content && data.content.id) {
                    console.log('[Party Joined] Guest syncing content from host');
                    syncContentFromHost(data.content);
                } else if (!isHost) {
                    console.log('[Party Joined] No content to sync (host hasnt loaded anything yet)');
                }
            });

            socket.on('join_error', (data) => {
                showError(data.message || 'Failed to join watchparty');
            });

            socket.on('user_joined', (data) => {
                watchpartyUsers = data.users;
                updateUsersList(data.users);
                addSystemMessage(`${data.username} joined the party`);
            });

            socket.on('user_left', (data) => {
                watchpartyUsers = data.users;
                updateUsersList(data.users);
                addSystemMessage(`${data.username} left the party`);
            });

            socket.on('new_host', (data) => {
                isHost = (username === data.username);
                addSystemMessage(`${data.username} is now the host`);
                // showStatus(`${data.username} is now controlling playback`);

                // Re-setup video sync listeners if I'm the new host
                if (isHost) {
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        console.log('[New Host] Re-attaching sync listeners to active video');
                        videoSyncListenersAttached = false; // Reset flag to allow re-attachment
                        setupVideoSyncListeners(playerVideo);
                    } else {
                        console.log('[New Host] No active video to attach sync listeners');
                    }
                    showStatus('You are now the host! You control playback for all guests.');
                }
            });

            socket.on('play_sync', (data) => {
                if (!isHost) {
                    console.log('[Guest] Received play_sync from host:', data);
                    showSyncIndicator(`Host resumed playback at ${formatTime(data.currentTime)}`);

                    // Set syncing flag to prevent loop
                    isSyncing = true;

                    // Check if using video element (live channels OR movies/TV with direct streams) or iframe (movies/TV embeds)
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        // For direct streams: control video element (works for live channels AND movies/TV)
                        console.log('[Guest] Syncing video element play at', data.currentTime);
                        playerVideo.currentTime = data.currentTime;
                        playerVideo.play().catch(e => console.log('Play prevented:', e));
                    } else if (currentContentUrl && data.currentTime !== undefined) {
                        // For embed iframes: reload with timestamp (movies/TV only)
                        console.log('[Guest] Reloading iframe with timestamp', data.currentTime);
                        reloadPlayerWithTimestamp(data.currentTime);
                    }

                    // Reset flag after a delay
                    setTimeout(() => { isSyncing = false; }, 1000);
                }
            });

            socket.on('pause_sync', (data) => {
                if (!isHost) {
                    console.log('[Guest] Received pause_sync from host:', data);
                    showSyncIndicator(`Host paused at ${formatTime(data.currentTime)}`);

                    // Set syncing flag to prevent loop
                    isSyncing = true;

                    // Check if using video element (live channels OR movies/TV with direct streams) or iframe (movies/TV embeds)
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        // For direct streams: control video element (works for live channels AND movies/TV)
                        console.log('[Guest] Syncing video element pause at', data.currentTime);
                        playerVideo.currentTime = data.currentTime;
                        playerVideo.pause();
                    } else if (currentContentUrl && data.currentTime !== undefined) {
                        // For embed iframes: reload with timestamp (movies/TV only)
                        console.log('[Guest] Reloading iframe with timestamp', data.currentTime);
                        reloadPlayerWithTimestamp(data.currentTime);
                    }

                    // Reset flag after a delay
                    setTimeout(() => { isSyncing = false; }, 1000);
                }
            });

            socket.on('seek_sync', (data) => {
                if (!isHost) {
                    console.log('[Guest] Received seek_sync from host:', data);
                    showSyncIndicator(`Host seeked to ${formatTime(data.currentTime)}`);

                    // Set syncing flag to prevent loop
                    isSyncing = true;

                    // Check if using video element (live channels OR movies/TV with direct streams) or iframe (movies/TV embeds)
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        // For direct streams: control video element (works for live channels AND movies/TV)
                        console.log('[Guest] Syncing video element seek to', data.currentTime);
                        playerVideo.currentTime = data.currentTime;
                    } else if (currentContentUrl && data.currentTime !== undefined) {
                        // For embed iframes: reload with timestamp (movies/TV only)
                        console.log('[Guest] Reloading iframe with timestamp', data.currentTime);
                        reloadPlayerWithTimestamp(data.currentTime);
                    }

                    // Reset flag after a delay
                    setTimeout(() => { isSyncing = false; }, 1000);
                }
            });

            socket.on('content_sync', (data) => {
                if (!isHost && data.content) {
                    showSyncIndicator(`Host changed content`);
                    syncContentFromHost(data.content);
                }
            });

            socket.on('stop_sync', (data) => {
                if (!isHost) {
                    showSyncIndicator(`Host stopped playback`);
                    stopPlayback();
                }
            });

            socket.on('chat_message', (data) => {
                addChatMessage(data);
            });

            // ============= PLAYBACK SYNC LISTENERS =============

            socket.on('playback_play', (data) => {
                console.log('[Sync] Received playback_play from', data.username, 'at', data.currentTime);
                const playerVideo = document.getElementById('playerVideo');
                const playerIframe = document.getElementById('contentPlayer');

                isSyncing = true; // Prevent sync loop

                if (playerVideo && playerVideo.style.display !== 'none') {
                    // Direct video element
                    playerVideo.currentTime = data.currentTime;
                    playerVideo.play().catch(e => console.log('[Sync] Play prevented:', e));
                } else if (playerIframe && playerIframe.style.display !== 'none') {
                    // For iframes, try postMessage (works with some embeds)
                    try {
                        playerIframe.contentWindow.postMessage({
                            action: 'play',
                            currentTime: data.currentTime
                        }, '*');
                    } catch (e) {
                        console.log('[Sync] Cannot control iframe:', e);
                    }
                }

                showStatus(` ${data.username} played`);
                setTimeout(() => { isSyncing = false; }, 500);
            });

            socket.on('playback_pause', (data) => {
                console.log('[Sync] Received playback_pause from', data.username, 'at', data.currentTime);
                const playerVideo = document.getElementById('playerVideo');
                const playerIframe = document.getElementById('contentPlayer');

                isSyncing = true; // Prevent sync loop

                if (playerVideo && playerVideo.style.display !== 'none') {
                    // Direct video element
                    playerVideo.currentTime = data.currentTime;
                    playerVideo.pause();
                } else if (playerIframe && playerIframe.style.display !== 'none') {
                    // For iframes, try postMessage
                    try {
                        playerIframe.contentWindow.postMessage({
                            action: 'pause',
                            currentTime: data.currentTime
                        }, '*');
                    } catch (e) {
                        console.log('[Sync] Cannot control iframe:', e);
                    }
                }

                showStatus(` ${data.username} paused`);
                setTimeout(() => { isSyncing = false; }, 500);
            });

            socket.on('playback_seek', (data) => {
                console.log('[Sync] Received playback_seek from', data.username, 'to', data.currentTime);
                const playerVideo = document.getElementById('playerVideo');
                const playerIframe = document.getElementById('contentPlayer');

                isSyncing = true; // Prevent sync loop

                if (playerVideo && playerVideo.style.display !== 'none') {
                    // Direct video element
                    playerVideo.currentTime = data.currentTime;
                } else if (playerIframe && playerIframe.style.display !== 'none') {
                    // For iframes, try postMessage
                    try {
                        playerIframe.contentWindow.postMessage({
                            action: 'seek',
                            currentTime: data.currentTime
                        }, '*');
                    } catch (e) {
                        console.log('[Sync] Cannot control iframe:', e);
                    }
                }

                showStatus(` ${data.username} seeked`);
                setTimeout(() => { isSyncing = false; }, 500);
            });

            socket.on('sync_status', (data) => {
                const playerVideo = document.getElementById('playerVideo');

                if (playerVideo && playerVideo.style.display !== 'none' && !playerVideo.paused) {
                    const currentTime = playerVideo.currentTime;
                    const expectedTime = data.currentTime;
                    const drift = Math.abs(currentTime - expectedTime);

                    console.log('[Drift] Current:', currentTime.toFixed(1), 'Expected:', expectedTime.toFixed(1), 'Drift:', drift.toFixed(1) + 's');

                    // If drift is more than 2 seconds, auto-correct
                    if (drift > 2) {
                        console.log('[Drift]  Drift detected! Auto-correcting...');
                        isSyncing = true;
                        playerVideo.currentTime = expectedTime;
                        setTimeout(() => { isSyncing = false; }, 500);
                    }
                }
            });

            socket.on('party_left', () => {
                resetWatchparty();
            });

        }

        function showWatchpartyMenu() {
            // Set default username if not already set
            if (!username) {
                username = 'User' + Math.floor(Math.random() * 1000);
            }

            // Populate username input field
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.value = username;
            }

            initSocket();
            document.getElementById('watchpartyMenuModal').style.display = 'flex';
        }

        window.closeWatchpartyMenu = function() {
            document.getElementById('watchpartyMenuModal').style.display = 'none';
            // Also close the watchparty panel
            const panel = document.getElementById('watchpartyPanel');
            if (panel) {
                panel.classList.remove('active');
            }
        }

        window.createWatchparty = async function() {
            // Get username from input field
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput && usernameInput.value.trim()) {
                username = usernameInput.value.trim();
            }

            if (!username) {
                showError('Please enter a display name');
                return;
            }

            try {
                if (!socket || !socket.connected) {
                    await initSocket();
                }
            } catch (error) {
                showError('Unable to connect to server. Please try again.');
                return;
            }

            let contentData = null;

            // Include content data if available
            if (currentContentId) {
                contentData = {
                    id: currentContentId,
                    title: currentContentData?.title || currentContentData?.name || 'Unknown',
                    type: currentContentType,
                    posterUrl: currentContentData?.poster_url || '',
                    url: currentContentUrl
                };

                // Add season/episode for TV shows
                if (currentContentType === 'tv') {
                    const seasonSelect = document.getElementById('seasonSelect');
                    const episodeSelect = document.getElementById('episodeSelect');
                    if (seasonSelect && episodeSelect) {
                        contentData.season = parseInt(seasonSelect.value);
                        contentData.episode = parseInt(episodeSelect.value);
                    }
                }
            }

            socket.emit('create_party', {
                username: username,
                content: contentData
            });
        }

        window.joinWatchparty = async function() {
            // Get username from input field
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput && usernameInput.value.trim()) {
                username = usernameInput.value.trim();
            }

            if (!username) {
                showError('Please enter a display name');
                return;
            }

            const roomCode = document.getElementById('joinRoomCodeInput').value.trim().toUpperCase();

            if (!roomCode || roomCode.length !== 6) {
                showError('Please enter a valid 6-character room code');
                return;
            }

            try {
                if (!socket || !socket.connected) {
                    await initSocket();
                }
            } catch (error) {
                showError('Unable to connect to server. Please try again.');
                return;
            }

            socket.emit('join_party', {
                room_code: roomCode,
                username: username
            });
        }

        function leaveWatchparty() {
            console.log('leaveWatchparty() called');
            // Show popup positioned near X button
            const modal = document.getElementById('leaveWatchpartyModal');
            console.log('Modal element:', modal);
            if (modal) {
                modal.style.display = 'block';
                console.log('Popup should now be visible');

                // Add click outside handler
                setTimeout(() => {
                    const clickOutsideHandler = (e) => {
                        if (!modal.contains(e.target) && !e.target.classList.contains('watchparty-close')) {
                            closeLeaveWatchpartyModal();
                            document.removeEventListener('click', clickOutsideHandler);
                        }
                    };
                    document.addEventListener('click', clickOutsideHandler);
                }, 100);

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        closeLeaveWatchpartyModal();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
            } else {
                console.error('leaveWatchpartyModal not found!');
            }
        }

        function closeLeaveWatchpartyModal() {
            const modal = document.getElementById('leaveWatchpartyModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function confirmLeaveWatchparty() {
            closeLeaveWatchpartyModal();
            if (socket) {
                socket.emit('leave_party');
            }
            resetWatchparty();
        }

        function resetWatchparty() {
            watchpartyActive = false;
            watchpartyRoomCode = null;
            isHost = false;
            watchpartyUsers = [];
            userColorMap = {}; // Reset user colors for new session
            videoSyncListenersAttached = false; // Allow re-attachment for next party
            document.getElementById('watchpartySidebar').classList.remove('active');
            document.getElementById('chatMessages').innerHTML = '';

            // Stop drift correction
            stopDriftCorrection();

            showStatus('Left watchparty');
        }

        function showWatchpartySidebar() {
            document.getElementById('watchpartySidebar').classList.add('active');

            // Hide the watchparty panel when in a room (it will be shown in sidebar instead)
            // Only hide it if we're NOT in fullscreen (in fullscreen, sidebar is inside player)
            const isFullscreen = document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                document.mozFullScreenElement ||
                                document.msFullscreenElement;

            if (!isFullscreen) {
                const panel = document.getElementById('watchpartyPanel');
                if (panel) {
                    panel.classList.remove('active');
                }
            }
        }

        function updateWatchpartyUI(data) {
            document.getElementById('watchpartyRoomCode').textContent = data.room_code;
            updateUsersList(data.users);

            // Re-setup video sync listeners when host status changes
            const playerVideo = document.getElementById('playerVideo');
            if (playerVideo && playerVideo.style.display !== 'none') {
                videoSyncListenersAttached = false; // Reset flag
                setupVideoSyncListeners(playerVideo);
            }
        }

        function updateUsersList(users) {
            const userList = document.getElementById('watchpartyUserList');
            document.getElementById('userCount').textContent = users.length;

            userList.innerHTML = users.map((user, index) => {
                // Handle both old format (string) and new format (object with username/socket_id)
                const username = typeof user === 'string' ? user : user.username;
                const firstChar = username.charAt(0).toUpperCase();

                return `
                    <div class="user-item">
                        <div class="user-avatar">${firstChar}</div>
                        <div class="user-name">
                            ${username}
                            ${index === 0 ? ' <span style="color: #ffd700; font-size: 14px; margin-left: 4px;" title="Host controls playback"></span>' : ''}
                        </div>
                        ${index === 0 ? '<span class="host-badge" style="background: linear-gradient(135deg, #ffd700, #ff8c00); border: 1px solid #ffa500;">HOST</span>' : ''}
                    </div>
                `;
            }).join('');
        }

        function copyRoomCode() {
            const roomCode = document.getElementById('watchpartyRoomCode').textContent;
            const roomCodeElement = document.getElementById('watchpartyRoomCode');

            navigator.clipboard.writeText(roomCode);

            // Store original text
            const originalText = roomCodeElement.textContent;

            // Show "Copied!" message
            roomCodeElement.textContent = 'Copied!';
            roomCodeElement.style.color = '#ff00ff';

            // Revert back after 1.5 seconds
            setTimeout(() => {
                roomCodeElement.textContent = originalText;
                roomCodeElement.style.color = '#00ff9f';
            }, 1500);

            showStatus('Room code copied to clipboard!');
        }

        let replyingToMessage = null;

        function setReplyTo(username, messageText) {
            replyingToMessage = { username, messageText };
            const replyIndicator = document.getElementById('replyIndicator');
            const replyingToText = document.getElementById('replyingToText');

            replyingToText.textContent = `Replying to ${username}: ${messageText.substring(0, 50)}${messageText.length > 50 ? '...' : ''}`;
            replyIndicator.style.display = 'flex';

            // Focus the input
            document.getElementById('chatInput').focus();
        }

        function cancelReply() {
            replyingToMessage = null;
            document.getElementById('replyIndicator').style.display = 'none';
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (message && socket) {
                const data = { message };

                // Include reply info if replying
                if (replyingToMessage) {
                    data.replyTo = replyingToMessage;
                }

                socket.emit('chat_message', data);
                input.value = '';
                cancelReply();
            }
        }

        function handleChatKeypress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        // ============= WATCHPARTY CONTENT SYNC =============
        async function syncContentFromHost(content) {
            console.log('[Content Sync] Received content from host:', content);

            if (!content || !content.id) {
                console.log('[Content Sync] No valid content to sync');
                return;
            }

            const { id, title, type, season, episode } = content;

            console.log(`[Content Sync] Syncing ${type}: ${title}`, { id, season, episode });
            showStatus(`Syncing content: ${title}`);

            try {
                // Load the same content as the host
                if (type === 'tv') {
                    if (season && episode) {
                        console.log(`[Content Sync] Loading TV show: ${title} S${season}E${episode}`);

                        // First load the content to populate selectors
                        playContent(id, title, type);

                        // After content loads, play the specific episode
                        setTimeout(async () => {
                            console.log(`[Content Sync] Playing episode S${season}E${episode}`);
                            currentSelectedSeason = season;
                            currentSelectedEpisode = episode;

                            const seasonBtn = document.getElementById('seasonButtonText');
                            const episodeBtn = document.getElementById('episodeButtonText');

                            if (seasonBtn) seasonBtn.textContent = `Season ${season}`;

                            await updateEpisodeSelector(season);

                            if (episodeBtn) episodeBtn.textContent = `Episode ${episode}`;

                            playTVEpisode(id, season, episode);
                        }, 1500);
                    } else {
                        // Just load the TV show details page (no specific episode yet)
                        console.log(`[Content Sync] Loading TV show details: ${title}`);
                        playContent(id, title, type);
                    }
                } else if (type === 'movie') {
                    console.log(`[Content Sync] Loading movie: ${title} (ID: ${id})`);
                    console.log(`[Content Sync] Calling playMovie(${id})...`);
                    await playMovie(id);
                    console.log(`[Content Sync] playMovie() completed`);
                } else {
                    console.warn('[Content Sync] Unknown content type or missing data:', type);
                }
            } catch (error) {
                console.error('[Content Sync] Error syncing content:', error);
                showError('Failed to sync content from host');
            }
        }

        // ============= MOBILE KEYBOARD HANDLING =============
        let originalViewportHeight = window.innerHeight;
        let chatWasMinimized = false;

        // Detect keyboard opening/closing on mobile
        window.addEventListener('resize', () => {
            const currentHeight = window.innerHeight;
            const sidebar = document.getElementById('watchpartySidebar');

            // If viewport height decreased significantly (keyboard opened)
            if (originalViewportHeight - currentHeight > 150 && sidebar && sidebar.classList.contains('active')) {
                // Minimize chat when keyboard opens
                if (!sidebar.classList.contains('minimized')) {
                    chatWasMinimized = false;
                    sidebar.classList.add('minimized');
                }
            }
            // If viewport height increased (keyboard closed)
            else if (currentHeight > originalViewportHeight - 100 && sidebar && !chatWasMinimized) {
                // Restore chat when keyboard closes (only if we auto-minimized it)
                if (sidebar.classList.contains('minimized') && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('minimized');
                }
            }

            // Update the baseline height
            if (Math.abs(currentHeight - originalViewportHeight) < 50) {
                originalViewportHeight = currentHeight;
            }
        });

        // Setup chat input keyboard handlers when DOM is ready
        function setupMobileChatHandlers() {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('focus', () => {
                    const sidebar = document.getElementById('watchpartySidebar');
                    if (sidebar && sidebar.classList.contains('active') && window.innerWidth <= 768) {
                        setTimeout(() => {
                            if (!sidebar.classList.contains('minimized')) {
                                chatWasMinimized = false;
                                sidebar.classList.add('minimized');
                            }
                        }, 300); // Small delay to let keyboard animation start
                    }
                });

                chatInput.addEventListener('blur', () => {
                    const sidebar = document.getElementById('watchpartySidebar');
                    setTimeout(() => {
                        if (sidebar && sidebar.classList.contains('minimized') && !chatWasMinimized && window.innerWidth <= 768) {
                            sidebar.classList.remove('minimized');
                        }
                    }, 300); // Delay to ensure keyboard is fully closed
                });
            }
        }

        function getUserColor(username) {
            // If user already has a color, return it
            if (userColorMap[username]) {
                return userColorMap[username];
            }

            // Assign a new color based on hash of username
            let hash = 0;
            for (let i = 0; i < username.length; i++) {
                hash = username.charCodeAt(i) + ((hash << 5) - hash);
                hash = hash & hash; // Convert to 32bit integer
            }
            const colorIndex = Math.abs(hash) % userColors.length;
            userColorMap[username] = userColors[colorIndex];

            console.log(`Assigned color ${userColors[colorIndex]} to user ${username} (index: ${colorIndex})`);
            return userColorMap[username];
        }

        function addChatMessage(data) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';

            const time = new Date(data.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const userColor = getUserColor(data.username);

            // Build reply HTML if this is a reply
            let replyHTML = '';
            if (data.replyTo) {
                const replyUserColor = getUserColor(data.replyTo.username);
                replyHTML = `
                    <div class="replying-to">
                         <span style="color: ${replyUserColor};">${escapeHtml(data.replyTo.username)}</span>: ${escapeHtml(data.replyTo.messageText.substring(0, 30))}${data.replyTo.messageText.length > 30 ? '...' : ''}
                    </div>
                `;
            }

            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-username" style="color: ${userColor};">${escapeHtml(data.username)}</span>
                    <span class="chat-timestamp">${time}</span>
                </div>
                ${replyHTML}
                <div class="chat-text">${escapeHtml(data.message)}</div>
            `;

            // Add click handler to set reply
            messageDiv.addEventListener('click', () => {
                setReplyTo(data.username, data.message);
            });

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function addSystemMessage(text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.innerHTML = `
                <div class="chat-text" style="background: rgba(0, 122, 255, 0.1); border-left: 3px solid #007AFF; font-style: italic; color: #007AFF;">
                    ${text}
                </div>
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showSyncIndicator(message) {
            const indicator = document.getElementById('syncIndicator');
            indicator.textContent = message;
            indicator.classList.add('show');

            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        function syncWithRoomState(state) {
            // This would sync the video player with the room state
            console.log('Syncing with room state:', state);
            // In a real implementation, you would control the iframe here
        }

        function formatTime(seconds) {
            if (!seconds || seconds < 0) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function reloadPlayerWithTimestamp(timestamp) {
            if (!currentContentUrl) return;

            // Parse the URL correctly
            let url;
            try {
                url = new URL(currentContentUrl);
            } catch (e) {
                // If it's a relative URL, use window.location.origin
                url = new URL(currentContentUrl, window.location.origin);
            }

            const timeInSeconds = Math.floor(timestamp);

            // Remove any existing time parameters
            url.searchParams.delete('t');
            url.searchParams.delete('time');
            url.searchParams.delete('start');
            url.searchParams.delete('timestamp');

            // VidKing uses 't' parameter for timestamp (like YouTube)
            // Add it in the format most embedded players support
            url.searchParams.set('t', timeInSeconds);

            const player = document.getElementById('contentPlayer');
            const newUrl = url.toString();

            // Force reload by setting src to empty first, then to new URL
            player.src = 'about:blank';
            setTimeout(() => {
                player.src = newUrl;
            }, 100);

            console.log('Reloading player with timestamp:', timestamp, 'seconds');
            console.log('New URL:', newUrl);
            showStatus(`Syncing to ${formatTime(timestamp)}...`);
        }

        // Initialize socket on page load
        window.addEventListener('load', () => {
            initSocket();
        });


        // Setup video sync listeners for watchparty
        let isSyncing = false; // Flag to prevent sync loops
        let videoSyncListenersAttached = false; // Track if listeners are already attached
        let driftCorrectionInterval = null; // Interval for drift correction

        function setupVideoSyncListeners(videoElement) {
            if (!videoElement) {
                console.log('[Sync] No video element provided, skipping sync listener setup');
                return;
            }

            // Prevent duplicate listeners
            if (videoSyncListenersAttached) {
                console.log('[Sync] Video sync listeners already attached, skipping');
                return;
            }

            // Anyone in watchparty can send sync events (Mode 2: Shared controls)
            if (watchpartyActive) {
                console.log('[Sync] Setting up automatic sync listeners for video playback');
                console.log('[Sync] Watchparty active:', watchpartyActive);

                // Play event
                videoElement.addEventListener('play', function() {
                    if (isSyncing) {
                        console.log('[Sync] Skipping play sync (isSyncing flag is true)');
                        return; // Prevent sync loops
                    }

                    const currentTime = Math.floor(videoElement.currentTime);
                    console.log('[Sync] Video played at', currentTime, '- emitting playback_play');

                    socket.emit('playback_play', {
                        currentTime: currentTime
                    });
                });

                // Pause event
                videoElement.addEventListener('pause', function() {
                    if (isSyncing) {
                        console.log('[Sync] Skipping pause sync (isSyncing flag is true)');
                        return; // Prevent sync loops
                    }

                    const currentTime = Math.floor(videoElement.currentTime);
                    console.log('[Sync] Video paused at', currentTime, '- emitting playback_pause');

                    socket.emit('playback_pause', {
                        currentTime: currentTime
                    });
                });

                // Seeked event (when user scrubs through video)
                videoElement.addEventListener('seeked', function() {
                    if (isSyncing) {
                        console.log('[Sync] Skipping seek sync (isSyncing flag is true)');
                        return; // Prevent sync loops
                    }

                    const currentTime = Math.floor(videoElement.currentTime);
                    console.log('[Sync] Video seeked to', currentTime, '- emitting playback_seek');

                    socket.emit('playback_seek', {
                        currentTime: currentTime
                    });
                });

                videoSyncListenersAttached = true;
                console.log('[Sync]  Video sync listeners attached successfully - automatic sync enabled');

                // Start drift correction
                startDriftCorrection(videoElement);
            } else {
                console.log('[Sync] Not in active watchparty - no sync listeners attached');
            }
        }

        function startDriftCorrection(videoElement) {
            // Clear any existing interval
            if (driftCorrectionInterval) {
                clearInterval(driftCorrectionInterval);
            }

            console.log('[Drift] Starting drift correction (checks every 5 seconds)');

            driftCorrectionInterval = setInterval(() => {
                if (!watchpartyActive || !videoElement) {
                    stopDriftCorrection();
                    return;
                }

                // Only check drift if video is playing
                if (videoElement.paused) {
                    return;
                }

                // Request current time from backend by emitting a drift check
                // Backend will respond with the authoritative time
                socket.emit('request_sync_status');
            }, 5000); // Check every 5 seconds
        }

        function stopDriftCorrection() {
            if (driftCorrectionInterval) {
                console.log('[Drift] Stopping drift correction');
                clearInterval(driftCorrectionInterval);
                driftCorrectionInterval = null;
            }
        }

        // ============= END WATCHPARTY FUNCTIONS =============

        // ============= KEYBOARD SHORTCUTS =============

        let playerContainerFocused = false;

        // Setup keyboard shortcuts when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Setup player container for keyboard shortcuts
            const playerContainer = document.querySelector('.player-container');
            if (playerContainer) {
                console.log('Player container found, setting up keyboard shortcuts');

                // Make player container focusable
                playerContainer.setAttribute('tabindex', '0');
                playerContainer.style.outline = 'none'; // Remove focus outline for aesthetics

                // Track focus state
                playerContainer.addEventListener('click', (e) => {
                    // Don't steal focus if clicking on watchparty elements
                    const watchpartySidebar = document.getElementById('watchpartySidebar');
                    if (watchpartySidebar && watchpartySidebar.contains(e.target)) {
                        console.log('Click on watchparty sidebar - not stealing focus');
                        return; // Let the watchparty elements handle their own focus
                    }

                    playerContainerFocused = true;
                    playerContainer.focus();
                    console.log('Player container clicked and focused');
                });

                playerContainer.addEventListener('focus', () => {
                    playerContainerFocused = true;
                    console.log('Player container focused');
                });

                playerContainer.addEventListener('blur', () => {
                    playerContainerFocused = false;
                    console.log('Player container blurred');
                });
            } else {
                console.error('Player container not found!');
            }
        });

        // ============= END KEYBOARD SHORTCUTS =============

        // ============= THEME SYSTEM =============
        const themes = {
            'matrix': { name: 'Matrix', color: '#00ff9f' },
            'hacker': { name: 'Hacker', color: '#00ff00' },
            'sunset': { name: 'Sunset', color: '#ff6b35' },
            'vaporwave': { name: 'Vaporwave', color: '#ff00ff' },
            'ocean': { name: 'Ocean', color: '#00d4ff' },
            'dracula': { name: 'Dracula', color: '#bd93f9' },
            'midnight': { name: 'Midnight Oil', color: '#ffd700' },
            'jspecial': { name: "J's Special", color: '#ff1493' },
            'phosphor': { name: 'Phosphor Burn', color: '#ffb000' }
        };

        let currentTheme = localStorage.getItem('selectedTheme') || 'jspecial';

        // Background effects state
        let activeEffects = JSON.parse(localStorage.getItem('bgEffects') || '{"matrix":false,"stars":true,"particles":true,"scanline":true}');

        // Clean up removed effects from old localStorage data
        if (activeEffects.vhs !== undefined || activeEffects.crt !== undefined || activeEffects.filmgrain !== undefined) {
            delete activeEffects.vhs;
            delete activeEffects.crt;
            delete activeEffects.filmgrain;
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));
        }

        function applyTheme(themeName) {
            document.documentElement.setAttribute('data-theme', themeName);
            currentTheme = themeName;
            localStorage.setItem('selectedTheme', themeName);

            // Update active state in theme selector
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.theme === themeName) {
                    opt.classList.add('active');
                }
            });

            // Handle phosphor theme specific elements
            updatePhosphorElements(themeName === 'phosphor');
        }

        // Show/hide phosphor-specific UI elements
        function updatePhosphorElements(isPhosphor) {
            const scanlines = document.getElementById('crtScanlines');
            const curvature = document.getElementById('crtCurvature');
            const powerLed = document.getElementById('crtPowerLed');
            const floatingSearch = document.getElementById('floatingSearch');

            if (isPhosphor) {
                if (scanlines) scanlines.style.display = 'block';
                if (curvature) curvature.style.display = 'block';
                if (powerLed) powerLed.style.display = 'block';
                if (floatingSearch) floatingSearch.style.display = 'block';
            } else {
                if (scanlines) scanlines.style.display = 'none';
                if (curvature) curvature.style.display = 'none';
                if (powerLed) powerLed.style.display = 'none';
                if (floatingSearch) floatingSearch.style.display = 'none';
            }
        }

        window.toggleThemeSelector = function() {
            const panel = document.getElementById('themeSelectorPanel');
            panel.classList.toggle('active');
        }

        window.toggleEffectsPanel = function() {
            const panel = document.getElementById('bgEffectsPanel');
            panel.classList.toggle('active');
        }

        window.toggleWatchpartyPanel = function() {
            const panel = document.getElementById('watchpartyPanel');
            panel.classList.toggle('active');
        }

        window.toggleEffect = function(effectName) {
            activeEffects[effectName] = !activeEffects[effectName];
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));

            // Update UI
            const option = document.querySelector(`[data-effect="${effectName}"]`);
            if (activeEffects[effectName]) {
                option.classList.add('active');
            } else {
                option.classList.remove('active');
            }

            // Update background
            updateBackgroundEffects();
        }

        window.enableAllEffects = function() {
            activeEffects = {matrix: true, stars: true, particles: true, scanline: true};
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));
            updateEffectsUI();
            updateBackgroundEffects();
        }

        window.disableAllEffects = function() {
            activeEffects = {matrix: false, stars: false, particles: false, scanline: false};
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));
            updateEffectsUI();
            updateBackgroundEffects();
        }

        function updateEffectsUI() {
            Object.keys(activeEffects).forEach(effect => {
                const option = document.querySelector(`[data-effect="${effect}"]`);
                if (option) {
                    if (activeEffects[effect]) {
                        option.classList.add('active');
                    } else {
                        option.classList.remove('active');
                    }
                }
            });
        }

        function updateBackgroundEffects() {
            const container = document.getElementById('bgAnimation');
            container.innerHTML = '';

            if (activeEffects.matrix) createMatrixRain();
            if (activeEffects.stars) createPixelStars();
            if (activeEffects.particles) createParticles();
            if (activeEffects.scanline) createScanline();
        }

        function initThemeSelector() {
            const panel = document.getElementById('themeSelectorPanel');
            Object.keys(themes).forEach(themeKey => {
                const theme = themes[themeKey];
                const option = document.createElement('div');
                option.className = 'theme-option';
                option.dataset.theme = themeKey;
                if (themeKey === currentTheme) option.classList.add('active');

                option.innerHTML = `
                    <div class="theme-color-preview" style="background: ${theme.color};"></div>
                    <div class="theme-name">${theme.name}</div>
                `;

                option.addEventListener('click', () => {
                    applyTheme(themeKey);
                    toggleThemeSelector();
                });

                panel.appendChild(option);
            });
        }

        // ============= ANIMATED BACKGROUND =============
        function createMatrixRain() {
            const container = document.getElementById('bgAnimation');
            const chars = '01';

            for (let i = 0; i < 30; i++) {
                const drop = document.createElement('div');
                drop.className = 'matrix-rain';
                drop.textContent = chars[Math.floor(Math.random() * chars.length)].repeat(Math.floor(Math.random() * 15) + 5);
                drop.style.left = Math.random() * 100 + '%';
                drop.style.animationDuration = (Math.random() * 3 + 2) + 's';
                drop.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(drop);
            }
        }

        function createPixelStars() {
            const container = document.getElementById('bgAnimation');

            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'pixel-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(star);
            }
        }

        function createParticles() {
            const container = document.getElementById('bgAnimation');

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                particle.style.animationDelay = Math.random() * 5 + 's';
                container.appendChild(particle);
            }
        }

        function createPlayerStars() {
            const container = document.getElementById('playerBgAnimation');
            if (!container) return;

            container.innerHTML = ''; // Clear existing

            for (let i = 0; i < 30; i++) {
                const star = document.createElement('div');
                star.className = 'pixel-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(star);
            }
        }

        function createPlayerParticles() {
            const container = document.getElementById('playerBgAnimation');
            if (!container) return;

            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                particle.style.animationDelay = Math.random() * 5 + 's';
                container.appendChild(particle);
            }
        }

        function initPlayerBackgroundEffects() {
            createPlayerStars();
            createPlayerParticles();
        }

        function clearPlayerBackgroundEffects() {
            const container = document.getElementById('playerBgAnimation');
            if (container) {
                container.innerHTML = '';
            }
        }

        function createScanline() {
            const container = document.getElementById('bgAnimation');
            const scanline = document.createElement('div');
            scanline.className = 'scanline';
            container.appendChild(scanline);
        }

        function createVHSEffect() {
            const container = document.getElementById('bgAnimation');
            const vhs = document.createElement('div');
            vhs.className = 'vhs-effect';
            container.appendChild(vhs);
        }

        function createCRTEffect() {
            const container = document.getElementById('bgAnimation');
            const crt = document.createElement('div');
            crt.className = 'crt-effect';
            container.appendChild(crt);
        }

        function createFilmGrain() {
            const container = document.getElementById('bgAnimation');
            const grain = document.createElement('div');
            grain.className = 'filmgrain-effect';
            container.appendChild(grain);
        }

        function initBgAnimation() {
            // Initialize effects UI
            updateEffectsUI();
            // Create enabled effects
            updateBackgroundEffects();
        }

        // ============= PHOSPHOR THEME CRT BOOT SEQUENCE =============
        let crtBootCompleted = sessionStorage.getItem('crtBootCompleted') === 'true';

        function runCrtBootSequence() {
            if (crtBootCompleted) {
                // Skip boot if already completed this session
                return Promise.resolve();
            }

            return new Promise((resolve) => {
                const overlay = document.getElementById('crtBootOverlay');

                if (!overlay) {
                    resolve();
                    return;
                }

                const bootLine = overlay.querySelector('.crt-boot-line');
                const bootText = overlay.querySelector('.crt-boot-text');

                // Failsafe: always hide overlay after 5 seconds max
                const failsafeTimeout = setTimeout(() => {
                    console.log('CRT boot failsafe triggered');
                    overlay.style.display = 'none';
                    overlay.classList.remove('active');
                    sessionStorage.setItem('crtBootCompleted', 'true');
                    crtBootCompleted = true;
                    resolve();
                }, 5000);

                // If GSAP not available, skip boot animation
                if (typeof gsap === 'undefined') {
                    clearTimeout(failsafeTimeout);
                    console.log('GSAP not available, skipping boot sequence');
                    resolve();
                    return;
                }

                overlay.style.display = 'block';
                overlay.classList.add('active');

                const bootMessages = [
                    'INITIALIZING GLITCHBOX v2.0...',
                    'LOADING PHOSPHOR DISPLAY DRIVER...',
                    'CALIBRATING CRT BEAM...',
                    'SYSTEM READY'
                ];

                // Timeline for boot animation
                const tl = gsap.timeline({
                    onComplete: () => {
                        clearTimeout(failsafeTimeout);
                        gsap.to(overlay, {
                            opacity: 0,
                            duration: 0.5,
                            onComplete: () => {
                                overlay.style.display = 'none';
                                overlay.classList.remove('active');
                                overlay.style.opacity = 1;
                                if (bootText) bootText.textContent = '';
                                if (bootLine) bootLine.classList.remove('expanding');
                                sessionStorage.setItem('crtBootCompleted', 'true');
                                crtBootCompleted = true;
                                resolve();
                            }
                        });
                    }
                });

                // Phase 1: Amber glow warmup
                tl.to(overlay, {
                    backgroundColor: '#0a0800',
                    duration: 0.3
                });

                // Phase 2: Horizontal line expands
                tl.add(() => {
                    bootLine.classList.add('expanding');
                }, '+=0.2');

                tl.to({}, { duration: 0.6 });

                // Phase 3: Type out boot messages
                let messageIndex = 0;
                const typeMessage = () => {
                    if (messageIndex >= bootMessages.length) return;

                    const message = bootMessages[messageIndex];
                    let charIndex = 0;

                    const typeInterval = setInterval(() => {
                        if (charIndex < message.length) {
                            bootText.textContent += message[charIndex];
                            charIndex++;
                        } else {
                            clearInterval(typeInterval);
                            bootText.textContent += '\n';
                            messageIndex++;
                            if (messageIndex < bootMessages.length) {
                                setTimeout(typeMessage, 200);
                            }
                        }
                    }, 30);
                };

                tl.add(() => {
                    typeMessage();
                }, '+=0.3');

                // Wait for typing to complete
                tl.to({}, { duration: 2.5 });

                // Phase 4: Screen flicker before reveal
                tl.to(overlay, {
                    opacity: 0.8,
                    duration: 0.05,
                    repeat: 3,
                    yoyo: true
                });
            });
        }

        // ============= FLOATING SEARCH FUNCTIONALITY =============
        let floatingSearchOpen = false;
        let floatingSearchDebounceTimer = null;

        window.toggleFloatingSearch = function() {
            const panel = document.querySelector('.floating-search-panel');
            const input = document.getElementById('floatingSearchInput');

            if (!panel) return;

            floatingSearchOpen = !floatingSearchOpen;

            if (floatingSearchOpen) {
                // Use GSAP for smooth animation if available
                if (typeof gsap !== 'undefined') {
                    gsap.to(panel, {
                        scaleX: 1,
                        opacity: 1,
                        duration: 0.4,
                        ease: 'back.out(1.7)',
                        onComplete: () => {
                            panel.classList.add('active');
                            if (input) input.focus();
                        }
                    });
                } else {
                    panel.classList.add('active');
                    if (input) input.focus();
                }
            } else {
                if (typeof gsap !== 'undefined') {
                    gsap.to(panel, {
                        scaleX: 0,
                        opacity: 0,
                        duration: 0.3,
                        ease: 'power2.in',
                        onComplete: () => {
                            panel.classList.remove('active');
                        }
                    });
                } else {
                    panel.classList.remove('active');
                }
            }
        };

        function initFloatingSearch() {
            const input = document.getElementById('floatingSearchInput');
            const resultsDiv = document.getElementById('floatingSearchResults');

            if (!input || !resultsDiv) return;

            input.addEventListener('input', function(e) {
                const query = e.target.value.trim();

                if (floatingSearchDebounceTimer) {
                    clearTimeout(floatingSearchDebounceTimer);
                }

                if (query.length < 2) {
                    resultsDiv.innerHTML = '';
                    return;
                }

                floatingSearchDebounceTimer = setTimeout(async () => {
                    try {
                        resultsDiv.innerHTML = '<div style="padding: 16px; color: #ffb000;">Searching...</div>';

                        // Use the existing search function
                        const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=5492f8f13c3de8b6b8f95a9e0ae7db71&query=${encodeURIComponent(query)}`);
                        const data = await response.json();

                        if (data.results && data.results.length > 0) {
                            const filteredResults = data.results
                                .filter(item => item.media_type === 'movie' || item.media_type === 'tv')
                                .slice(0, 6);

                            resultsDiv.innerHTML = filteredResults.map(item => {
                                const title = item.title || item.name;
                                const year = item.release_date || item.first_air_date;
                                const yearStr = year ? year.substring(0, 4) : 'N/A';
                                const posterPath = item.poster_path
                                    ? `https://image.tmdb.org/t/p/w92${item.poster_path}`
                                    : 'https://via.placeholder.com/40x60/333/fff?text=N/A';
                                const type = item.media_type === 'tv' ? 'TV' : 'Movie';

                                return `
                                    <div class="floating-search-result-item" onclick="floatingSearchSelect(${item.id}, '${title.replace(/'/g, "\\'")}', '${item.media_type}')">
                                        <img src="${posterPath}" alt="${title}" onerror="this.src='https://via.placeholder.com/40x60/333/fff?text=N/A'">
                                        <div class="floating-search-result-info">
                                            <div class="floating-search-result-title">${title}</div>
                                            <div class="floating-search-result-year">${yearStr}  ${type}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                        } else {
                            resultsDiv.innerHTML = '<div style="padding: 16px; color: rgba(255, 176, 0, 0.6);">No results found</div>';
                        }
                    } catch (error) {
                        console.error('Floating search error:', error);
                        resultsDiv.innerHTML = '<div style="padding: 16px; color: #ff6666;">Search error</div>';
                    }
                }, 300);
            });

            // Handle Enter key
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const firstResult = resultsDiv.querySelector('.floating-search-result-item');
                    if (firstResult) {
                        firstResult.click();
                    }
                } else if (e.key === 'Escape') {
                    toggleFloatingSearch();
                }
            });
        }

        window.floatingSearchSelect = function(id, title, type) {
            // Close the search panel
            toggleFloatingSearch();

            // Clear the input
            const input = document.getElementById('floatingSearchInput');
            if (input) input.value = '';

            // Clear results
            const resultsDiv = document.getElementById('floatingSearchResults');
            if (resultsDiv) resultsDiv.innerHTML = '';

            // Play the selected content - redirect to player
            window.location.href = `movie_tv_player.html?id=${id}&title=${encodeURIComponent(title)}&type=${type}`;
        };

        // Close floating search when clicking outside
        function setupFloatingSearchClickOutside() {
            document.addEventListener('click', function(e) {
                const floatingSearch = document.getElementById('floatingSearch');
                if (floatingSearchOpen && floatingSearch && !floatingSearch.contains(e.target)) {
                    toggleFloatingSearch();
                }
            });
        }

        // ============= END PHOSPHOR THEME FUNCTIONS =============

        // Initialize theme and animations
        document.addEventListener('DOMContentLoaded', async () => {
            // Check if phosphor theme should show boot sequence
            if (currentTheme === 'phosphor' && !crtBootCompleted) {
                await runCrtBootSequence();
            }

            applyTheme(currentTheme);
            initThemeSelector();
            initBgAnimation();
            setupClickOutsideListeners();
            initFloatingSearch();
            setupFloatingSearchClickOutside();
        });

        // ============= CLICK OUTSIDE TO CLOSE PANELS =============
        function setupClickOutsideListeners() {
            document.addEventListener('click', function(event) {
                // Season Panel
                const seasonPanel = document.getElementById('seasonPanel');
                const seasonButton = document.getElementById('seasonButton');
                if (seasonPanel && seasonPanel.style.display === 'flex') {
                    if (!seasonPanel.contains(event.target) && !seasonButton.contains(event.target)) {
                        seasonPanel.style.display = 'none';
                    }
                }

                // Episode Panel
                const episodePanel = document.getElementById('episodePanel');
                const episodeButton = document.getElementById('episodeButton');
                if (episodePanel && episodePanel.style.display === 'flex') {
                    if (!episodePanel.contains(event.target) && !episodeButton.contains(event.target)) {
                        episodePanel.style.display = 'none';
                    }
                }

                // Watchlist Panel
                const watchlistPanel = document.getElementById('watchlistPanel');
                const playerWatchlistBtn = document.getElementById('playerWatchlistBtn');
                if (watchlistPanel && watchlistPanel.style.display === 'flex') {
                    // Check if click is on any watchlist button or the panel itself
                    const isWatchlistButton = event.target.classList.contains('watchlist-btn') ||
                                             event.target.closest('.watchlist-btn') ||
                                             (playerWatchlistBtn && playerWatchlistBtn.contains(event.target));

                    if (!watchlistPanel.contains(event.target) && !isWatchlistButton) {
                        watchlistPanel.style.display = 'none';
                        window.pendingWatchlistPanelItem = null;
                    }
                }

                // Theme Selector Panel
                const themeSelectorPanel = document.getElementById('themeSelectorPanel');
                const themeSelectorBtn = document.querySelector('.theme-selector-btn');
                if (themeSelectorPanel && themeSelectorPanel.classList.contains('active')) {
                    if (!themeSelectorPanel.contains(event.target) && !themeSelectorBtn.contains(event.target)) {
                        themeSelectorPanel.classList.remove('active');
                    }
                }

                // Effects Panel
                const bgEffectsPanel = document.getElementById('bgEffectsPanel');
                const effectsToggleBtn = document.querySelector('.bg-animation-toggle[onclick*="toggleEffectsPanel"]');
                if (bgEffectsPanel && bgEffectsPanel.classList.contains('active')) {
                    if (!bgEffectsPanel.contains(event.target) &&
                        (!effectsToggleBtn || !effectsToggleBtn.contains(event.target))) {
                        bgEffectsPanel.classList.remove('active');
                    }
                }

                // Watchparty Panel
                const watchpartyPanel = document.getElementById('watchpartyPanel');
                const watchpartyToggleBtn = document.querySelector('.bg-animation-toggle[onclick*="toggleWatchpartyPanel"]');
                if (watchpartyPanel && watchpartyPanel.classList.contains('active')) {
                    if (!watchpartyPanel.contains(event.target) &&
                        (!watchpartyToggleBtn || !watchpartyToggleBtn.contains(event.target))) {
                        watchpartyPanel.classList.remove('active');
                    }
                }
            });
        }
        // ============= END CLICK OUTSIDE TO CLOSE PANELS =============

        // ============= END THEME & ANIMATION SYSTEM =============

        // ============= SPORTS STREAMING SECTION =============

        const WESTREAM_BASE_URL = 'https://westream.su';  // Free sports streaming API
        let allSportsMatches = [];
        let availableSports = [];
        let isLiveFilterActive = false; // Toggle state for live filter
        let currentSportType = null; // null means all sports, or a specific sport id
        let currentDisplayedMatches = []; // Keep track of currently filtered matches
        let allMatchesForCurrentSport = []; // All matches for selected sport (before live filter)

        // Sports stream source management
        let currentSportsMatch = null; // Store the current match being played
        let currentSportsSourceIndex = 0; // Track which source is currently selected

        // Load sports data from westream API
        async function loadSportsData() {
            try {
                showLoading();

                // Reset filters to default
                isLiveFilterActive = false;
                currentSportType = null;

                // Clear search input
                const searchInput = document.getElementById('sportsSearchInput');
                const clearBtn = document.getElementById('clearSportsSearchBtn');
                if (searchInput) searchInput.value = '';
                if (clearBtn) clearBtn.style.display = 'none';

                // Reset button states
                const liveBtn = document.getElementById('liveSportsBtn');
                if (liveBtn) liveBtn.classList.remove('active');

                document.querySelectorAll('#sportTypeButtons .bg-animation-toggle').forEach(btn => {
                    btn.classList.remove('active');
                });

                // Fetch available sports
                const sportsResponse = await fetch(`${WESTREAM_BASE_URL}/sports`);
                availableSports = await sportsResponse.json();

                // Fetch all matches
                const matchesResponse = await fetch(`${WESTREAM_BASE_URL}/matches`);
                allSportsMatches = await matchesResponse.json();

                // Populate sport type filter buttons
                populateSportTypeButtons();

                // Display matches based on current filter
                filterAndDisplayMatches();

                hideLoading();
            } catch (error) {
                console.error('Error loading sports data:', error);
                showError('Failed to load sports data');
                hideLoading();
            }
        }

        // Populate sport type filter buttons
        function populateSportTypeButtons() {
            const buttonContainer = document.getElementById('sportTypeButtons');
            buttonContainer.innerHTML = '';

            availableSports.forEach(sport => {
                const button = document.createElement('button');
                button.className = 'bg-animation-toggle';
                button.textContent = ` ${sport.name || sport}`;
                button.onclick = () => setSportType(sport.id || sport);
                buttonContainer.appendChild(button);
            });
        }

        // Toggle live filter on/off
        function toggleLiveFilter() {
            // Toggle the live filter state
            isLiveFilterActive = !isLiveFilterActive;

            // Clear search input when toggling
            const searchInput = document.getElementById('sportsSearchInput');
            if (searchInput) searchInput.value = '';

            // Update button state
            const liveBtn = document.getElementById('liveSportsBtn');
            if (liveBtn) {
                if (isLiveFilterActive) {
                    liveBtn.classList.add('active');
                } else {
                    liveBtn.classList.remove('active');
                }
            }

            // Keep sport type buttons state unchanged
            filterAndDisplayMatches();
        }

        // Set sport type filter
        function setSportType(sportType) {
            currentSportType = sportType;
            // Keep currentSportsFilter - don't reset the all/live filter

            // Clear search input when changing filters
            const searchInput = document.getElementById('sportsSearchInput');
            if (searchInput) searchInput.value = '';

            // Update sport type button states only
            document.querySelectorAll('#sportTypeButtons .bg-animation-toggle').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(sportType)) {
                    btn.classList.add('active');
                }
            });

            filterAndDisplayMatches();
        }

        // Filter and display matches
        async function filterAndDisplayMatches() {
            let sportMatches = [];
            let filteredMatches = [];

            try {
                // Step 1: Filter by sport type
                if (currentSportType) {
                    // Fetch matches for specific sport
                    const response = await fetch(`${WESTREAM_BASE_URL}/matches/${currentSportType}`);
                    sportMatches = await response.json();
                } else {
                    // Use all matches
                    sportMatches = allSportsMatches;
                }

                // Store all matches for current sport (before live filter)
                allMatchesForCurrentSport = sportMatches;

                // Step 2: Apply live filter if active
                if (isLiveFilterActive) {
                    // Filter to show only live matches from the sport selection
                    const liveResponse = await fetch(`${WESTREAM_BASE_URL}/matches/live`);
                    const allLiveMatches = await liveResponse.json();

                    // If a sport is selected, filter live matches to that sport
                    if (currentSportType) {
                        filteredMatches = allLiveMatches.filter(match =>
                            match.category === currentSportType
                        );
                    } else {
                        // Show all live matches
                        filteredMatches = allLiveMatches;
                    }
                } else {
                    // Show all matches for selected sport (or all sports)
                    filteredMatches = sportMatches;
                }

                displaySportsMatches(filteredMatches);
            } catch (error) {
                console.error('Error filtering matches:', error);
                showError('Failed to load matches');
            }
        }

        // Display sports matches in the grid
        function displaySportsMatches(matches) {
            const container = document.getElementById('sportsMatches');

            if (!matches || matches.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px; color: #666;">
                        <h3 style="font-size: 24px; margin-bottom: 12px; color: #00d9ff;">No matches available</h3>
                        <p style="font-size: 18px;">Check back later for live sports events</p>
                    </div>
                `;
                return;
            }

            // Store matches globally for access by playSportsStream and search
            window.currentSportsMatches = matches;
            currentDisplayedMatches = matches;

            container.innerHTML = matches.map((match, index) => createSportsMatchCard(match, index)).join('');
        }

        // Search sports matches
        function searchSportsMatches() {
            const searchInput = document.getElementById('sportsSearchInput');
            const clearBtn = document.getElementById('clearSportsSearchBtn');
            const query = searchInput.value.toLowerCase().trim();

            // Show/hide clear button
            if (clearBtn) {
                clearBtn.style.display = query ? 'block' : 'none';
            }

            // If search is empty, show all currently filtered matches
            if (!query) {
                displaySportsMatches(currentDisplayedMatches);
                return;
            }

            // Filter matches based on search query
            const filteredMatches = currentDisplayedMatches.filter(match => {
                // Extract team names
                let homeTeam = '';
                let awayTeam = '';

                if (match.teams?.home?.name && match.teams?.away?.name) {
                    homeTeam = match.teams.home.name.toLowerCase();
                    awayTeam = match.teams.away.name.toLowerCase();
                } else if (match.title) {
                    const parts = match.title.split(/\s+(?:vs|VS|-)\s+/);
                    if (parts.length === 2) {
                        homeTeam = parts[0].trim().toLowerCase();
                        awayTeam = parts[1].trim().toLowerCase();
                    }
                }

                const title = (match.title || '').toLowerCase();
                const category = (match.category || '').toLowerCase();

                // Search in title, teams, and category
                return title.includes(query) ||
                       homeTeam.includes(query) ||
                       awayTeam.includes(query) ||
                       category.includes(query);
            });

            displaySportsMatches(filteredMatches);
        }

        // Clear sports search
        function clearSportsSearch() {
            const searchInput = document.getElementById('sportsSearchInput');
            const clearBtn = document.getElementById('clearSportsSearchBtn');

            if (searchInput) searchInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';

            displaySportsMatches(currentDisplayedMatches);
        }

        // Create a sports match card
        function createSportsMatchCard(match, index) {
            // Check if live filter is active to determine if this is a live match
            const isLive = isLiveFilterActive;

            // Extract team names from teams object or parse from title
            let homeTeam = 'Home Team';
            let awayTeam = 'Away Team';

            if (match.teams?.home?.name && match.teams?.away?.name) {
                homeTeam = match.teams.home.name;
                awayTeam = match.teams.away.name;
            } else if (match.title) {
                // Parse title like "Team A vs Team B" or "Team A - Team B"
                const parts = match.title.split(/\s+(?:vs|VS|-)\s+/);
                if (parts.length === 2) {
                    homeTeam = parts[0].trim();
                    awayTeam = parts[1].trim();
                } else {
                    homeTeam = match.title;
                    awayTeam = '';
                }
            }

            // Format date
            const matchDate = match.date ? new Date(match.date) : null;
            const matchTime = matchDate ? matchDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'TBD';

            // Get sport category
            const sport = match.category || 'Sports';
            const sportDisplay = sport.charAt(0).toUpperCase() + sport.slice(1);

            // Get source count
            const sourceCount = match.sources ? match.sources.length : 0;

            return `
                <div class="content-card" onclick='playSportsStream(${index})' style="--accent-color: ${isLive ? '#ff00ff' : '#00d9ff'}; --primary-color: ${isLive ? '#00ff9f' : '#00ff9f'};">
                    ${isLive ? `
                        <div class="content-type-badge" style="background: rgba(255,0,0,0.9); border-color: #ff0000; animation: pulse 2s infinite;">
                             LIVE
                        </div>
                    ` : `
                        <div class="content-type-badge" style="background: rgba(0,217,255,0.9); border-color: #00d9ff;">
                            SPORTS
                        </div>
                    `}
                    ${sourceCount > 1 ? `
                        <div class="content-type-badge" style="background: rgba(255,165,0,0.9); border-color: #ffa500; top: 50px;">
                            ${sourceCount} Sources
                        </div>
                    ` : ''}

                    <div class="content-poster" style="padding: 20px; min-height: 300px; display: flex; flex-direction: column; justify-content: center; background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div style="color: #00d9ff; font-size: 18px; margin-bottom: 8px; text-transform: uppercase; font-weight: bold;">
                                ${sportDisplay}
                            </div>
                        </div>

                        <div style="text-align: center; margin: 20px 0;">
                            <div style="color: #00ff9f; font-size: 22px; font-weight: bold; margin-bottom: 12px;">
                                ${homeTeam}
                            </div>
                            ${awayTeam ? `
                                <div style="color: #ff00ff; font-size: 20px; margin: 8px 0;">
                                    VS
                                </div>
                                <div style="color: #00ff9f; font-size: 22px; font-weight: bold; margin-top: 12px;">
                                    ${awayTeam}
                                </div>
                            ` : ''}
                        </div>

                        <div style="text-align: center; margin-top: 20px; padding-top: 16px; border-top: 2px solid rgba(0, 217, 255, 0.3);">
                            <div style="color: #00d9ff; font-size: 18px;">
                                ${isLive ? ' LIVE NOW' : matchTime}
                            </div>
                        </div>
                    </div>
                    <div class="content-info">
                        <div class="content-title">${awayTeam ? `${homeTeam} vs ${awayTeam}` : homeTeam}</div>
                        <div class="content-year">${sportDisplay}</div>
                        <div class="content-genres">${isLive ? 'Live Now' : matchTime}</div>
                    </div>
                </div>
            `;
        }

        // Play sports stream in the content player
        function playSportsStream(matchIndex, sourceIndex = 0) {
            // Get the match from the global array
            const match = window.currentSportsMatches[matchIndex];
            if (!match) {
                showError('Match not found');
                return;
            }

            // Get streaming source
            if (!match.sources || match.sources.length === 0) {
                showError('No streaming source available for this match');
                return;
            }

            // Store current match and source index
            currentSportsMatch = match;
            currentSportsSourceIndex = sourceIndex;

            // Get the selected source
            const selectedSource = match.sources[sourceIndex];
            const source = selectedSource.source;
            const sourceId = selectedSource.id;
            const streamNo = 1; // Default stream number

            // Build the embed URL
            const embedUrl = `https://westream.su/embed/${source}/${sourceId}/${streamNo}`;

            console.log('Playing sports stream:', embedUrl);
            console.log('Match data:', match);
            console.log('Using source:', selectedSource);

            // Extract team names
            let homeTeam = 'Team 1';
            let awayTeam = 'Team 2';

            if (match.teams?.home?.name && match.teams?.away?.name) {
                homeTeam = match.teams.home.name;
                awayTeam = match.teams.away.name;
            } else if (match.title) {
                const parts = match.title.split(/\s+(?:vs|VS|-)\s+/);
                if (parts.length === 2) {
                    homeTeam = parts[0].trim();
                    awayTeam = parts[1].trim();
                } else {
                    homeTeam = match.title;
                    awayTeam = '';
                }
            }

            // Update current content info
            currentContentId = match.id;
            currentContentType = 'sports';
            currentContentTitle = awayTeam ? `${homeTeam} vs ${awayTeam}` : homeTeam;

            // Show the player section
            const playerSection = document.getElementById('playerSection');
            const currentContent = document.getElementById('currentContent');
            if (playerSection) playerSection.style.display = 'block';
            if (currentContent) currentContent.style.display = 'block';

            // Hide TV controls for sports
            const tvControls = document.getElementById('tvControls');
            if (tvControls) tvControls.style.display = 'none';

            // Hide OMDB details for sports
            const omdbDetails = document.getElementById('omdbDetails');
            const omdbRatings = document.getElementById('omdbRatings');
            if (omdbDetails) omdbDetails.style.display = 'none';
            if (omdbRatings) omdbRatings.style.display = 'none';

            // Update content info display with correct element IDs
            const titleEl = document.getElementById('currentTitle');
            const yearEl = document.getElementById('currentYear');
            const overviewEl = document.getElementById('currentOverview');
            const posterEl = document.getElementById('currentPoster');

            const sport = match.category || 'Sports';
            const sportDisplay = sport.charAt(0).toUpperCase() + sport.slice(1);

            if (titleEl) titleEl.textContent = currentContentTitle;
            if (yearEl) yearEl.textContent = `${sportDisplay}${isLiveFilterActive ? ' - Live Now' : ''}`;
            if (overviewEl) overviewEl.textContent = match.description || `Watch ${currentContentTitle}${isLiveFilterActive ? ' live' : ''}`;

            // Set backdrop if available
            const backdropImage = document.getElementById('backdropImage');
            if (backdropImage) {
                if (match.image || match.thumbnail) {
                    backdropImage.style.backgroundImage = `url(${match.image || match.thumbnail})`;
                } else {
                    backdropImage.style.backgroundImage = 'linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%)';
                }
            }

            // Set poster to placeholder or match image
            if (posterEl) {
                if (match.image || match.thumbnail) {
                    posterEl.src = match.image || match.thumbnail;
                    posterEl.style.display = 'block';
                } else {
                    posterEl.style.display = 'none';
                }
            }

            // Update sports source button
            updateSportsSourceButton();

            // Hide video source button (for movies/TV)
            const sourceMenuContainer = document.getElementById('sourceMenuContainer');
            if (sourceMenuContainer) sourceMenuContainer.style.display = 'none';

            // Hide source hint
            dismissSourceHint();

            // Hide next episode button
            const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
            if (nextEpisodeBtn) nextEpisodeBtn.style.display = 'none';

            // Load the stream in the iframe
            loadPlayerContent(embedUrl);

            // Scroll to player
            if (currentContent) {
                currentContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            showStatus(`Loading ${match.sport || 'Sports'} stream...`);
        }

        // Update sports source button display
        function updateSportsSourceButton() {
            const btn = document.getElementById('sportsSourceBtn');
            const btnText = document.getElementById('sportsSourceBtnText');

            if (!btn || !btnText || !currentSportsMatch) return;

            const sources = currentSportsMatch.sources || [];

            // Only show button if there are multiple sources
            if (sources.length > 1) {
                btn.style.display = 'inline-block';

                // Get source name
                const currentSource = sources[currentSportsSourceIndex];
                let sourceName;

                if (currentSource?.source === 'okru') {
                    // Use title if available for OK.ru sources
                    sourceName = currentSource.title || 'OK.ru';
                } else {
                    sourceName = currentSource?.source?.toUpperCase() || `Source ${currentSportsSourceIndex + 1}`;
                }

                btnText.textContent = `${sourceName} (${currentSportsSourceIndex + 1}/${sources.length})`;
            } else {
                btn.style.display = 'none';
            }
        }

        // Switch to the next available sports source
        window.switchSportsSource = function() {
            if (!currentSportsMatch || !currentSportsMatch.sources) {
                showError('No match is currently playing');
                return;
            }

            const sources = currentSportsMatch.sources;
            if (sources.length <= 1) {
                showStatus('Only one source available for this match');
                return;
            }

            // Move to next source (cycle back to 0 after last one)
            currentSportsSourceIndex = (currentSportsSourceIndex + 1) % sources.length;

            // Get the match index in the current displayed matches
            const matchIndex = window.currentSportsMatches.findIndex(m => m.id === currentSportsMatch.id);

            if (matchIndex !== -1) {
                // Replay the match with the new source
                playSportsStream(matchIndex, currentSportsSourceIndex);

                const sourceName = sources[currentSportsSourceIndex].source.toUpperCase();
                showStatus(`Switched to ${sourceName} (${currentSportsSourceIndex + 1}/${sources.length})`);
            } else {
                showError('Unable to switch source');
            }
        }

        // Add pulse animation for live badge
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% {
                    opacity: 1;
                    box-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
                }
                50% {
                    opacity: 0.8;
                    box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
                }
            }
        `;
        document.head.appendChild(style);

        // ============= END SPORTS STREAMING SECTION =============

        // ============= LIVE CHANNELS SECTION =============

        // All TV Channels data organized by country
        // Verified working channels only (tested on 2025-11-01)
        // Total: 68 channels across 9 countries
        const allWorldChannels = [
            // Lebanon
            { name: 'Aghani Aghani TV', url: 'https://streaming-a-1035.cdn.nextologies.com/6zj8y5nemi8a32vyjjbkv0oqx/77pcakd8reik3g8qdqnexlkmq/playlist.m3u8', category: 'Music', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/o6HSfNg.png' },            { name: 'Al Mayadeen', url: 'https://mdnlv.cdn.octivid.com/almdn/smil:mpegts.stream.smil/playlist.m3u8', category: 'News', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/GtQOKeW.png' },            { name: 'Future TV', url: 'https://live.kwikmotion.com/futurelive/ftv.smil/playlist.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.postimg.cc/43Ww9bQV/futuretv.png' },
            { name: 'LBC International', url: 'https://pwultrp.alwaysdata.net/rotana.php?channel=rlbc&.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/V6CqaVq.png' },
            { name: 'LTV', url: 'https://p-ltv.akamaized.net/ltv/ltv.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB' },            { name: 'MTV Lebanon', url: 'https://hms.pfs.gdn/v1/broadcast/mtv/playlist.m3u8', category: 'Entertainment', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/hHRkvr3.png' },            { name: 'Red TV Lebanon', url: 'https://live.kwikmotion.com/redtvlive/redtv.smil/playlist.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB' },            { name: 'Tele Liban', url: 'https://cdn.catiacast.video/abr/ed8f807e2548db4507d2a6f4ba0c4a06/playlist.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.postimg.cc/d3RWtcXq/teleliban.png' },            { name: 'Voice of Lebanon', url: 'https://svs.itworkscdn.net/vdltvlive/vdltv.smil/playlist.m3u8', category: 'News', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/f8WcqRY.png' },

            // Saudi Arabia
            { name: 'Al Arabiya Al Hadath', url: 'https://av.alarabiya.net/alarabiapublish/alhadath.smil/playlist.m3u8', category: 'News', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'Al Ekhbariya', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-al-ekhbaria/297b3ef1cd0633ad9cfba7473a686a06/index.m3u8', category: 'News', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'Al Quran Al Kareem TV', url: 'https://cdn-globecast.akamaized.net/live/eds/saudi_quran/hls_roku/index.m3u8', category: 'Religious', country: 'Saudi Arabia', countryCode: 'SA' },            { name: 'Al Saudiya', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-saudi-tv/2ad66056b51fd8c1b624854623112e43/index.m3u8', category: 'General', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'Al Sunnah Al Nabawiyah TV', url: 'https://cdn-globecast.akamaized.net/live/eds/saudi_sunnah/hls_roku/index.m3u8', category: 'Religious', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'SBC', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-sbc/90e09c0c28db26435799b4a14892a167/index.m3u8', category: 'General', country: 'Saudi Arabia', countryCode: 'SA' },

            // UAE
            { name: 'Abu Dhabi Emirates', url: 'https://vo-live-media.cdb.cdn.orange.com/Content/Channel/EmiratesChannel/HLS/index.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Abu Dhabi TV', url: 'https://vo-live-media.cdb.cdn.orange.com/Content/Channel/AbuDhabiChannel/HLS/index.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Dubai TV', url: 'https://dmieigthvllta.cdn.mgmlcdn.com/dubaitvht/smil:dubaitv.stream.smil/chunklist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Dubai Sports 1', url: 'https://dmidspta.cdn.mgmlcdn.com/dubaisports/smil:dubaisports.stream.smil/chunklist.m3u8', category: 'Sports', country: 'UAE', countryCode: 'AE' },
            { name: 'Sama Dubai', url: 'https://dmieigthvllta.cdn.mgmlcdn.com/samadubaiht/smil:samadubai.stream.smil/chunklist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Sharjah TV', url: 'https://svs.itworkscdn.net/smc1live/smc1.smil/playlist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Ajman TV', url: 'https://cdn1.logichost.in/ajmantv/live/playlist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Noor Dubai', url: 'https://dmiffthftl.cdn.mangomolo.com/noordubaitv/smil:noordubaitv.smil/chunklist.m3u8', category: 'Religious', country: 'UAE', countryCode: 'AE' },
            { name: 'CNBC Arabiya', url: 'https://cnbc-live.akamaized.net/cnbc/master.m3u8', category: 'News', country: 'UAE', countryCode: 'AE' },
            { name: 'Al Arabiya', url: 'https://live.alarabiya.net/alarabiapublish/alarabiya.smil/playlist.m3u8', category: 'News', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/NXFkYFj.png' },
            { name: 'MBC 1', url: 'https://shls-live-enc.edgenextcdn.net/out/v1/0965e4d7deae49179172426cbfb3bc5e/index.m3u8', category: 'General', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/eKLtN03.png' },
            { name: 'MBC 4', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-mbc-4/24f134f1cd63db9346439e96b86ca6ed/index.m3u8', category: 'Entertainment', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/BcXASR9.png' },
            { name: 'MBC 5', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-mbc-5/ee6b000cee0629411b666ab26cb13e9b/index.m3u8', category: 'Entertainment', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/fRWTV9F.png' },
            { name: 'MBC Drama', url: 'https://mbc1-enc.edgenextcdn.net/out/v1/b0b3a0e6750d4408bb86d703d5feffd1/index.m3u8', category: 'Entertainment', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/g5PWnqp.png' },

            // Egypt            { name: 'MBC Masr', url: 'https://mbc1-enc.edgenextcdn.net/out/v1/d5036cabf11e45bf9d0db410ca135c18/index.m3u8', category: 'General', country: 'Egypt', countryCode: 'EG' },            // Canada            { name: 'CityNews Toronto', url: 'https://citynewsregional.akamaized.net/hls/live/1024052/Regional_Live_7/master.m3u8', category: 'News', country: 'Canada', countryCode: 'CA' },
            { name: 'TSN1', url: 'https://fl1.moveonjoy.com/TSN_1/index.m3u8', category: 'Sports', country: 'Canada', countryCode: 'CA' },            { name: 'Much', url: 'https://fl1.moveonjoy.com/MUCH/index.m3u8', category: 'Music', country: 'Canada', countryCode: 'CA' },
            { name: 'CPAC', url: 'https://d7z3qjdsxbwoq.cloudfront.net/groupa/live/f9809cea-1e07-47cd-a94d-2ddd3e1351db/live.isml/.m3u8', category: 'News', country: 'Canada', countryCode: 'CA' },
            { name: 'ICI Montreal', url: 'https://amdici.akamaized.net/hls/live/873426/ICI-Live-Stream/master.m3u8', category: 'General', country: 'Canada', countryCode: 'CA' },            { name: 'Golf Channel', url: 'https://fl1.moveonjoy.com/GOLF/index.m3u8', category: 'Sports', country: 'Canada', countryCode: 'CA' },
            // UK            { name: 'BBC Two HD', url: 'https://viamotionhsi.netplus.ch/live/eds/bbc2/browser-HLS8/bbc2.m3u8', category: 'General', country: 'UK', countryCode: 'GB' },            { name: 'ITV3', url: 'https://viamotionhsi.netplus.ch/live/eds/itv3/browser-HLS8/itv3.m3u8', category: 'Entertainment', country: 'UK', countryCode: 'GB' },            { name: 'Film4 HD', url: 'https://viamotionhsi.netplus.ch/live/eds/film4/browser-HLS8/film4.m3u8', category: 'Movies', country: 'UK', countryCode: 'GB' },            { name: 'QVC UK', url: 'https://qvcuk-live.akamaized.net/hls/live/2097112/qvc/master.m3u8', category: 'Shopping', country: 'UK', countryCode: 'GB' },
            // Germany
            { name: 'Das Erste', url: 'https://derste247liveint.akamaized.net/hls/live/662735/daserste_int/master.m3u8', category: 'General', country: 'Germany', countryCode: 'DE' },            { name: 'ARD-alpha', url: 'https://brlive-lh.akamaihd.net/i/bralpha_germany@119899/master.m3u8', category: 'Education', country: 'Germany', countryCode: 'DE' },            { name: 'tagesschau 24', url: 'https://tagesschau.akamaized.net/hls/live/2020115/tagesschau/tagesschau_1/master.m3u8', category: 'News', country: 'Germany', countryCode: 'DE' },
            { name: 'WELT', url: 'https://viamotionhsi.netplus.ch/live/eds/n24/browser-HLS8/n24.m3u8', category: 'News', country: 'Germany', countryCode: 'DE' },
            { name: 'Dokusat', url: 'https://muc3.iptv-playoutcenter.de/dokusat/dokusat1/playlist.m3u8', category: 'Documentary', country: 'Germany', countryCode: 'DE' },
            { name: 'KiKA', url: 'https://kikageohls.akamaized.net/hls/live/2022693/livetvkika_de/master.m3u8', category: 'Kids', country: 'Germany', countryCode: 'DE' },            { name: 'More Than Sports TV', url: 'https://mts1.iptv-playoutcenter.de/mts/mts-web/playlist.m3u8', category: 'Sports', country: 'Germany', countryCode: 'DE' },            { name: 'WDR Fernsehen', url: 'https://wdr-live.ard-mcdn.de/wdr/live/hls/de/master.m3u8', category: 'General', country: 'Germany', countryCode: 'DE' },

            // USA
            { name: 'ABC News New York', url: 'https://content.uplynk.com/channel/ext/72750b711f704e4a94b5cfe6dc99f5e1/wabc_24x7_news.m3u8', category: 'News', country: 'USA', countryCode: 'US', logo: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/WABC_TV_New_2021.svg/512px-WABC_TV_New_2021.svg.png' },
            { name: 'CBS News New York', url: 'https://cbsn-ny.cbsnstream.cbsnews.com/out/v1/ec3897d58a9b45129a77d67aa247d136/master.m3u8', category: 'News', country: 'USA', countryCode: 'US' },
            { name: 'CBS News Chicago', url: 'https://cbsn-chi.cbsnstream.cbsnews.com/out/v1/b2fc0d5715d54908adf07f97d2616646/master.m3u8', category: 'News', country: 'USA', countryCode: 'US' },
            { name: 'CBS News Los Angeles', url: 'https://cbsn-la.cbsnstream.cbsnews.com/out/v1/57b6c4534a164accb6b1872b501e0028/master.m3u8', category: 'News', country: 'USA', countryCode: 'US' },
            { name: 'Cheddar News', url: 'https://cheddar-us.samsung.wurl.tv/playlist.m3u8', category: 'News', country: 'USA', countryCode: 'US' },            { name: 'CNBC', url: 'https://fl1.moveonjoy.com/CNBC/index.m3u8', category: 'News', country: 'USA', countryCode: 'US', logo: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e3/CNBC_logo.svg/512px-CNBC_logo.svg.png' },            { name: 'BBC America', url: 'https://bcovlive-a.akamaihd.net/7f5ec16d102f4b5d92e8e27bc95ff424/us-east-1/6240731308001/playlist.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },
            { name: 'Bravo', url: 'https://fl1.moveonjoy.com/BRAVO/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US', logo: 'https://i.imgur.com/JmTIRLF.png' },            { name: 'Comet', url: 'https://fast-channels.sinclairstoryline.com/COMET/index.m3u8', category: 'Movies', country: 'USA', countryCode: 'US' },            { name: 'CMT', url: 'https://fl1.moveonjoy.com/CMT/index.m3u8', category: 'Music', country: 'USA', countryCode: 'US' },
            { name: 'Antenna TV', url: 'https://fl1.moveonjoy.com/Antenna_TV/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },            { name: 'Buzzr', url: 'https://fl1.moveonjoy.com/Buzzr/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },
            { name: 'Aspire', url: 'https://fl1.moveonjoy.com/Aspire/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },            { name: 'CBS Sports Network', url: 'https://fl1.moveonjoy.com/CBS_SPORTS_NETWORK/index.m3u8', category: 'Sports', country: 'USA', countryCode: 'US', logo: 'https://i.imgur.com/A8CnA8g.png' },
            { name: 'ACC Network', url: 'https://fl1.moveonjoy.com/ACC_NETWORK/index.m3u8', category: 'Sports', country: 'USA', countryCode: 'US' },
            { name: 'AXS TV', url: 'https://fl1.moveonjoy.com/Axs_TV/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },
            { name: '3ABN Kids', url: 'https://3abn.bozztv.com/3abn2/Kids_live/smil:Kids_live.smil/playlist.m3u8', category: 'Kids', country: 'USA', countryCode: 'US' },
            { name: 'Baby Shark TV', url: 'https://newidco-babysharktv-1-eu.rakuten.wurl.tv/playlist.m3u8', category: 'Kids', country: 'USA', countryCode: 'US' },
            { name: 'BabyFirst', url: 'https://streams2.sofast.tv/v1/master/611d79b11b77e2f571934fd80ca1413453772ac7/c8d16110-566c-4e95-a1df-55d175e9e201/manifest.m3u8', category: 'Kids', country: 'USA', countryCode: 'US' },            { name: 'Catholic TV', url: 'https://catholictvhd-lh.akamaized.net/hls/live/2043390/CTVLiveHD/master.m3u8', category: 'Religious', country: 'USA', countryCode: 'US' }
        ];

        let allChannels = [];
        let currentDisplayedChannels = [];
        let selectedCountry = 'All';

        // Load live channels
        function loadLiveChannels() {
            allChannels = [...allWorldChannels];
            selectedCountry = 'All';
            currentDisplayedChannels = [...allChannels];
            displayLiveChannels(currentDisplayedChannels);
            populateCountryFilter();
        }

        // Populate country filter dropdown
        function populateCountryFilter() {
            const countries = ['Favourites', 'All', ...new Set(allChannels.map(ch => ch.country))].sort((a, b) => {
                // Keep Favourites first, All second, then alphabetical
                if (a === 'Favourites') return -1;
                if (b === 'Favourites') return 1;
                if (a === 'All') return -1;
                if (b === 'All') return 1;
                return a.localeCompare(b);
            });
            const container = document.getElementById('countryFilterButtons');
            if (!container) return;

            container.innerHTML = countries.map(country => {
                const isActive = country === selectedCountry ? 'active' : '';
                const icon = country === 'Favourites' ? '' : '';
                return `<button class="bg-animation-toggle ${isActive}" onclick="filterByCountry('${country}')" id="country_${country.replace(/\s+/g, '_')}">
                    ${icon} ${country}
                </button>`;
            }).join('');
        }

        // Filter channels by country
        function filterByCountry(country) {
            selectedCountry = country;

            // Update button states
            document.querySelectorAll('#countryFilterButtons .bg-animation-toggle').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`country_${country.replace(/\s+/g, '_')}`);
            if (activeBtn) activeBtn.classList.add('active');

            // Filter channels
            if (country === 'Favourites') {
                currentDisplayedChannels = channelFavourites;
            } else if (country === 'All') {
                currentDisplayedChannels = [...allChannels];
            } else {
                currentDisplayedChannels = allChannels.filter(ch => ch.country === country);
            }

            // Clear search when changing country
            const searchInput = document.getElementById('channelsSearchInput');
            const clearBtn = document.getElementById('clearChannelsSearchBtn');
            if (searchInput) searchInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';

            displayLiveChannels(currentDisplayedChannels);
        }

        // Display channels in the grid
        function displayLiveChannels(channels) {
            const container = document.getElementById('liveChannels');

            if (!channels || channels.length === 0) {
                container.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 60px 20px; color: #666;">
                        <h3 style="font-size: 24px; margin-bottom: 12px; color: #00d9ff;">No channels available</h3>
                        <p style="font-size: 18px;">Check back later for live channels</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = channels.map((channel, index) => createChannelCard(channel, index)).join('');
        }

        // Create a channel card
        function createChannelCard(channel, index) {
            // Get category color
            const categoryColors = {
                'News': '#ff0000',
                'General': '#00d9ff',
                'Music': '#ff00ff',
                'Entertainment': '#00ff9f',
                'Sports': '#ffaa00',
                'Religious': '#9d00ff',
                'Kids': '#ff69b4',
                'Education': '#00bfff',
                'Documentary': '#ffa500',
                'Shopping': '#32cd32',
                'Movies': '#dc143c'
            };
            const categoryColor = categoryColors[channel.category] || '#00d9ff';

            // Country flag emojis
            const countryFlags = {
                'LB': '',
                'SA': '',
                'AE': '',
                'EG': '',
                'CA': '',
                'GB': '',
                'DE': '',
                'US': ''
            };
            const flag = countryFlags[channel.countryCode] || '';

            // Check if channel is in favourites
            const isFavourited = channelFavourites.some(fav => fav.name === channel.name && fav.url === channel.url);

            return `
                <div class="content-card" onclick='playChannel(${index})' style="--accent-color: ${categoryColor}; --primary-color: #00ff9f;">
                    <button type="button" class="watchlist-btn ${isFavourited ? 'added' : ''}"
                            onclick="event.stopPropagation(); event.preventDefault(); toggleChannelFavourite(${index}); return false;"
                            title="${isFavourited ? 'Remove from Favourites' : 'Add to Favourites'}">
                        ${isFavourited ? '' : ''}
                    </button>
                    <div class="content-type-badge" style="background: rgba(255,0,0,0.9); border-color: #ff0000; animation: pulse 2s infinite;">
                         LIVE
                    </div>

                    <div class="content-poster" style="padding: 20px; min-height: 300px; display: flex; flex-direction: column; justify-content: center; background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);">
                        <div style="text-align: center; margin-bottom: 16px;">
                            <div style="color: ${categoryColor}; font-size: 18px; margin-bottom: 8px; text-transform: uppercase; font-weight: bold;">
                                ${channel.category}
                            </div>
                        </div>

                        <div style="text-align: center; margin: 20px 0;">
                            ${channel.logo ? `
                                <img src="${channel.logo}"
                                     alt="${channel.name}"
                                     style="max-width: 120px; max-height: 80px; margin-bottom: 12px; object-fit: contain; filter: drop-shadow(0 0 10px ${categoryColor});"
                                     onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                                <div style="font-size: 32px; margin-bottom: 8px; display: none;"></div>
                            ` : `
                                <div style="font-size: 32px; margin-bottom: 8px;"></div>
                            `}
                            <div style="font-size: 24px; font-weight: bold; color: #00ff9f; margin-bottom: 8px;">
                                ${channel.name}
                            </div>
                        </div>

                        <div style="text-align: center; margin-top: auto;">
                            <div style="display: inline-block; padding: 8px 16px; background: rgba(0, 255, 159, 0.1); border: 2px solid ${categoryColor}; border-radius: 4px; color: ${categoryColor}; font-size: 16px;">
                                ${flag} ${channel.country}
                            </div>
                        </div>
                    </div>

                    <div class="content-info">
                        <h3 class="content-title" style="color: #00ff9f;">${channel.name}</h3>
                        <p class="content-meta" style="color: ${categoryColor};">${channel.category}  ${channel.country}</p>
                    </div>
                </div>
            `;
        }

        // Search channels
        function searchChannels() {
            const searchInput = document.getElementById('channelsSearchInput');
            const clearBtn = document.getElementById('clearChannelsSearchBtn');
            const query = searchInput.value.toLowerCase().trim();

            // Show/hide clear button
            if (clearBtn) {
                clearBtn.style.display = query ? 'block' : 'none';
            }

            // Start with channels filtered by country or favourites
            let baseChannels;
            if (selectedCountry === 'Favourites') {
                baseChannels = channelFavourites; // Use global variable loaded from DB
            } else if (selectedCountry === 'All') {
                baseChannels = allChannels;
            } else {
                baseChannels = allChannels.filter(ch => ch.country === selectedCountry);
            }

            if (!query) {
                currentDisplayedChannels = baseChannels;
                displayLiveChannels(baseChannels);
                return;
            }

            // Filter channels by name, category, or country
            const filteredChannels = baseChannels.filter(channel =>
                channel.name.toLowerCase().includes(query) ||
                channel.category.toLowerCase().includes(query) ||
                channel.country.toLowerCase().includes(query)
            );

            currentDisplayedChannels = filteredChannels;
            displayLiveChannels(filteredChannels);
        }

        // Clear channels search
        function clearChannelsSearch() {
            const searchInput = document.getElementById('channelsSearchInput');
            const clearBtn = document.getElementById('clearChannelsSearchBtn');

            if (searchInput) searchInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';

            // Respect country filter when clearing search
            if (selectedCountry === 'Favourites') {
                currentDisplayedChannels = channelFavourites; // Use global variable loaded from DB
            } else if (selectedCountry === 'All') {
                currentDisplayedChannels = allChannels;
            } else {
                currentDisplayedChannels = allChannels.filter(ch => ch.country === selectedCountry);
            }
            displayLiveChannels(currentDisplayedChannels);
        }

        // Toggle channel favourite
        async function toggleChannelFavourite(channelIndex) {
            const channel = currentDisplayedChannels[channelIndex];
            if (!channel) return;

            // Require authentication - no localStorage fallback
            if (!authToken) {
                showError('Please login to save favorites');
                showLoginModal();
                return;
            }

            // Use database only - don't redeclare, use the global variable
            const existingIndex = channelFavourites.findIndex(fav => fav.name === channel.name);

            try {
                if (existingIndex > -1) {
                    // Remove from favourites
                    await removeFromFavoritesAPI(channel.url || channel.name);
                } else {
                    // Add to favourites
                    await addToFavoritesAPI(channel.url || channel.name, channel.name);
                }

                // Reload favorites from database
                await loadFavorites();

                // Refresh the display - if on Favourites view, update currentDisplayedChannels
                if (selectedCountry === 'Favourites') {
                    currentDisplayedChannels = channelFavourites;
                }
                displayLiveChannels(currentDisplayedChannels);
            } catch (error) {
                console.error('Failed to update favorites:', error);
                showError('Failed to update favorites');
            }
        }

        // Play a channel
        function playChannel(channelIndex) {
            const channel = currentDisplayedChannels[channelIndex];
            if (!channel) {
                showError('Channel not found');
                return;
            }

            console.log('Playing channel:', channel);

            // Update current content info
            currentContentId = channelIndex;
            currentContentType = 'channel';
            currentContentTitle = channel.name;

            // Show the player section
            const playerSection = document.getElementById('playerSection');
            const currentContent = document.getElementById('currentContent');
            if (playerSection) playerSection.style.display = 'block';
            if (currentContent) currentContent.style.display = 'block';

            // Hide TV controls
            const tvControls = document.getElementById('tvControls');
            if (tvControls) tvControls.style.display = 'none';

            // Hide OMDB details
            const omdbDetails = document.getElementById('omdbDetails');
            const omdbRatings = document.getElementById('omdbRatings');
            if (omdbDetails) omdbDetails.style.display = 'none';
            if (omdbRatings) omdbRatings.style.display = 'none';

            // Hide sports source button
            const sportsSourceBtn = document.getElementById('sportsSourceBtn');
            if (sportsSourceBtn) sportsSourceBtn.style.display = 'none';

            // Hide video source button
            const sourceMenuContainer2 = document.getElementById('sourceMenuContainer');
            if (sourceMenuContainer2) sourceMenuContainer2.style.display = 'none';

            // Hide source hint
            dismissSourceHint();

            // Hide next episode button
            const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
            if (nextEpisodeBtn) nextEpisodeBtn.style.display = 'none';

            // Update content info display
            const titleEl = document.getElementById('currentTitle');
            const yearEl = document.getElementById('currentYear');
            const overviewEl = document.getElementById('currentOverview');
            const posterEl = document.getElementById('currentPoster');

            if (titleEl) titleEl.textContent = channel.name;
            if (yearEl) yearEl.textContent = `${channel.category}  ${channel.country} TV - Live Now`;
            if (overviewEl) overviewEl.textContent = `Watch ${channel.name} live from ${channel.country}`;

            // Set backdrop
            const backdropImage = document.getElementById('backdropImage');
            if (backdropImage) {
                backdropImage.style.backgroundImage = 'linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%)';
            }

            // Hide poster for channels
            if (posterEl) {
                posterEl.style.display = 'none';
            }

            // Load the stream - use HLS.js for m3u8 streams
            loadChannelStream(channel.url);

            // Scroll to player
            if (currentContent) {
                currentContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            showStatus(`Loading ${channel.name}...`);
        }

        // Load channel stream using HLS.js
        function loadChannelStream(streamUrl) {
            const playerIframe = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');
            const placeholder = document.getElementById('playerPlaceholder');

            // Hide iframe and placeholder
            if (playerIframe) playerIframe.style.display = 'none';
            if (placeholder) placeholder.style.display = 'none';

            // Show video element and stop button
            if (playerVideo) {
                playerVideo.style.display = 'block';
                const stopBtn = document.getElementById('stopBtn');
                if (stopBtn) stopBtn.style.display = 'inline-block';

                // Check if HLS.js is supported
                if (Hls.isSupported()) {
                    // Destroy existing HLS instance if any
                    if (window.hls) {
                        window.hls.destroy();
                    }

                    // Create new HLS instance
                    window.hls = new Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });

                    // Load the source
                    window.hls.loadSource(streamUrl);
                    window.hls.attachMedia(playerVideo);

                    // Handle events
                    window.hls.on(Hls.Events.MANIFEST_PARSED, function() {
                        playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                    });

                    // Add watchparty sync listeners for live channels
                    setupVideoSyncListeners(playerVideo);

                    window.hls.on(Hls.Events.ERROR, function(event, data) {
                        console.error('HLS error:', data);
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    showError('Network error - trying to recover...');
                                    window.hls.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    showError('Media error - trying to recover...');
                                    window.hls.recoverMediaError();
                                    break;
                                default:
                                    showError('Fatal error - cannot play this stream');
                                    window.hls.destroy();
                                    break;
                            }
                        }
                    });
                }
                // Check if the browser supports HLS natively (Safari)
                else if (playerVideo.canPlayType('application/vnd.apple.mpegurl')) {
                    playerVideo.src = streamUrl;
                    playerVideo.addEventListener('loadedmetadata', function() {
                        playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                    });

                    // Add watchparty sync listeners for live channels
                    setupVideoSyncListeners(playerVideo);
                } else {
                    showError('HLS playback not supported in this browser');
                }
            }
        }

        // ============= END LIVE CHANNELS SECTION =============

        // ============= AUTHENTICATION & API SYSTEM =============

        // Automatically detect API base URL based on environment
        const AUTH_API_BASE_URL = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
            ? 'http://localhost:5001/api'  // Local development
            : `${window.location.origin}/api`;  // Production (same origin)

        let authToken = localStorage.getItem('authToken');
        window.authToken = authToken;  // Set globally for rating system
        let currentUser = null;
        try {
            const storedUser = localStorage.getItem('currentUser');
            if (storedUser) {
                currentUser = JSON.parse(storedUser);
                window.currentUser = currentUser;  // Set globally for rating system
            }
        } catch(e) {
            console.error('Failed to load currentUser from localStorage:', e);
        }

        // API Helper Function
        async function apiRequest(endpoint, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            const url = `${AUTH_API_BASE_URL}${endpoint}`;
            console.log('[API] Request:', options.method || 'GET', url);
            console.log('[API] Headers:', headers);

            try {
                const response = await fetch(url, {
                    ...options,
                    headers
                });

                console.log('[API] Response status:', response.status);

                if (response.status === 401) {
                    // Token expired or invalid
                    console.log('[API] 401 Unauthorized - logging out');
                    logout();
                    throw new Error('Authentication required');
                }

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'API request failed');
                }

                return data;
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        // Modal Functions - exposed to global scope for onclick handlers
        window.showLoginModal = function() {
            console.log('[showLoginModal] Opening login modal');
            document.getElementById('loginModal').style.display = 'flex';
            document.getElementById('loginError').style.display = 'none';
        }

        window.closeLoginModal = function() {
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('loginForm').reset();
        }

        window.showRegisterModal = function() {
            document.getElementById('registerModal').style.display = 'flex';
            document.getElementById('registerError').style.display = 'none';
        }

        window.closeRegisterModal = function() {
            document.getElementById('registerModal').style.display = 'none';
            document.getElementById('registerForm').reset();
        }

        window.showFriendsModal = function() {
            document.getElementById('friendsModal').style.display = 'block';
            loadFriends();
            loadFriendRequests();
        }

        window.closeFriendsModal = function() {
            document.getElementById('friendsModal').style.display = 'none';
        }

        // Friend Request Notifications
        let pendingFriendRequests = [];

        async function fetchPendingFriendRequests() {
            if (!authToken) {
                console.log('[Friend Requests] No auth token, skipping fetch');
                return;
            }

            try {
                console.log('[Friend Requests] Fetching pending requests...');
                const requests = await apiRequest('/friends/requests', { method: 'GET' });
                console.log('[Friend Requests] Received:', requests);
                pendingFriendRequests = requests || [];
                console.log('[Friend Requests] Count:', pendingFriendRequests.length);
                updateFriendRequestNotification();
            } catch (error) {
                console.error('[Friend Requests] Failed to fetch:', error);
                pendingFriendRequests = [];
                updateFriendRequestNotification();
            }
        }

        function updateFriendRequestNotification() {
            const countElement = document.getElementById('friendRequestCount');
            const count = pendingFriendRequests.length;

            console.log('[Friend Requests] Updating count - count:', count, 'element:', !!countElement);

            if (countElement) {
                if (count > 0) {
                    countElement.textContent = `(+${count})`;
                    countElement.style.display = 'inline';
                    console.log('[Friend Requests] Count shown:', count);
                } else {
                    countElement.style.display = 'none';
                    console.log('[Friend Requests] Count hidden (no requests)');
                }
            } else {
                console.error('[Friend Requests] Count element not found!');
            }
        }

        // No longer need dropdown functionality - count shows on Friends button
        // When user clicks Friends button, modal opens showing all pending requests

        // Poll for friend requests every 30 seconds
        setInterval(fetchPendingFriendRequests, 30000);

        // Expose for testing
        window.testFriendNotification = fetchPendingFriendRequests;

        // Close modals on outside click
        document.getElementById('loginModal')?.addEventListener('click', function(e) {
            if (e.target === this) closeLoginModal();
        });
        document.getElementById('registerModal')?.addEventListener('click', function(e) {
            if (e.target === this) closeRegisterModal();
        });

        // Authentication Handlers
        async function handleLogin(event) {
            event.preventDefault();
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;
            const errorEl = document.getElementById('loginError');

            try {
                const data = await apiRequest('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ username, password })
                });

                authToken = data.access_token;
                window.authToken = authToken;  // Set globally for rating system
                localStorage.setItem('authToken', authToken);
                currentUser = data.user;
                window.currentUser = currentUser;  // Set globally for rating system
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

                closeLoginModal();
                updateAuthUI();
                await loadUserData();
                showStatus('Logged in successfully!');
            } catch (error) {
                errorEl.textContent = error.message;
                errorEl.style.display = 'block';
            }
        }

        async function handleRegister(event) {
            event.preventDefault();
            const username = document.getElementById('registerUsername').value;
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const errorEl = document.getElementById('registerError');

            try {
                const data = await apiRequest('/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ username, email, password })
                });

                authToken = data.access_token;
                window.authToken = authToken;  // Set globally for rating system
                localStorage.setItem('authToken', authToken);
                currentUser = data.user;
                window.currentUser = currentUser;  // Set globally for rating system
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

                closeRegisterModal();
                updateAuthUI();
                await loadUserData();
                showStatus('Account created successfully!');
            } catch (error) {
                errorEl.textContent = error.message;
                errorEl.style.display = 'block';
            }
        }

        window.logout = function() {
            authToken = null;
            window.authToken = null;  // Clear global token
            currentUser = null;
            window.currentUser = null;  // Clear global user
            localStorage.removeItem('authToken');
            localStorage.removeItem('currentUser');

            // Clear database-loaded data from memory
            watchlists = JSON.parse(localStorage.getItem('streamingSite_watchlists') || '{"My Watchlist": []}');
            watchHistory = JSON.parse(localStorage.getItem('streamingSite_watchHistory') || '[]');

            // Stop comments polling
            if (commentsPollingInterval) {
                clearInterval(commentsPollingInterval);
                commentsPollingInterval = null;
            }

            // Hide comments section
            hideCommentsSection();

            // Don't auto-switch to any tab - let user choose
            // Reset current tab
            currentTab = null;
            // Hide all sections
            document.getElementById('contentResults').style.display = 'none';
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            document.getElementById('sportsDisplay').style.display = 'none';
            document.getElementById('channelsDisplay').style.display = 'none';
            // Remove active tab styling
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            updateAuthUI();
            showStatus('Logged out successfully');
        }

        function updateAuthUI() {
            const authButtons = document.getElementById('authButtons');
            const userMenu = document.getElementById('userMenu');
            const usernameDisplay = document.getElementById('usernameDisplay');
            const userMenuBtn = document.getElementById('userMenuBtn');
            const userMenuDropdown = document.getElementById('userMenuDropdown');
            const userMenuText = document.getElementById('userMenuText');
            const userMenuIcon = document.getElementById('userMenuIcon');

            if (authToken && currentUser) {
                // Hide old buttons
                authButtons.style.display = 'none';
                userMenu.style.display = 'none';
                usernameDisplay.textContent = currentUser.username;

                // Update new user menu
                userMenuBtn.classList.add('logged-in');
                userMenuText.textContent = currentUser.username;
                userMenuText.style.display = 'inline';

                // Update icon size for logged in state (20x20)
                userMenuIcon.style.width = '20px';
                userMenuIcon.style.height = '20px';

                // Populate dropdown for logged-in user
                userMenuDropdown.innerHTML = `
                    <div class="user-menu-username">@${currentUser.username}</div>
                    <button class="user-menu-item" onclick="showFriendsModal(); closeUserMenu();">
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAABaAAAAAQAAAFoAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAABSgAwAEAAAAAQAAABQAAAAAeyom9gAAAAlwSFlzAAAN1wAADdcBQiibeAAAAWRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHhtcDpDcmVhdG9yVG9vbD53d3cuaW5rc2NhcGUub3JnPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgqyyWIhAAACrUlEQVQ4EeVSW0tUURT+zmVGR2siK1EyKkwlerBApeghIYssXx2kt0jtIiISEtWTBtZDLxIEXR4KQfCSUC+KRkUlRQgmCg5OWqHOeM3LONOcOWf2aa1xDkww4Q9wDWv2Pnt/+1vrW2sBW86kOMUq7TvJd8adhWlfQf47dpZGazu5PfbNC9+Vkxv8wSRs++x2e21d/c2ylMgnFaFJQFIQiZh40j7dNL+ktzAoPT2jrvrq9RJl/DmwNgUoCoKaabS81ZrDBh4SZEolK87Ozi7Kzc1taLpVjmRTA9YpcckGhAV+ekM1QyOry0jJw7H8vJq7taXAQA+wuEDp2BBaF6p7TjSMz0UWJxbFV5ZslpScRn9/F/CjkhJnBQp5zFJVuC5/AZxl6HjRCLSeACIUVJItBECxzzzw482YsSHZDI5SsteIzE+gODJ+QrJNOQmYeA28GgSE/i8ZYwRlZfIG2AhjUu0NksA3CY2E6AEg4Et4G38Yy5uVx0mIR1h7iTDUqM0syiIzn43/EpgqQSZAFPM/PjqP3tNzWVVROjWr3XZVD0OjrsJGMbgeCgUgssr6Ebi/rze7F0Rz5TOSzaSWGBo6zTDhehTAzIq4k6TgvGoY6HVPBlbJcWBvMqoqspBzKBU+7x88bptB60sfwoYY4NzdsxqynBKunEpGZpoEj0/g6UcNnYM8/3hH/ll1OHB8f4ajwOm0o+fDEi4U70bO4W1YXtHR3TeP/CPbEQjoR+EPITVFRvc3Ha6CJGTukeFdEegZ1VF0UMWqJgq9ywIS1do8e3IXersKqdOx3nM8yxwKLl4aAqYX0HZjBw17AgyV4dz9NfTxHPL8eH4F0XjPQ1OzAbaeRNukyhgeo/n0CzR2BGkuucQWghpPP66pZ15EZ5HfvLeS2WSN8m+C2YrXfwHqzfa7JgSB/AAAAABJRU5ErkJggg==" alt="Friends" style="width: 20px; height: 20px; image-rendering: pixelated; margin-right: 8px;"> Friends
                    </button>
                    <div class="user-menu-divider"></div>
                    <button class="user-menu-item" onclick="logout(); closeUserMenu();">
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAFKADAAQAAAABAAAAFAAAAACy3fD9AAADg0lEQVQ4EaVVTYgcRRR+r7pqpnvazE7CsEYlJKgx4AYUjGhEMIO5+Ee8mNy8ikTxIMRDLnuRePIgmIPgxYsECYIGPewhS1A8yLpEnEXYRXc37qxuZzIz6253T3dVPV/N7vzsQA6SOnS991XVV/V+G1dX62eyLP3LoBCgEY0xQqNGstZKkAS9gYxoLCCitZ6VkghZc7MbbouUntUajsHa2u/Hdg7d+3dpaf45qbUn+1RH5q9XNBbDvj4+W93tNk7Ubo/jfZ0NEEyW9XVItfcxBuoFSLsdBxJaiUiKRYHK8wBh/dT16dpsbVoPDo0JMs81DjEq2078ZbeDZRK4ybf97Cn9G4S0JYQ+LAA/iaLHxXD/XolfiKLvVLdEBnMUsF9VvXeLB9VFcVBd7cZ4duPZ0/9Akm0AkdlLsVfLmUy4aPVhSyySYJByYXPwimwmYNmtG0KOKfhO5nlwxumDoTlXtDBDEzJOC8N7c0esgECBtTtpEZ18euO2v++L+tk38n+/qj7W+rr6/oBoV3BpJAsjKDERCne5EGLbLJLuZiCkx4mm1l587cxDR6PN1rR4SzdKR4JqdqH9/YSqvNT5qE+BqHCQMg60mgPJ79UFmb155Yfv7l9vygtvv97kJd+0g0/NnQf2hSYBihVkWwkEufiwfaWAlXPRJXfeFYV0me8UN2jXeo+T8VrtyQdVlsRBqg+4pbRZvBNlSmpVRK/iC/8RVfBjX3Qb8jBA1Dsv+XmyMGKz859jFznZqFJ5BfxJI/9uXWYobsTh6R/VZHlqsbFVnaLjYYRXoyX4/ObsE+8B3OwRsreJK2UkKJbtdfEwyPHGElnOabaAIQszF5NKa/tS+9TMueUTN+5rLoafrSw8c/5l2Jvkwwj37mD/G+DGICR5nCFewI6Bnp8nt5t+KbCHnpp71ftzzi7MLBx6pzZGhvwKOSw8ZrQkLFeI0Hae4nQB8uwnj8y37i5r8phsUaerf2ANZlOAWQePDe5PowhaEYAsPm/ztM54GzN6FEsTH1Sv/SIxgYpV3f3+w63dljZ6ckfu+VDt9jMH2ax7WQp5nJxfkUuGMW6A7FP2K3AFafPN3I31u5YfeZwxKyv1qR3+e/8uL/960gXlrib83ytco5FK+aVbt+oH4jjheuNegR4mSYLg2uw2QBAEtLnZoXJ5gn8Sgj1gew/oy9yAKAzDHpZluvQfgFKf8NDtjCEAAAAASUVORK5CYII=" alt="Logout" style="width: 20px; height: 20px; image-rendering: pixelated; margin-right: 8px;"> Logout
                    </button>
                `;
            } else {
                // Hide old buttons
                authButtons.style.display = 'none';
                userMenu.style.display = 'none';

                // Update new user menu
                userMenuBtn.classList.remove('logged-in');
                userMenuText.textContent = '';
                userMenuText.style.display = 'none';

                // Update icon size for logged out state (30x30)
                userMenuIcon.style.width = '30px';
                userMenuIcon.style.height = '30px';

                // Populate dropdown for guest user
                userMenuDropdown.innerHTML = `
                    <button class="user-menu-item" onclick="showLoginModal(); closeUserMenu();">
                        <img src="data:image/png;base64,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" alt="Login" style="width: 20px; height: 20px; image-rendering: pixelated; margin-right: 8px;"> Login
                    </button>
                    <button class="user-menu-item" onclick="showRegisterModal(); closeUserMenu();">
                        <span></span> Sign Up
                    </button>
                `;
            }
        }

        // User Menu Toggle Functions
        window.toggleUserMenu = function() {
            const dropdown = document.getElementById('userMenuDropdown');
            dropdown.classList.toggle('show');
        };

        window.closeUserMenu = function() {
            const dropdown = document.getElementById('userMenuDropdown');
            dropdown.classList.remove('show');
        };

        // Close user menu when clicking outside
        document.addEventListener('click', function(event) {
            const userMenuContainer = document.querySelector('.user-menu-container');
            const dropdown = document.getElementById('userMenuDropdown');
            if (userMenuContainer && !userMenuContainer.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // Load user data on page load
        async function loadUserData() {
            if (!authToken) {
                console.log('[Auth] No auth token found, skipping user data load');
                return;
            }

            console.log('[Auth] Loading user data...');
            try {
                currentUser = await apiRequest('/auth/me');
                console.log('[Auth] User authenticated:', currentUser.username);
                updateAuthUI();

                await Promise.all([
                    loadWatchlist(),
                    loadContinueWatching(),
                    loadFavorites(),
                    fetchPendingFriendRequests()
                ]);

                console.log('[Auth] User data loaded successfully');
                // Don't auto-switch to any tab - let user choose
            } catch (error) {
                console.error('[Auth] Failed to load user data:', error);
                if (error.message && error.message.includes('401')) {
                    console.log('[Auth] Token expired or invalid, clearing auth');
                    // Token is invalid, clear it
                    authToken = null;
                    localStorage.removeItem('authToken');
                    updateAuthUI();
                }
            }
        }

        // Watchlist Functions
        async function loadWatchlist() {
            if (!authToken) return;

            try {
                const watchlist = await apiRequest('/watchlist');
                console.log('[Watchlist] Loaded from database:', watchlist);
                console.log('[Watchlist] Is array?', Array.isArray(watchlist), 'Length:', watchlist?.length);

                // Only update if API call was successful (database is source of truth)
                // Don't clear existing data until we have the DB response
                if (watchlist && watchlist.length > 0) {
                    // Organize items by list_name
                    watchlists = {};
                    watchlist.forEach(item => {
                        const listName = item.list_name || 'My Watchlist';
                        if (!watchlists[listName]) {
                            watchlists[listName] = [];
                        }
                        watchlists[listName].push({
                            id: item.content_id,
                            type: item.content_type,
                            title: item.title,
                            posterUrl: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : 'https://via.placeholder.com/500x750/333/fff?text=No+Poster'
                        });
                    });
                    console.log('[Watchlist] Updated with DB data, lists:', Object.keys(watchlists));
                } else if (watchlist && watchlist.length === 0) {
                    // API returned successfully but empty - user has no watchlist items
                    watchlists = { 'My Watchlist': [] };
                    console.log('[Watchlist] DB returned empty, cleared watchlist');
                }
                // If watchlist is null/undefined (API error), keep existing data

                // Update UI if watchlist tab is active
                const watchlistTab = document.querySelector('[onclick*="watchlist"]');
                if (watchlistTab && watchlistTab.classList.contains('active')) {
                    displayWatchlistInResults();
                }
            } catch (error) {
                console.error('[Watchlist] Failed to load:', error);
                // Don't clear existing data on error - keep localStorage data
            }
        }

        async function addToWatchlistAPI(contentId, contentType, title, posterPath, listName = 'My Watchlist') {
            if (!authToken) {
                showLoginModal();
                return;
            }

            try {
                // Extract just the path if it's a full URL
                let posterPathOnly = posterPath;
                if (posterPath && posterPath.includes('image.tmdb.org')) {
                    // Extract path from: https://image.tmdb.org/t/p/w500/abc.jpg -> /abc.jpg
                    const match = posterPath.match(/\/t\/p\/w\d+(\/.+)/);
                    if (match) posterPathOnly = match[1];
                }

                console.log('[Watchlist] Adding to DB:', {
                    content_id: contentId,
                    content_type: contentType,
                    title: title,
                    poster_path: posterPathOnly,
                    list_name: listName
                });

                const result = await apiRequest('/watchlist', {
                    method: 'POST',
                    body: JSON.stringify({
                        content_id: contentId,
                        content_type: contentType,
                        title: title,
                        poster_path: posterPathOnly,
                        list_name: listName
                    })
                });
                console.log('[Watchlist] Added successfully:', result);
                showStatus(`Added to ${listName}!`);
                await loadWatchlist();
            } catch (error) {
                console.error('[Watchlist] Failed to add:', error);
                showError(error.message);
            }
        }

        async function removeFromWatchlistAPI(contentId) {
            if (!authToken) return;

            try {
                await apiRequest(`/watchlist/${contentId}`, { method: 'DELETE' });
                showStatus('Removed from watchlist');
                await loadWatchlist();
            } catch (error) {
                showError(error.message);
            }
        }

        // Continue Watching Functions
        async function loadContinueWatching() {
            if (!authToken) return;

            try {
                const items = await apiRequest('/continue-watching');
                console.log('[Continue Watching] Loaded from database:', items);
                console.log('[Continue Watching] Is array?', Array.isArray(items), 'Length:', items?.length);

                // Only update if API call was successful (database is source of truth)
                // Don't clear existing data until we have the DB response
                if (items && items.length > 0) {
                    watchHistory = items.map(item => ({
                        id: item.content_id,
                        type: item.content_type,
                        title: item.title,
                        posterUrl: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : 'https://via.placeholder.com/200x300/333/fff?text=No+Poster',
                        progress: item.progress || 0,
                        lastWatched: item.last_watched || new Date().toISOString(),
                        year: item.year || new Date().getFullYear(),
                        season: item.season || 1,
                        episode: item.episode || 1
                    }));
                    console.log('[Continue Watching] Updated with DB data, now has', watchHistory.length, 'items');
                } else if (items && items.length === 0) {
                    // API returned successfully but empty - user has no continue watching items
                    watchHistory = [];
                    console.log('[Continue Watching] DB returned empty, cleared history');
                }
                // If items is null/undefined (API error), keep existing data

                // Update UI if continue watching tab is active
                displayContinueWatchingInResults();
            } catch (error) {
                console.error('[Continue Watching] Failed to load:', error);
                // Don't clear existing data on error - keep localStorage data
            }
        }

        async function updateContinueWatchingAPI(contentId, contentType, title, posterPath, progress, season, episode) {
            if (!authToken) return;

            try {
                // Extract just the path if it's a full URL
                let posterPathOnly = posterPath;
                if (posterPath && posterPath.includes('image.tmdb.org')) {
                    const match = posterPath.match(/\/t\/p\/w\d+(\/.+)/);
                    if (match) posterPathOnly = match[1];
                } else if (posterPath && posterPath.includes('placeholder')) {
                    posterPathOnly = null; // Don't save placeholder URLs
                }

                console.log('[Continue Watching] Updating in DB:', {
                    content_id: contentId,
                    content_type: contentType,
                    title: title,
                    poster_path: posterPathOnly,
                    progress: progress,
                    season: season,
                    episode: episode
                });

                const result = await apiRequest('/continue-watching', {
                    method: 'POST',
                    body: JSON.stringify({
                        content_id: contentId,
                        content_type: contentType,
                        title: title,
                        poster_path: posterPathOnly,
                        progress: progress,
                        season: season,
                        episode: episode
                    })
                });
                console.log('[Continue Watching] Updated successfully:', result);
            } catch (error) {
                console.error('[Continue Watching] Failed to update:', error);
            }
        }

        // Favorites Functions
        async function loadFavorites() {
            if (!authToken) return;

            try {
                const favorites = await apiRequest('/favorites');
                console.log('Favorites loaded from database:', favorites);

                // Update global variable - database is source of truth
                channelFavourites = [];

                if (favorites && favorites.length > 0) {
                    favorites.forEach(fav => {
                        channelFavourites.push({
                            name: fav.channel_name,
                            url: fav.channel_id,
                            id: fav.channel_id
                        });
                    });
                }

                // Refresh live channels display if on that tab
                const liveChannelsTab = document.querySelector('[onclick*="live-channels"]');
                if (liveChannelsTab && liveChannelsTab.classList.contains('active')) {
                    // Redisplay current channels to show updated favorites
                    if (typeof currentDisplayedChannels !== 'undefined' && currentDisplayedChannels) {
                        displayLiveChannels(currentDisplayedChannels);
                    }
                }
            } catch (error) {
                console.error('Failed to load favorites:', error);
            }
        }

        async function addToFavoritesAPI(channelId, channelName) {
            if (!authToken) {
                showLoginModal();
                return;
            }

            try {
                await apiRequest('/favorites', {
                    method: 'POST',
                    body: JSON.stringify({
                        channel_id: channelId,
                        channel_name: channelName
                    })
                });
                showStatus('Added to favorites!');
                await loadFavorites();
            } catch (error) {
                showError(error.message);
            }
        }

        async function removeFromFavoritesAPI(channelId) {
            if (!authToken) return;

            try {
                await apiRequest(`/favorites/${channelId}`, { method: 'DELETE' });
                showStatus('Removed from favorites');
                await loadFavorites();
            } catch (error) {
                showError(error.message);
            }
        }

        // Friends Functions
        // Store friends list globally for checking status
        let currentFriendsList = [];

        async function loadFriends() {
            console.log('[Friends] loadFriends called, authToken:', !!authToken);
            if (!authToken) return;

            try {
                console.log('[Friends] Fetching friends list...');
                const response = await apiRequest('/friends');
                console.log('[Friends] Received response:', response);
                console.log('[Friends] Response type:', typeof response);
                console.log('[Friends] Is array:', Array.isArray(response));

                // Handle different response formats
                let friends = response;
                if (response && response.friends && Array.isArray(response.friends)) {
                    friends = response.friends;
                } else if (!Array.isArray(response)) {
                    console.error('[Friends] Response is not an array:', response);
                    const friendsList = document.getElementById('friendsList');
                    friendsList.innerHTML = '<p style="color: #ff6b6b; padding: 20px; text-align: center;">Error loading friends</p>';
                    return;
                }

                console.log('[Friends] Friends array:', friends);
                currentFriendsList = friends; // Store for checking status
                const friendsList = document.getElementById('friendsList');

                if (friends.length === 0) {
                    console.log('[Friends] No friends found');
                    friendsList.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No friends yet</p>';
                    return;
                }

                console.log('[Friends] Rendering', friends.length, 'friends');

                // Clear existing content
                friendsList.innerHTML = '';

                // Create elements programmatically
                friends.forEach(friend => {
                    const container = document.createElement('div');
                    container.style.cssText = 'background: rgba(15, 15, 30, 0.6); border: 2px solid var(--primary-color); padding: 16px; margin-bottom: 12px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;';

                    const username = document.createElement('span');
                    username.style.cssText = 'color: #e0e0e0; font-family: "VT323", monospace; font-size: 18px;';
                    username.textContent = friend.username;

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'btn';
                    removeBtn.style.cssText = 'padding: 8px 16px; background: #ff6b6b;';
                    removeBtn.textContent = 'Remove';
                    removeBtn.onclick = () => removeFriend(friend.id);

                    container.appendChild(username);
                    container.appendChild(removeBtn);
                    friendsList.appendChild(container);
                });
            } catch (error) {
                console.error('Failed to load friends:', error);
            }
        }

        async function loadFriendRequests() {
            if (!authToken) return;

            try {
                const requests = await apiRequest('/friends/requests');
                const requestsList = document.getElementById('friendRequestsList');

                if (requests.length === 0) {
                    requestsList.innerHTML = '<p style="color: #666; padding: 20px; text-align: center;">No pending requests</p>';
                    return;
                }

                // Clear existing content
                requestsList.innerHTML = '';

                // Create elements programmatically to avoid string escaping issues
                requests.forEach(req => {
                    const container = document.createElement('div');
                    container.style.cssText = 'background: rgba(15, 15, 30, 0.6); border: 2px solid #00d9ff; padding: 16px; margin-bottom: 12px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;';

                    const username = document.createElement('span');
                    username.style.cssText = 'color: #e0e0e0; font-family: "VT323", monospace; font-size: 18px;';
                    username.textContent = req.from_user.username;

                    const buttonContainer = document.createElement('div');
                    buttonContainer.style.cssText = 'display: flex; gap: 8px;';

                    const acceptBtn = document.createElement('button');
                    acceptBtn.className = 'btn';
                    acceptBtn.style.cssText = 'padding: 8px 16px; background: #00ff9f;';
                    acceptBtn.textContent = 'Accept';
                    acceptBtn.onclick = () => acceptFriendRequest(req.id);

                    const rejectBtn = document.createElement('button');
                    rejectBtn.className = 'btn';
                    rejectBtn.style.cssText = 'padding: 8px 16px; background: #ff6b6b;';
                    rejectBtn.textContent = 'Reject';
                    rejectBtn.onclick = () => rejectFriendRequest(req.id);

                    buttonContainer.appendChild(acceptBtn);
                    buttonContainer.appendChild(rejectBtn);

                    container.appendChild(username);
                    container.appendChild(buttonContainer);

                    requestsList.appendChild(container);
                });
            } catch (error) {
                console.error('Failed to load friend requests:', error);
            }
        }

        let searchFriendsTimeout;
        async function searchFriends() {
            const query = document.getElementById('friendSearchInput').value.trim();
            const resultsDiv = document.getElementById('friendSearchResults');
            console.log('[Friends] Search query:', query);

            if (query.length < 2) {
                resultsDiv.innerHTML = '';
                return;
            }

            clearTimeout(searchFriendsTimeout);
            searchFriendsTimeout = setTimeout(async () => {
                try {
                    console.log('[Friends] Searching for:', query);
                    const results = await apiRequest(`/friends/search?q=${encodeURIComponent(query)}`);
                    console.log('[Friends] Search results:', results);

                    if (results.length === 0) {
                        resultsDiv.innerHTML = '<p style="color: #666; padding: 12px;">No users found</p>';
                        return;
                    }

                    // Clear existing content
                    resultsDiv.innerHTML = '';

                    // Create elements programmatically
                    results.forEach(user => {
                        const container = document.createElement('div');
                        container.style.cssText = 'background: rgba(15, 15, 30, 0.6); border: 2px solid var(--accent-color); padding: 12px; margin-bottom: 8px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;';

                        const username = document.createElement('span');
                        username.style.cssText = 'color: #e0e0e0; font-family: "VT323", monospace; font-size: 18px;';
                        username.textContent = user.username;

                        // Check if already friends
                        const isFriend = currentFriendsList.some(f => f.id === user.id || f.username === user.username);

                        const addBtn = document.createElement('button');
                        addBtn.className = 'btn';
                        if (isFriend) {
                            addBtn.style.cssText = 'padding: 8px 16px; background: #00ff9f; cursor: default;';
                            addBtn.textContent = ' Friends';
                            addBtn.disabled = true;
                        } else {
                            addBtn.style.cssText = 'padding: 8px 16px;';
                            addBtn.textContent = 'Add Friend';
                            addBtn.onclick = () => sendFriendRequest(user.username);
                        }

                        container.appendChild(username);
                        container.appendChild(addBtn);
                        resultsDiv.appendChild(container);
                    });
                } catch (error) {
                    resultsDiv.innerHTML = '<p style="color: #ff6b6b; padding: 12px;">Error searching users</p>';
                }
            }, 300);
        }

        async function sendFriendRequest(username) {
            try {
                await apiRequest('/friends/request', {
                    method: 'POST',
                    body: JSON.stringify({ username })
                });
                showStatus('Friend request sent!');
                document.getElementById('friendSearchInput').value = '';
                document.getElementById('friendSearchResults').innerHTML = '';
            } catch (error) {
                showError(error.message);
            }
        }

        async function acceptFriendRequest(requestId) {
            try {
                await apiRequest(`/friends/requests/${requestId}/accept`, { method: 'POST' });
                showStatus('Friend request accepted!');
                await loadFriends();
                await loadFriendRequests();
                await fetchPendingFriendRequests();
            } catch (error) {
                showError(error.message);
            }
        }

        async function rejectFriendRequest(requestId) {
            try {
                await apiRequest(`/friends/requests/${requestId}/reject`, { method: 'POST' });
                showStatus('Friend request rejected');
                await loadFriendRequests();
                await fetchPendingFriendRequests();
            } catch (error) {
                showError(error.message);
            }
        }

        async function removeFriend(friendId) {
            if (!confirm('Are you sure you want to remove this friend?')) return;

            try {
                await apiRequest(`/friends/${friendId}`, { method: 'DELETE' });
                showStatus('Friend removed');
                await loadFriends();
            } catch (error) {
                showError(error.message);
            }
        }

        // Comments Functions
        let currentContentComments = [];
        let commentsPollingInterval = null;

        async function loadComments(contentId) {
            if (!authToken) return [];

            try {
                const comments = await apiRequest(`/comments/${contentId}`);
                console.log('[Comments] Loaded comments:', comments);
                console.log('[Comments] Number of top-level comments:', comments.length);
                comments.forEach((comment, i) => {
                    console.log(`[Comments] Comment ${i}:`, comment.comment_text.substring(0, 30));
                    console.log(`[Comments]   - Has ${comment.replies?.length || 0} direct replies`);
                    if (comment.replies && comment.replies.length > 0) {
                        comment.replies.forEach((reply, j) => {
                            console.log(`[Comments]     Reply ${j}:`, reply.comment_text.substring(0, 30));
                            console.log(`[Comments]       - Has ${reply.replies?.length || 0} nested replies`);
                        });
                    }
                });
                currentContentComments = comments;
                return comments;
            } catch (error) {
                console.error('Failed to load comments:', error);
                return [];
            }
        }

        async function addComment(contentId, contentType, commentText) {
            if (!authToken) {
                showLoginModal();
                return;
            }

            try {
                await apiRequest('/comments', {
                    method: 'POST',
                    body: JSON.stringify({
                        content_id: contentId,
                        content_type: contentType,
                        comment_text: commentText
                    })
                });
                showStatus('Comment added!');
                return await loadComments(contentId);
            } catch (error) {
                showError(error.message);
                return [];
            }
        }

        async function deleteComment(commentId, contentId) {
            try {
                await apiRequest(`/comments/${commentId}`, { method: 'DELETE' });
                showStatus('Comment deleted');
                return await loadComments(contentId);
            } catch (error) {
                showError(error.message);
                return [];
            }
        }

        // Comments UI Functions

        window.toggleComments = function() {
            const commentsSection = document.getElementById('commentsSection');
            const isVisible = commentsSection.style.display === 'block';

            if (isVisible) {
                hideCommentsSection();
            } else if (currentContentId && currentContentType) {
                showCommentsSection(currentContentId, currentContentType);
            } else {
                showError('No content is currently playing');
            }
        }

        function showCommentsSection(contentId, contentType) {
            if (!authToken) {
                showError('Please login to view and post comments');
                return;
            }

            currentContentId = contentId;
            currentContentType = contentType;
            document.getElementById('commentsSection').style.display = 'block';
            displayComments(contentId);

            // Start polling for new comments every 3 seconds
            if (commentsPollingInterval) {
                clearInterval(commentsPollingInterval);
            }
            commentsPollingInterval = setInterval(() => {
                displayComments(contentId);
            }, 3000);
        }

        function hideCommentsSection() {
            document.getElementById('commentsSection').style.display = 'none';

            // Stop polling when comments section is hidden
            if (commentsPollingInterval) {
                clearInterval(commentsPollingInterval);
                commentsPollingInterval = null;
            }
        }

        // Recursive function to render nested replies
        function renderReplies(replies, depth = 0) {
            console.log(`[Comments] renderReplies called with ${replies?.length || 0} replies at depth ${depth}`);
            if (!replies || replies.length === 0) return '';

            const marginLeft = 20; // Consistent left margin for all nested levels

            return replies.map((reply, index) => {
                console.log(`[Comments]   Rendering reply ${index} at depth ${depth}: "${reply.comment_text.substring(0, 30)}"`);
                console.log(`[Comments]     Reply has ${reply.replies?.length || 0} nested replies`);
                const replyDate = new Date(reply.created_at);
                const isOwnReply = currentUser && reply.user_id === currentUser.id;
                const likeIconReply = reply.liked_by_user ? '' : '';

                // Recursively render nested replies underneath this reply
                const nestedRepliesHTML = renderReplies(reply.replies || [], depth + 1);

                return `
                    <div style="background: rgba(15, 15, 30, 0.4); border-left: 3px solid ${isOwnReply ? 'var(--primary-color, #00ff9f)' : 'var(--accent-color, #00d9ff)'}; padding: 8px; margin: 6px 0 6px ${marginLeft}px; border-radius: 3px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="color: ${isOwnReply ? 'var(--primary-color, #00ff9f)' : 'var(--accent-color, #00d9ff)'}; font-family: 'VT323', monospace; font-size: 14px; font-weight: bold;">
                                ${reply.username}${isOwnReply ? ' (You)' : ''}
                            </span>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <span style="color: #888; font-family: 'VT323', monospace; font-size: 11px;">
                                    ${replyDate.toLocaleDateString()} ${replyDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                </span>
                                ${isOwnReply ? `<button onclick="event.stopPropagation(); deleteCommentUI('${reply._id}')" style="background: #ff6b6b; border: none; color: #fff; padding: 2px 6px; cursor: pointer; border-radius: 2px; font-family: 'VT323', monospace; font-size: 12px;">Delete</button>` : ''}
                            </div>
                        </div>
                        <p style="color: #e0e0e0; font-family: 'VT323', monospace; font-size: 14px; line-height: 1.3; margin: 0 0 6px 0; white-space: pre-wrap;">
                            ${escapeHtml(reply.comment_text)}
                        </p>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <button onclick="event.stopPropagation(); toggleLike('${reply._id}')" style="background: none; border: none; color: #ccc; cursor: pointer; font-family: 'VT323', monospace; font-size: 14px; display: flex; align-items: center; gap: 3px; padding: 3px 6px;">
                                <span>${likeIconReply}</span>
                                <span id="like-count-${reply._id}">${reply.like_count || 0}</span>
                            </button>
                            <button onclick="event.stopPropagation(); showReplyBox('${reply._id}')" style="background: none; border: none; color: var(--accent-color, #00d9ff); cursor: pointer; font-family: 'VT323', monospace; font-size: 13px; padding: 3px 6px;">
                                 Reply
                            </button>
                        </div>
                        <div id="reply-box-${reply._id}" style="display: none; margin-top: 8px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 3px;">
                            <textarea id="reply-textarea-${reply._id}" placeholder="Write a reply..."
                                      style="width: 100%; padding: 6px; background: #1a1a2e; border: 2px solid var(--secondary-color, #ff00ff); color: #e0e0e0; font-family: 'VT323', monospace; font-size: 14px; resize: none; overflow: hidden; min-height: 25px; max-height: 120px; border-radius: 3px; margin-bottom: 6px;"
                                      maxlength="500"
                                      rows="1"
                                      oninput="autoResizeTextarea(this)"></textarea>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="submitReply('${reply._id}')" class="btn" style="padding: 4px 12px; font-size: 14px;">Post Reply</button>
                                <button onclick="hideReplyBox('${reply._id}')" class="btn btn-secondary" style="padding: 4px 12px; font-size: 14px;">Cancel</button>
                            </div>
                        </div>
                        ${nestedRepliesHTML}
                    </div>
                `;
            }).join('');
        }

        async function displayComments(contentId) {
            const comments = await loadComments(contentId);
            const commentsList = document.getElementById('commentsList');

            // Preserve scroll position, open reply boxes, AND textarea values
            const scrollPos = commentsList.scrollTop;
            const openReplyBoxes = [];
            const textareaValues = {};
            document.querySelectorAll('[id^="reply-box-"]').forEach(box => {
                if (box.style.display !== 'none') {
                    const commentId = box.id.replace('reply-box-', '');
                    openReplyBoxes.push(commentId);
                    // Also preserve the textarea value
                    const textarea = document.getElementById(`reply-textarea-${commentId}`);
                    if (textarea && textarea.value) {
                        textareaValues[commentId] = textarea.value;
                    }
                }
            });

            if (comments.length === 0) {
                commentsList.innerHTML = '<p style="color: #666; text-align: center; padding: 20px; font-family: \'VT323\', monospace; font-size: 18px;">No comments yet. Be the first to share your thoughts!</p>';
                return;
            }

            // Generate new comments HTML with likes and replies
            const newCommentsHTML = comments.map(comment => {
                const date = new Date(comment.created_at);
                const isOwnComment = currentUser && comment.user_id === currentUser.id;

                // Use recursive function to render all nested replies
                const repliesHTML = renderReplies(comment.replies || [], 0);

                const likeIcon = comment.liked_by_user ? '' : '';

                return`
                    <div style="background: rgba(15, 15, 30, 0.6); border-left: 4px solid ${isOwnComment ? 'var(--primary-color, #00ff9f)' : 'var(--accent-color, #00d9ff)'}; padding: 10px; margin-bottom: 10px; border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <span style="color: ${isOwnComment ? 'var(--primary-color, #00ff9f)' : 'var(--accent-color, #00d9ff)'}; font-family: 'VT323', monospace; font-size: 16px; font-weight: bold;">
                                ${comment.username}${isOwnComment ? ' (You)' : ''}
                            </span>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span style="color: #888; font-family: 'VT323', monospace; font-size: 12px;">
                                    ${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                                </span>
                                ${isOwnComment ? `<button onclick="event.stopPropagation(); deleteCommentUI('${comment._id}')" style="background: #ff6b6b; border: none; color: #fff; padding: 3px 10px; cursor: pointer; border-radius: 3px; font-family: 'VT323', monospace; font-size: 13px;">Delete</button>` : ''}
                            </div>
                        </div>
                        <p style="color: #e0e0e0; font-family: 'VT323', monospace; font-size: 15px; line-height: 1.4; margin: 0 0 8px 0; white-space: pre-wrap;">
                            ${escapeHtml(comment.comment_text)}
                        </p>
                        <div style="display: flex; gap: 12px; align-items: center; margin-bottom: 6px;">
                            <button onclick="event.stopPropagation(); toggleLike('${comment._id}')" style="background: none; border: none; color: #ccc; cursor: pointer; font-family: 'VT323', monospace; font-size: 15px; display: flex; align-items: center; gap: 4px; padding: 4px 8px;">
                                <span>${likeIcon}</span>
                                <span id="like-count-${comment._id}">${comment.like_count || 0}</span>
                            </button>
                            <button onclick="event.stopPropagation(); showReplyBox('${comment._id}')" style="background: none; border: none; color: var(--accent-color, #00d9ff); cursor: pointer; font-family: 'VT323', monospace; font-size: 14px; padding: 4px 8px;">
                                 Reply
                            </button>
                        </div>
                        <div id="reply-box-${comment._id}" style="display: none; margin-top: 8px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                            <textarea id="reply-textarea-${comment._id}" placeholder="Write a reply..."
                                      style="width: 100%; padding: 6px; background: #1a1a2e; border: 2px solid var(--secondary-color, #ff00ff); color: #e0e0e0; font-family: 'VT323', monospace; font-size: 14px; resize: none; overflow: hidden; min-height: 25px; max-height: 130px; border-radius: 3px; margin-bottom: 6px;"
                                      maxlength="500"
                                      rows="1"
                                      oninput="autoResizeTextarea(this)"></textarea>
                            <div style="display: flex; gap: 6px;">
                                <button onclick="submitReply('${comment._id}')" class="btn" style="padding: 5px 14px; font-size: 14px;">Post Reply</button>
                                <button onclick="hideReplyBox('${comment._id}')" class="btn btn-secondary" style="padding: 5px 14px; font-size: 14px;">Cancel</button>
                            </div>
                        </div>
                        ${repliesHTML}
                    </div>
                `;
            }).join('');

            // Only update if content changed to avoid flashing
            if (commentsList.innerHTML !== newCommentsHTML) {
                commentsList.innerHTML = newCommentsHTML;
                // Restore scroll position
                commentsList.scrollTop = scrollPos;
                // Restore open reply boxes AND their textarea values
                openReplyBoxes.forEach(commentId => {
                    const replyBox = document.getElementById(`reply-box-${commentId}`);
                    if (replyBox) {
                        replyBox.style.display = 'block';
                        // Restore the textarea value if it existed
                        if (textareaValues[commentId]) {
                            const textarea = document.getElementById(`reply-textarea-${commentId}`);
                            if (textarea) {
                                textarea.value = textareaValues[commentId];
                                // Re-trigger auto-resize to match content
                                autoResizeTextarea(textarea);
                            }
                        }
                    }
                });
            }
        }

        window.submitComment = async function() {
            const textarea = document.getElementById('commentTextarea');
            const commentText = textarea.value.trim();

            if (!commentText) {
                showError('Please enter a comment');
                return;
            }

            if (!currentContentId || !currentContentType) {
                showError('No content selected');
                return;
            }

            await addComment(currentContentId, currentContentType, commentText);
            textarea.value = '';
            textarea.style.height = 'auto';
            updateCharCount();
            await displayComments(currentContentId);
        }

        async function deleteCommentUI(commentId) {
            if (!confirm('Delete this comment?')) return;
            await deleteComment(commentId, currentContentId);
            await displayComments(currentContentId);
        }

        function updateCharCount() {
            const textarea = document.getElementById('commentTextarea');
            const charCount = document.getElementById('commentCharCount');
            if (textarea && charCount) {
                charCount.textContent = `${textarea.value.length}/500`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-resize textarea
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, parseInt(textarea.style.maxHeight)) + 'px';
        }

        // Toggle like on a comment
        async function toggleLike(commentId) {
            if (!authToken) {
                showError('Please login to like comments');
                return;
            }

            try {
                const likeCountEl = document.getElementById(`like-count-${commentId}`);
                if (!likeCountEl) return;

                // Check if already liked by finding the heart icon
                const likeBtn = likeCountEl.closest('button');
                const heartIcon = likeBtn.querySelector('span:first-child');
                const isLiked = heartIcon.textContent === '';

                if (isLiked) {
                    // Unlike
                    const response = await apiRequest(`/comments/${commentId}/like`, { method: 'DELETE' });
                    likeCountEl.textContent = response.like_count;
                    heartIcon.textContent = '';
                } else {
                    // Like
                    const response = await apiRequest(`/comments/${commentId}/like`, { method: 'POST' });
                    likeCountEl.textContent = response.like_count;
                    heartIcon.textContent = '';
                }
            } catch (error) {
                console.error('Failed to toggle like:', error);
            }
        }

        // Show reply box
        function showReplyBox(commentId) {
            const replyBox = document.getElementById(`reply-box-${commentId}`);
            if (replyBox) {
                replyBox.style.display = 'block';
                const textarea = document.getElementById(`reply-textarea-${commentId}`);
                if (textarea) textarea.focus();
            }
        }

        // Hide reply box
        function hideReplyBox(commentId) {
            const replyBox = document.getElementById(`reply-box-${commentId}`);
            if (replyBox) {
                replyBox.style.display = 'none';
                const textarea = document.getElementById(`reply-textarea-${commentId}`);
                if (textarea) textarea.value = '';
            }
        }

        // Submit reply
        async function submitReply(parentCommentId) {
            console.log('[Comments] submitReply called with parentCommentId:', parentCommentId);
            const textarea = document.getElementById(`reply-textarea-${parentCommentId}`);
            const replyText = textarea.value.trim();
            console.log('[Comments] Reply text:', replyText);

            if (!replyText) {
                showError('Please enter a reply');
                return;
            }

            if (!currentContentId || !currentContentType) {
                showError('No content selected');
                return;
            }

            const payload = {
                content_id: currentContentId,
                content_type: currentContentType,
                comment_text: replyText,
                parent_comment_id: parentCommentId
            };
            console.log('[Comments] Submitting reply with payload:', payload);

            try {
                const result = await apiRequest('/comments', {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });
                console.log('[Comments] Reply submitted successfully:', result);

                textarea.value = '';
                hideReplyBox(parentCommentId);
                console.log('[Comments] Refreshing comments display...');
                await displayComments(currentContentId);
                console.log('[Comments] Comments display refreshed');
            } catch (error) {
                console.error('[Comments] Error submitting reply:', error);
                showError(error.message);
            }
        }

        // Add event listener for character count
        document.addEventListener('DOMContentLoaded', function() {
            const textarea = document.getElementById('commentTextarea');
            if (textarea) {
                textarea.addEventListener('input', updateCharCount);
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateAuthUI();
            loadUserData();
        });

        // ============= END AUTHENTICATION & API SYSTEM =============

        // Log that all functions are loaded
        console.log('[INIT] Script fully loaded. Functions available:', {
            showTab: typeof window.showTab,
            showLoginModal: typeof window.showLoginModal,
            showRegisterModal: typeof window.showRegisterModal,
            logout: typeof window.logout
        });

        // ============= END THEME & ANIMATION SYSTEM =============
    </script>
    <script>
        /* ===================== User Ratings Injection (You + Friends) ===================== */
        (function(){
          if (window.__userRatingsInjected) return; 
          window.__userRatingsInjected = true;
        
          // --- small helpers ---
          function getToken(){
            return (window.authToken) ||
                   localStorage.getItem('authToken') ||
                   localStorage.getItem('jwt') ||
                   localStorage.getItem('token') ||
                   localStorage.getItem('access_token');
          }
          function getCurrentUser(){
            if (window.currentUser) return window.currentUser;
            try { return JSON.parse(localStorage.getItem('currentUser') || 'null'); } catch(_) { return null; }
          }
          function showToast(msg){
            try { (window.showError || window.showToast || console.log)(msg); } catch(_) {}
          }
        
          // Prefer site-wide API helper if present (cookie/session), else add Authorization header
          const API_BASE = '/api';
          const baseFetch = async (path, opt={}) => {
                // Always ensure path starts with /api but don't double it
                let url = path;
                if (!path.startsWith('/api')) {
                  url = API_BASE + (path.startsWith('/') ? '' : '/') + path;
                }
                const token = getToken();
                const headers = Object.assign({'Content-Type':'application/json'}, opt.headers || {});
                if (token) headers['Authorization'] = 'Bearer ' + token;
                const res = await fetch(url, Object.assign({ headers, credentials: 'include' }, opt));
                if (!res.ok) {
                  const text = await res.text().catch(()=> '');
                  const err = new Error(text || ('HTTP ' + res.status));
                  err.status = res.status;
                  throw err;
                }
                return res.status === 204 ? null : res.json();
              };
        
          // Track current title identity (movie/tv + TMDB id)
          let currentContentType = window.currentContentType || null;
          let currentContentId   = window.currentContentId   || null;
          let isRefreshing = false; // Prevent concurrent refreshes
        
          // ---- DOM location helpers ----
          function closestContainerFromKnownIds(){
            const ids = ['imdbRating','rtRating','metacriticRating'];
            const els = ids.map(id => document.getElementById(id)).filter(Boolean);
            if (!els.length) return null;
            for (const el of els) {
              const grid = el.closest('.ratings-container');
              if (grid) return grid;
            }
            // Fallback: common parent of value nodes
            let parent = els[0].parentElement;
            for (let i=1;i<els.length;i++){
              const set = new Set();
              let n = els[i].parentElement;
              while (n){ set.add(n); n = n.parentElement; }
              while (parent && !set.has(parent)) parent = parent.parentElement;
              if (!parent) break;
            }
            return parent || null;
          }
        
          function hostRatingsBox(){
            let container =
              document.querySelector('#omdbRatings .ratings-container') ||
              document.querySelector('.omdb-ratings .ratings-container') ||
              document.querySelector('.ratings-container');
        
            if (!container){
              container = closestContainerFromKnownIds();
            }
        
            if (!container){
              // Last resort: create a minimal grid under the info column
              const info = document.querySelector('.current-content-info') || document.querySelector('.player-section') || document.body;
              if (!info) return null;
              let outer = document.getElementById('omdbRatings') || document.createElement('div');
              if (!outer.id) outer.id = 'omdbRatings';
              outer.classList.add('omdb-ratings');
              container = document.createElement('div');
              container.className = 'ratings-container';
              outer.appendChild(container);
              info.prepend(outer);
            }
            return container;
          }
        
          // ---- UI creation ----
          function ensurePill(container){
            if (!container) return null;
            let pill = document.getElementById('userRatingPill');
            if (pill && pill.parentElement !== container){
              pill.remove(); pill = null;
            }
            if (pill) return pill;
        
            pill = document.createElement('div');
            pill.className = 'rating-item user-pill';
            pill.id = 'userRatingPill';
            pill.innerHTML = `
              <div class="rating-source">You</div>
              <div class="rating-value" id="userRatingValue"></div>
              <div style="display:flex; align-items:center; gap:8px; margin-top:4px;">
                <input id="userRatingInput" type="number" min="1" max="10" step="0.1" placeholder="110" />
                <button class="post-btn" id="postUserRatingBtn">Post</button>
              </div>
            `;
            container.appendChild(pill);
            const btn = pill.querySelector('#postUserRatingBtn');
            btn.addEventListener('click', postUserRating);
            return pill;
          }
        
          async function getFriendUsernames(){
            try {
              const r = await baseFetch('/friends', { method: 'GET' });
              console.log('[Ratings] getFriendUsernames response:', r);

              // Handle both array and object formats
              let friendsList = [];
              if (Array.isArray(r)) {
                // Backend returns array directly: [{id: '...', username: '...'}, ...]
                friendsList = r;
              } else if (r && Array.isArray(r.friends)) {
                // Backend returns object: {friends: [...]}
                friendsList = r.friends;
              }

              const usernames = friendsList.map(f => (f.username || f));
              console.log('[Ratings] Friend usernames:', usernames);
              return usernames;
            } catch(e){
              console.error('[Ratings] getFriendUsernames failed:', e);
              return [];
            }
          }
        
          async function postUserRating(){
            console.log('[Ratings] postUserRating called');
            if (!currentContentId || !currentContentType){
              console.log('[Ratings] Missing content info', { currentContentId, currentContentType });
              showToast('Select a title first');
              return;
            }
            const input = document.getElementById('userRatingInput');
            const val = parseFloat(input && input.value);
            console.log('[Ratings] Rating value:', val);
            if (isNaN(val) || val < 1 || val > 10){
              showToast('Enter a rating from 1 to 10');
              return;
            }
            try{
              const url = `/ratings/${currentContentType}/${currentContentId}`;
              console.log('[Ratings] Posting to:', url, 'with rating:', val);
              const result = await baseFetch(url, {
                method: 'POST',
                body: JSON.stringify({ rating: val })
              });
              console.log('[Ratings] Post result:', result);
              await refreshRatingsUI();
              showToast('Saved');
            }catch(e){
              console.error('[Ratings] Post failed:', e);
              if (e && (e.status === 401 || /401/.test(String(e.message||'')))){
                if (window.showLoginModal) showLoginModal(); else alert('Please log in');
              } else {
                console.error(e); showToast('Failed to save');
              }
            }
          }
        
          async function refreshRatingsUI(){
            console.log('[Ratings] refreshRatingsUI called', { currentContentType, currentContentId, isRefreshing });

            // Prevent concurrent refreshes
            if (isRefreshing) {
              console.log('[Ratings] Already refreshing, skipping...');
              return;
            }

            const container = hostRatingsBox();
            if (!container || !currentContentId || !currentContentType) {
              console.log('[Ratings] Missing container or content info', { container: !!container, currentContentId, currentContentType });
              return;
            }

            isRefreshing = true;
            console.log('[Ratings] Starting refresh...');

            // Ensure "You" tile
            ensurePill(container);

            // Fetch aggregated ratings
            let data = { ratings_by_user: {} };
            try {
              const url = `/ratings/${currentContentType}/${currentContentId}`;
              console.log('[Ratings] Fetching from:', url);
              data = await baseFetch(url, { method: 'GET' });
              console.log('[Ratings] Received data:', data);
            } catch(e){
              console.error('[Ratings] Fetch failed:', e);
            }

            const cu = getCurrentUser();
            console.log('[Ratings] getCurrentUser() returned:', cu);
            const me = (cu && (cu.username || cu.name)) || null;
            console.log('[Ratings] Current user (me):', me);
            console.log('[Ratings] window.currentUser:', window.currentUser);
            console.log('[Ratings] localStorage currentUser:', localStorage.getItem('currentUser'));
            console.log('[Ratings] Ratings by user:', data.ratings_by_user);
            console.log('[Ratings] All usernames in ratings:', Object.keys(data.ratings_by_user || {}));

            // Update "You" tile UI
            const input = document.getElementById('userRatingInput');
            const btn = document.getElementById('postUserRatingBtn');
            const youValEl = document.getElementById('userRatingValue');
            const yourVal = me ? data.ratings_by_user?.[me] : null;
            console.log('[Ratings] Checking for rating: data.ratings_by_user[' + me + '] =', data.ratings_by_user?.[me]);
            console.log('[Ratings] Your rating value (yourVal):', yourVal);

            if (input) input.value = (yourVal || '');
            if (btn) btn.textContent = yourVal ? 'Update' : 'Post';
            if (youValEl) {
                const displayValue = yourVal ? `${yourVal}/10` : '';
                console.log('[Ratings] Setting youValEl.textContent to:', displayValue);
                youValEl.textContent = displayValue;
            } else {
                console.log('[Ratings] youValEl not found!');
            }

            // Remove prior friend tiles
            container.querySelectorAll('.friend-rating-item').forEach(n => n.remove());

            // Render friend ratings as tiles like others
            try{
              const friends = await getFriendUsernames();
              console.log('[Ratings] Friends list:', friends);
              console.log('[Ratings] Current user (me):', me);

              // Log all ratings to see who has rated
              const allRatings = Object.entries(data.ratings_by_user || {});
              console.log('[Ratings] All ratings:', allRatings);

              // Filter to only show friend ratings (exclude own rating)
              const friendEntries = allRatings.filter(([username, rating]) => {
                const isMe = (me && username === me);
                const isFriend = friends.includes(username);
                console.log(`[Ratings] Check ${username}: isMe=${isMe}, isFriend=${isFriend}`);
                return !isMe && isFriend;
              });
              console.log('[Ratings] Friend ratings to display:', friendEntries);
              console.log('[Ratings] Number of friend ratings:', friendEntries.length);

              for (const [u, v] of friendEntries){
                console.log(`[Ratings] Creating tile for friend ${u} with rating ${v}`);
                const tile = document.createElement('div');
                tile.className = 'rating-item friend-rating-item';
                tile.innerHTML = `
                  <div class="rating-source">@${u}</div>
                  <div class="rating-value">${v}/10</div>
                `;
                container.appendChild(tile);
                console.log('[Ratings] Tile appended to container for ${u}');
              }
              console.log('[Ratings] Finished rendering friend ratings. Total rendered:', friendEntries.length);
            }catch(e){
              console.error('[Ratings] Friends rendering failed:', e);
            } finally {
              isRefreshing = false;
              console.log('[Ratings] Refresh complete, flag reset');
            }
          }
        
          // --- Wire-up: when details are loaded, set ids and refresh ---
          if (!window.fetch.__rfRatingsWrap){
            const _orig = window.fetch;
            const wrapped = async function(url, options){
              const res = await _orig.apply(this, arguments);
              try{
                let href = typeof url === 'string' ? url : (url && url.url) || '';
                const m = href && href.match(/\/api\/(movie|tv)\/(\d+)/);
                if (m){
                  currentContentType = m[1];
                  currentContentId = parseInt(m[2], 10);
                  console.log('[Ratings] Fetch intercepted:', currentContentType, currentContentId);
                  // after response resolves and DOM updates, seed the pill
                  // Try multiple times with increasing delays to ensure DOM is ready
                  setTimeout(() => {
                    console.log('[Ratings] First attempt to setup ratings UI');
                    setupUserRatingsPill();
                  }, 300);
                  setTimeout(() => {
                    console.log('[Ratings] Second attempt to setup ratings UI');
                    setupUserRatingsPill();
                  }, 800);
                }
              }catch(e){
                console.error('[Ratings] Fetch wrapper error:', e);
              }
              return res;
            };
            Object.defineProperty(wrapped, '__rfRatingsWrap', { value: true });
            window.fetch = wrapped;
          }
        
          // Keep pill present if grid re-renders
          let __gridObserver = null;
          function observeGrid(container){
            try{
              if (!container) return;
              if (__gridObserver) __gridObserver.disconnect();
              __gridObserver = new MutationObserver(() => {
                if (!document.getElementById('userRatingPill')) ensurePill(container);
              });
              __gridObserver.observe(container, { childList: true });
            }catch(_){}
          }
        
          let __lastRefreshedContentId = null;

          function setupUserRatingsPill(){
            const box = hostRatingsBox();
            console.log('[Ratings] setupUserRatingsPill called - container found:', !!box, 'contentType:', currentContentType, 'contentId:', currentContentId);
            if (!box) {
              console.log('[Ratings] No ratings container found yet, will retry');
              return;
            }
            console.log('[Ratings] Ensuring pill exists...');
            ensurePill(box);
            console.log('[Ratings] Setting up grid observer...');
            observeGrid(box);

            // Only refresh if we have valid content info and haven't already refreshed for this content
            if (currentContentType && currentContentId) {
              const contentKey = `${currentContentType}_${currentContentId}`;
              if (__lastRefreshedContentId !== contentKey) {
                console.log('[Ratings] Calling refreshRatingsUI to load friend ratings for:', contentKey);
                __lastRefreshedContentId = contentKey;
                try {
                  refreshRatingsUI();
                } catch(e){
                  console.error('[Ratings] refreshRatingsUI error:', e);
                }
              } else {
                console.log('[Ratings] Already refreshed for this content:', contentKey);
              }
            } else {
              console.log('[Ratings] No valid content info yet, skipping refresh');
            }
          }
        
          document.addEventListener('DOMContentLoaded', () => {
            setTimeout(setupUserRatingsPill, 300);
          });
        })();
        </script>
</body>
</html>