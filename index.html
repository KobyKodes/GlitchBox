<!DOCTYPE html>
<html lang="en" data-theme="jspecial">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta http-equiv="Permissions-Policy" content="fullscreen=*">
    <title>GlitchBox - Stream Movies & TV Shows</title>

    <!-- IMPORTANT: Define all onclick handler functions FIRST before any HTML is parsed -->
    

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- <script src="https://fpyf8.com/88/tag.min.js" data-zone="178035" async data-cfasync="false"></script> -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: var(--custom-cursor), auto !important;
        }

        html, body {
            overflow-x: hidden;
        }

        body {
            font-family: 'VT323', monospace;
            background: #1a1a2e;
            background-image:
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 0, 0, 0.2) 2px, rgba(0, 0, 0, 0.2) 4px),
                linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            background-attachment: fixed;
            color: #e0e0e0;
            line-height: 1.6;
            font-weight: 400;
            min-height: 100vh;
            position: relative;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 20px;
            display: flex;
            flex-direction: column;
        }

        .container > .hero-header { order: 1; }
        .container > .player-section { order: 2; }
        .container > .standalone-poster { order: 2; }
        .container > .hero-nav-section { order: 3; }
        .container > .header { order: 4; }
        .container > .search-section { order: 5; }
        .container > .popular-section { order: 5; }
        .container > #contentResults { order: 6; }
        .container > #continueWatchingDisplay { order: 6; }
        .container > #watchlistDisplay { order: 6; }
        .container > #statisticsDisplay { order: 6; }
        .container > #loadingIndicator { order: 6; }
        .container > #sportsDisplay { order: 6; }
        .container > #channelsDisplay { order: 6; }
        .container > #loginModal { order: 7; }
        .container > #registerModal { order: 8; }
        .container > #friendsModal { order: 9; }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-align: center;
            margin-bottom: 48px;
            padding: 32px 20px;
            background: transparent;
            border: none;
            box-shadow: none;
            position: relative;
        }

        .header p {
            font-size: 1.5rem;
            line-height: 1.4;
            color: #00d9ff;
            margin-top: 12px;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2rem;
            line-height: 1.4;
            margin-bottom: 16px;
            color: #00ff9f;
            text-shadow:
                3px 3px 0 #ff00ff,
                6px 6px 0 rgba(0, 0, 0, 0.3),
                0 0 20px rgba(0, 255, 159, 0.5);
            animation: glitch 3s infinite;
        }

        @keyframes glitch {
            0%, 90%, 100% {
                transform: translate(0);
            }
            92% {
                transform: translate(-2px, 2px);
            }
            94% {
                transform: translate(2px, -2px);
            }
            96% {
                transform: translate(-2px, -2px);
            }
            98% {
                transform: translate(2px, 2px);
            }
        }

        .search-section {
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 32px;
            margin-bottom: 32px;
            position: relative;
            z-index: 1000;
        }

        .search-box {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            flex-wrap: wrap;
            align-items: center;
        }

        .search-input {
            font-family: 'VT323', monospace;
            width: 100%;
            padding: 14px 16px;
            background: #1a1a2e;
            border: 3px solid #00d9ff;
            color: #00ff9f;
            font-size: 24px;
            transition: all 0.2s;
            box-shadow:
                inset 2px 2px 0 rgba(0, 0, 0, 0.3),
                0 0 10px rgba(0, 217, 255, 0.3);
        }

        .search-input:focus {
            outline: none;
            border-color: #00ff9f;
            background: #16213e;
            box-shadow:
                inset 2px 2px 0 rgba(0, 0, 0, 0.3),
                0 0 15px rgba(0, 255, 159, 0.5);
            color: #00ff9f;
        }

        .search-input::placeholder {
            color: #4a5568;
        }

        .search-container {
            position: relative;
            flex: 1;
            z-index: 100001;
        }

        .search-autocomplete {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(29, 29, 31, 0.98);
            backdrop-filter: saturate(180%) blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin-top: 8px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 100002;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: none;
        }

        .search-autocomplete::-webkit-scrollbar {
            width: 8px;
        }

        .search-autocomplete::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .search-autocomplete::-webkit-scrollbar-thumb {
            background: rgba(0, 122, 255, 0.5);
            border-radius: 4px;
        }

        .search-autocomplete::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 122, 255, 0.7);
        }

        .autocomplete-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background: rgba(145, 70, 255, 0.2);
        }

        .autocomplete-poster {
            width: 40px;
            height: 60px;
            object-fit: cover;
            border-radius: 4px;
        }

        .autocomplete-info {
            flex: 1;
        }

        .autocomplete-title {
            color: #fff;
            font-weight: 600;
            font-size: 14px;
        }

        .autocomplete-meta {
            color: #888;
            font-size: 12px;
            margin-top: 4px;
        }

        .year-input {
            width: 120px;
            padding: 16px 20px;
            background: rgba(58, 58, 60, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            color: #f5f5f7;
            font-size: 17px;
            font-weight: 400;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(20px);
        }

        .btn {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: var(--primary-color, #00ff9f);
            border: 2px solid var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            font-size: 20px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 159, 0.3);
            text-decoration: none;
            text-align: center;
        }

        .btn:hover {
            background: rgba(0, 255, 159, 0.1);
            color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--bg-dark, #0f0f1e);
            color: var(--primary-color, #00ff9f);
            border: 2px solid var(--primary-color, #00ff9f);
        }

        .btn-secondary:hover {
            background: rgba(0, 255, 159, 0.1);
            color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .btn-secondary:active {
            transform: translateY(0);
        }

        .quick-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .content-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        @media (min-width: 1400px) {
            .content-results {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 28px;
            }
        }

        .content-card {
            background: var(--bg-dark, #0f0f1e);
            overflow: visible;
            cursor: pointer;
            transition: all 0.1s;
            border: 3px solid var(--accent-color, #00d9ff);
            position: relative;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .content-card .content-poster {
            overflow: hidden;
        }

        .content-card:hover {
            transform: translate(-3px, -3px);
            border-color: var(--primary-color, #00ff9f);
            box-shadow:
                9px 9px 0 rgba(0, 0, 0, 0.5),
                0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .content-card:hover .watchlist-btn {
            /* Watchlist button is always visible */
        }

        .content-card:hover .genre-overlay {
            opacity: 1;
        }

        /* Base tooltip styles - overridden by more specific styles below */
        .tooltip-loading {
            color: #00d9ff;
            font-size: 17px;
            text-align: center;
        }

        .content-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
        }

        .content-info {
            padding: 15px;
        }

        .content-title {
            font-weight: 600;
            font-size: 19px;
            margin-bottom: 5px;
            line-height: 1.3;
            color: var(--primary-color, #00ff9f);
        }

        .content-year {
            color: var(--accent-color, #00d9ff);
            font-size: 17px;
            margin-bottom: 8px;
        }

        .content-genres {
            color: #888;
            font-size: 16px;
            margin-top: 4px;
            line-height: 1.3;
        }

        .card-progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 5;
        }

        .card-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color, #00ff9f), var(--accent-color, #00d9ff));
            transition: width 0.3s ease;
            box-shadow: 0 0 8px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .content-type-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: var(--primary-color, #00ff9f);
            padding: 4px 8px;
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .content-rating-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            color: #FFD700;
            padding: 4px 10px;
            border: 2px solid #FFD700;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
            font-family: 'Press Start 2P', cursive;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .content-runtime-badge {
            position: absolute;
            top: 45px;
            left: 10px;
            background: rgba(0,0,0,0.85);
            color: var(--accent-color, #00d9ff);
            padding: 4px 10px;
            border: 2px solid var(--accent-color, #00d9ff);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
            font-family: 'VT323', monospace;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .content-card:hover .content-rating-badge,
        .content-card:hover .content-runtime-badge {
            opacity: 1;
        }

        .imdb-btn {
            position: absolute;
            bottom: 67px;
            right: 10px;
            background: #F5C518;
            color: #000;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 700;
            text-decoration: none;
            display: none;
            align-items: center;
            gap: 4px;
            transition: all 0.3s;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .content-card:hover .imdb-btn {
            display: flex;
        }

        .imdb-btn:hover {
            background: #FFD93D;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(245, 197, 24, 0.5);
        }

        .genre-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 70%, transparent 100%);
            padding: 40px 15px 15px 15px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .genre-text {
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            line-height: 1.4;
            text-align: center;
        }

        .tv-badge {
            background: #ff6b6b;
        }

        .movie-badge {
            background: #4ecdc4;
        }

        .player-section {
            background: transparent;
            border: none;
            border-bottom: 2px solid var(--primary-color, #00ff9f);
            padding: 32px;
            padding-top: 48px;
            margin-bottom: 32px;
            box-shadow: none;
            position: relative;
        }

        .player-close-btn {
            position: absolute;
            top: 6px;
            right: 16px;
            z-index: 100;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            color: var(--text-secondary, #aaa);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-close-btn:hover {
            background: rgba(255, 70, 70, 0.15);
            border-color: rgba(255, 70, 70, 0.4);
            color: #ff4646;
            transform: scale(1.08);
        }

        /* Redesigned Player Watchlist Panel */
        .player-watchlist-panel {
            display: none;
            flex-direction: column;
            width: 360px;
            max-height: 450px;
            background: var(--bg-elevated, rgba(26, 26, 46, 0.97));
            border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.1));
            border-radius: 18px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.15));
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.96);
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .player-watchlist-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
            display: flex;
        }

        .player-watchlist-header {
            padding: 18px 22px 14px;
            border-bottom: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.08));
        }

        .player-watchlist-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-watchlist-title {
            font-family: inherit;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary, #f5f5f7);
            margin: 0;
        }

        .player-watchlist-close {
            width: 34px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 10px;
            color: var(--text-secondary, #aaa);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .player-watchlist-close:hover {
            background: rgba(255, 70, 70, 0.12);
            color: #ff4646;
        }

        .player-watchlist-lists {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .player-watchlist-list-card {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 16px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid transparent;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-primary, #f5f5f7);
            font-size: 16px;
            font-weight: 500;
        }

        .player-watchlist-list-card:hover {
            background: var(--primary-glow, rgba(0, 255, 159, 0.08));
            border-color: var(--primary-glow, rgba(0, 255, 159, 0.2));
            transform: translateX(4px);
        }

        .player-watchlist-list-card.remove-card:hover {
            background: rgba(255, 59, 48, 0.1);
            border-color: rgba(255, 59, 48, 0.25);
        }

        .player-watchlist-list-icon {
            width: 42px;
            height: 42px;
            background: linear-gradient(135deg, var(--primary-color, #00ff9f) 0%, var(--accent-color, #00d9ff) 100%);
            border-radius: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--bg-dark, #0f0f1e);
            font-size: 18px;
            flex-shrink: 0;
        }

        .player-watchlist-list-card.remove-card .player-watchlist-list-icon {
            background: linear-gradient(135deg, #ff3b30 0%, #ff6b60 100%);
        }

        .player-watchlist-list-name {
            flex: 1;
            font-size: 15px;
            font-weight: 500;
        }

        .player-watchlist-list-arrow {
            color: var(--text-secondary, #aaa);
            opacity: 0;
            transform: translateX(-8px);
            transition: all 0.2s ease;
            font-size: 16px;
        }

        .player-watchlist-list-card:hover .player-watchlist-list-arrow {
            opacity: 1;
            transform: translateX(0);
        }

        .player-watchlist-create {
            padding: 14px 16px 16px;
            border-top: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.08));
        }

        .player-watchlist-input {
            width: 100%;
            padding: 12px 14px;
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid var(--border-subtle, rgba(255, 255, 255, 0.1));
            border-radius: 10px;
            color: var(--text-primary, #f5f5f7);
            font-size: 15px;
            margin-bottom: 10px;
            outline: none;
            transition: border-color 0.2s ease;
            box-sizing: border-box;
        }

        .player-watchlist-input:focus {
            border-color: var(--primary-color, #00ff9f);
        }

        .player-watchlist-input::placeholder {
            color: var(--text-secondary, #777);
        }

        .player-watchlist-create-btn {
            width: 100%;
            padding: 12px;
            background: var(--primary-color, #00ff9f);
            border: none;
            border-radius: 10px;
            color: var(--bg-dark, #0f0f1e);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-watchlist-create-btn:hover {
            opacity: 0.85;
            transform: translateY(-1px);
        }

        .backdrop-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            z-index: 1;
            pointer-events: none;
        }

        .backdrop-image::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(15, 15, 30, 0.4) 0%,
                rgba(15, 15, 30, 0.6) 50%,
                rgba(15, 15, 30, 0.8) 100%
            );
            backdrop-filter: blur(2px);
        }

        .backdrop-image.loaded {
            opacity: 1;
        }

        .player-bg-animation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .current-content > *:not(.backdrop-image):not(.player-bg-animation) {
            position: relative;
            z-index: 2;
        }

        .player-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: #000000;
            overflow: hidden;
            margin-bottom: 24px;
            border: none;
            box-shadow: none;
        }

        .player-container:fullscreen,
        .player-container:-webkit-full-screen,
        .player-container:-moz-full-screen,
        .player-container:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            margin: 0;
            border: none;
            box-shadow: none;
        }

        .player-container:fullscreen iframe,
        .player-container:-webkit-full-screen iframe,
        .player-container:-moz-full-screen iframe,
        .player-container:-ms-fullscreen iframe {
            width: 100%;
            height: 100%;
            border: none;
            box-shadow: none;
        }

        .player-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #666;
            font-size: 18px;
            text-align: center;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Fullscreen styles for iframe itself (mobile support) */
        iframe:fullscreen,
        iframe:-webkit-full-screen,
        iframe:-moz-full-screen,
        iframe:-ms-fullscreen {
            width: 100vw;
            height: 100vh;
            border: none;
            box-shadow: none;
        }

        .current-content {
            display: block;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
            border-radius: 12px;
            padding: 20px;
        }

        .standalone-poster {
            width: 180px;
            height: 270px;
            object-fit: cover;
            border-radius: 8px;
            background: #333;
            border: 3px solid var(--accent-color, #00d9ff);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
            margin-top: 10px;
            margin-bottom: 14px;
            margin-left: 32px;
            align-self: flex-start;
        }

        .player-heart-btn {
            position: absolute;
            top: 6px;
            right: 60px;
            z-index: 100;
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 0;
        }

        .player-heart-btn:hover {
            background: rgba(255, 70, 100, 0.15);
            border-color: rgba(255, 70, 100, 0.4);
            transform: scale(1.08);
        }

        .player-heart-btn img {
            width: 22px;
            height: 22px;
        }

        .current-content-info {
            display: flex;
            flex-direction: column;
            gap: 16px;
            min-width: 0;
            overflow: hidden;
        }

        .current-content-info h3 {
            font-family: 'VT323', monospace;
            margin: 0 0 4px 0;
            color: var(--primary-color, #00ff9f);
            text-shadow:
                2px 2px 0 var(--accent-color, #00d9ff),
                4px 4px 0 rgba(0, 0, 0, 0.3);
            font-weight: 600;
            font-size: 46px;
            text-align: center;
        }

        .current-content-info p#currentYear {
            font-family: 'VT323', monospace;
            color: var(--accent-color, #00d9ff);
            font-size: 32px;
            margin: 0;
            text-align: center;
        }

        .current-content-info p {
            font-family: 'VT323', monospace;
            color: var(--accent-color, #00d9ff);
            font-size: 24px;
            margin: 0;
        }

        /* --- User & friends ratings (UI) --- */
.rating-item.user-pill {
  display:flex; align-items:center; gap:8px; padding:8px 12px;
  border-radius:8px; background:rgba(255,255,255,0.06);
  border:1px solid rgba(255,255,255,0.12);
}
.rating-item.user-pill input[type="number"]{
  width:84px; padding:6px 8px; border-radius:6px;
  border:1px solid rgba(255,255,255,0.25); background:transparent; color:inherit;
}
.rating-item.user-pill .post-btn{
  padding:6px 10px; border-radius:6px;
  border:1px solid rgba(255,255,255,0.25);
  background:rgba(255,255,255,0.08); cursor:pointer;
  font-family:'VT323', monospace; font-size:18px;
  color:var(--primary-color, #00ff9f);
  transition:all 0.2s;
  box-shadow:0 0 10px rgba(255,255,255,0.15);
  margin-left:8px;
  margin-right:8px;
}
.rating-item.user-pill .post-btn:hover{
  background:rgba(255,255,255,0.12);
  box-shadow:0 0 15px rgba(255,255,255,0.25);
}
.rating-item.user-pill .post-btn:active{
  transform:scale(0.98);
}
.friends-ratings{ display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
.friend-pill{
  padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.15);
  background:rgba(255,255,255,0.04); font-size:14px; opacity:0.9;
}
.friend-pill b{ margin-left:4px; }

        /* OMDB Ratings Styles */
        .omdb-ratings {
            margin: 0;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .ratings-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .rating-item {
            font-family: 'VT323', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 20px;
            background: rgba(0, 122, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            min-width: 100px;
            transition: all 0.1s;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
        }

        .rating-item:hover {
            transform: translate(-2px, -2px);
            border-color: var(--primary-color, #00ff9f);
            box-shadow:
                5px 5px 0 rgba(0, 0, 0, 0.4),
                0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .rating-source {
            font-size: 22px;
            font-weight: 600;
            color: var(--accent-color, #00d9ff);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .rating-value {
            font-size: 36px;
            font-weight: 700;
            color: var(--primary-color, #00ff9f);
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        /* OMDB Details Styles */
        .omdb-details {
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 20px;
            background: rgba(0, 122, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
            text-align: center;
        }

        .detail-item {
            color: #f5f5f7;
            font-size: 26px;
            margin-bottom: 10px;
            line-height: 1.5;
            word-wrap: break-word;
            overflow-wrap: break-word;
            text-align: center;
        }

        .detail-item strong {
            color: var(--accent-color, #00d9ff);
            font-weight: 600;
            margin-right: 8px;
        }

        .detail-item span {
            color: #e5e5e7;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .detail-item.awards span {
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            font-weight: 600;
        }

        /* Cast Grid Styles */
        .cast-section {
            margin: 0;
            padding: 16px;
            background: rgba(0, 122, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
            width: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-top: 12px;
        }

        .cast-member {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s ease;
            min-width: 0;
            overflow: hidden;
            padding: 8px;
        }

        .cast-member:hover {
            transform: translateY(-4px);
        }

        .cast-member-image {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            border: 3px solid var(--primary-color, #00ff9f);
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.4));
            object-fit: cover;
            margin-bottom: 8px;
            background: var(--bg-dark, #0f0f1e);
        }

        .cast-member-image.placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: var(--primary-color, #00ff9f);
            background: var(--bg-medium, #1a1a2e);
        }

        .cast-member-name {
            font-family: 'VT323', monospace;
            font-size: 22px;
            color: var(--primary-color, #00ff9f);
            font-weight: 600;
            margin-bottom: 4px;
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        .cast-member-character {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--accent-color, #00d9ff);
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
        }

        /* Episode Description Styles */
        .episode-description {
            margin: 0;
            padding: 16px;
            background: rgba(0, 122, 255, 0.05);
            border-radius: 8px;
            width: 100%;
        }

        #episodeDescriptionText {
            font-family: 'VT323', monospace;
            font-size: 30px;
            line-height: 1.6;
            color: #e5e5e7;
            margin: 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        #currentOverview {
            font-family: 'VT323', monospace;
            font-size: 30px;
            line-height: 1.6;
            color: #e5e5e7;
            margin: 0;
            width: 100%;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            text-align: center;
        }

        .tv-controls {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 122, 255, 0.05) 0%, rgba(88, 86, 214, 0.05) 50%, rgba(175, 82, 222, 0.05) 100%);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.15);
            text-align: center;
            width: 100%;
        }

        .season-selector,
        .episode-selector {
            font-family: 'VT323', monospace;
            width: 200px;
            padding: 14px 18px;
            background: var(--bg-dark, #0f0f1e);
            border: 4px solid var(--primary-color, #00ff9f);
            border-style: solid;
            color: var(--primary-color, #00ff9f);
            font-size: 28px;
            font-weight: 600;
            margin: 8px 8px 8px 0;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow:
                4px 4px 0 var(--primary-glow, rgba(0, 255, 159, 0.3)),
                inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.4));
            image-rendering: pixelated;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .season-selector::before,
        .episode-selector::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            width: 4px;
            height: 4px;
            background: #00ff9f;
            box-shadow:
                calc(100% + 2px) 0 0 #00ff9f,
                0 calc(100% + 2px) 0 #00ff9f,
                calc(100% + 2px) calc(100% + 2px) 0 #00ff9f;
        }

        .episode-selector {
            width: 320px;
        }

        .season-selector:focus,
        .episode-selector:focus {
            outline: none;
            border-color: var(--secondary-color, #ff00ff);
            background: var(--bg-light, #16213e);
            box-shadow:
                4px 4px 0 var(--secondary-glow, rgba(255, 0, 255, 0.4)),
                inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                0 0 25px var(--secondary-glow, rgba(255, 0, 255, 0.6));
            animation: pulse-glow 1s ease-in-out infinite;
        }

        .season-selector:hover,
        .episode-selector:hover {
            border-color: var(--accent-color, #00d9ff);
            background: var(--bg-medium, #1a1a2e);
            box-shadow:
                4px 4px 0 rgba(0, 217, 255, 0.4),
                inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 217, 255, 0.5);
        }

        .episode-selector {
            max-height: 500px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #00ff9f #0f0f1e;
        }

        .episode-selector::-webkit-scrollbar {
            width: 12px;
        }

        .episode-selector::-webkit-scrollbar-track {
            background: var(--bg-dark, #0f0f1e);
            border: 3px solid var(--accent-color, #00d9ff);
        }

        .episode-selector::-webkit-scrollbar-thumb {
            background: var(--primary-color, #00ff9f);
            border: 2px solid var(--primary-color, #00ff9f);
            box-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .episode-selector::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color, #00d9ff);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.7);
        }

        .episode-selector option,
        .season-selector option {
            padding: 14px 16px !important;
            background: #0f0f1e !important;
            background-color: #0f0f1e !important;
            border-bottom: 2px solid #00d9ff !important;
            min-height: 55px;
            color: #00ff9f !important;
            font-weight: 500 !important;
            font-family: 'VT323', monospace !important;
            font-size: 22px !important;
            text-shadow: 2px 2px 0 rgba(0, 0, 0, 0.5) !important;
            border-left: none !important;
            border-right: none !important;
            border-top: none !important;
        }

        .episode-selector option:hover,
        .season-selector option:hover {
            background: #1a1a2e !important;
            background-color: #1a1a2e !important;
            color: #00d9ff !important;
            text-shadow: 0 0 8px rgba(0, 217, 255, 0.8), 2px 2px 0 rgba(0, 0, 0, 0.5) !important;
            box-shadow: inset 0 0 20px rgba(0, 217, 255, 0.3) !important;
        }

        .episode-selector option:checked,
        .season-selector option:checked {
            background: #00ff9f !important;
            background-color: #00ff9f !important;
            color: #0f0f1e !important;
            font-weight: 700 !important;
            text-shadow: 1px 1px 0 rgba(0, 217, 255, 0.5) !important;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.3) !important;
        }

        .episode-selector option:active,
        .season-selector option:active {
            background: #00ff9f !important;
            background-color: #00ff9f !important;
            color: #0f0f1e !important;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow:
                    4px 4px 0 rgba(255, 0, 255, 0.4),
                    inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                    0 0 25px rgba(255, 0, 255, 0.6);
            }
            50% {
                box-shadow:
                    4px 4px 0 rgba(255, 0, 255, 0.4),
                    inset 2px 2px 0 rgba(0, 0, 0, 0.5),
                    0 0 35px rgba(255, 0, 255, 0.8);
            }
        }

        .player-controls {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            position: relative;
            overflow: visible;
        }

        .player-controls-left,
        .player-controls-center,
        .player-controls-right {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .player-controls-left {
            justify-content: flex-start;
        }

        .player-controls-center {
            justify-content: center;
            flex: 1;
        }

        .player-controls-right {
            justify-content: flex-end;
        }

        .player-icon-btn {
            display: flex !important;
            align-items: center;
            justify-content: center;
            padding: 10px 14px !important;
        }

        .player-control-icon {
            width: 28px !important;
            height: 28px !important;
            margin: 0 !important;
            vertical-align: middle;
        }

        .loading {
            font-family: 'VT323', monospace;
            text-align: center;
            color: var(--primary-color, #00ff9f);
            font-size: 24px;
            padding: 20px;
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .error {
            font-family: 'VT323', monospace;
            background: var(--bg-medium, #1a1a2e);
            border: 3px solid #FF453A;
            color: #FF453A;
            padding: 16px 20px;
            margin: 12px 0;
            font-size: 20px;
            box-shadow:
                inset 1px 1px 0 rgba(0, 0, 0, 0.3),
                0 0 15px rgba(255, 69, 58, 0.4);
        }

        .status-bar {
            font-family: 'VT323', monospace;
            background: var(--bg-medium, #1a1a2e);
            padding: 12px 20px;
            margin-bottom: 24px;
            font-size: 22px;
            color: var(--primary-color, #00ff9f);
            border: 2px solid var(--accent-color, #00d9ff);
            box-shadow:
                inset 1px 1px 0 rgba(0, 0, 0, 0.3),
                0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .tab {
            font-family: 'VT323', monospace;
            padding: 10px 20px;
            background: var(--bg-medium, #1a1a2e);
            border: 3px solid var(--accent-color, #00d9ff);
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 22px;
            font-weight: 400;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .tab.active {
            background: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            border-color: var(--primary-color, #00ff9f);
            border-width: 3px;
            box-shadow: 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.8)),
                        inset 0 0 20px rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            font-weight: 600;
        }

        .tab:hover {
            background: var(--bg-light, #16213e);
            color: #fff;
            border-color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .tab.active:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            border-color: var(--accent-color, #00d9ff);
            box-shadow: 0 0 25px var(--secondary-glow, rgba(0, 217, 255, 0.6));
        }

        .section-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.5rem;
            font-weight: 400;
            line-height: 1.6;
            margin-bottom: 24px;
            color: var(--secondary-color, #ff00ff);
            text-shadow:
                2px 2px 0 var(--accent-color, #00d9ff),
                4px 4px 0 rgba(0, 0, 0, 0.3);
        }

        .watchlist-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 2px solid var(--accent-color, #00d9ff);
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 101;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
            opacity: 1;
            transform: scale(1);
        }

        .watchlist-btn:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            border-color: var(--accent-color, #00d9ff);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.6));
        }

        .watchlist-btn.added {
            background: var(--primary-color, #00ff9f);
            border-color: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .watchlist-btn.added:hover {
            background: var(--secondary-color, #ff00ff);
            border-color: var(--secondary-color, #ff00ff);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(255, 0, 255, 0.6));
        }

        .continue-watching-section, .watchlist-section {
            background: var(--bg-dark, #0f0f1e);
            border: 3px solid var(--secondary-color, #ff00ff);
            box-shadow:
                0 0 0 3px var(--bg-medium, #1a1a2e),
                0 0 15px var(--secondary-glow, rgba(255, 0, 255, 0.4)),
                inset 0 0 15px var(--secondary-glow, rgba(255, 0, 255, 0.1));
            padding: 32px;
            margin-bottom: 32px;
            position: relative;
        }

        .continue-watching-section::before,
        .continue-watching-section::after,
        .watchlist-section::before,
        .watchlist-section::after {
            content: '';
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--secondary-color, #ff00ff);
            box-shadow: 0 0 8px var(--secondary-color, #ff00ff);
        }

        .continue-watching-section::before,
        .watchlist-section::before {
            top: -3px;
            right: -3px;
        }

        .continue-watching-section::after,
        .watchlist-section::after {
            bottom: -3px;
            left: -3px;
        }

        .horizontal-scroll-container {
            display: none;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        #continueWatchingDisplay {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        @media (min-width: 1400px) {
            .horizontal-scroll-container {
                grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
                gap: 28px;
            }
        }

        .continue-item {
            background: var(--bg-dark, #0f0f1e);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.1s;
            border: 3px solid var(--accent-color, #00d9ff);
            position: relative;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.3));
            animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        .continue-item:hover {
            transform: translate(-3px, -3px);
            border-color: var(--primary-color, #00ff9f);
            box-shadow:
                9px 9px 0 rgba(0, 0, 0, 0.5),
                0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .continue-item:hover .watchlist-btn,
        .result-item:hover .watchlist-btn {
            opacity: 1;
            transform: scale(1);
        }

        .continue-item:hover .omdb-ratings-tooltip {
            display: block !important;
        }

        .continue-poster {
            width: 100%;
            height: 300px;
            object-fit: cover;
            background: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            transition: all 0.2s;
        }

        .continue-item:hover .continue-poster {
            filter: brightness(1.1);
        }

        .continue-info {
            padding: 15px;
        }

        .continue-title {
            font-weight: 600;
            font-size: 19px;
            margin-bottom: 5px;
            line-height: 1.3;
            color: var(--primary-color, #00ff9f);
        }

        .continue-progress {
            color: var(--accent-color, #00d9ff);
            font-size: 17px;
            margin-bottom: 8px;
        }

        .continue-last-watched {
            color: #888;
            font-size: 16px;
        }

        .continue-episode-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: var(--accent-color, #00d9ff);
            padding: 4px 8px;
            border: 2px solid var(--accent-color, #00d9ff);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .watchlist-remove-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 68, 68, 0.9);
            color: white;
            border: 2px solid #FF453A;
            width: 48px;
            height: 48px;
            cursor: pointer;
            font-size: 24px;
            transition: all 0.2s;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
            box-shadow: 0 0 10px rgba(255, 69, 58, 0.3);
        }

        .continue-item:hover .watchlist-remove-btn {
            display: flex;
        }

        .watchlist-remove-btn:hover {
            background: #FF453A;
            border-color: #FF453A;
            color: white;
            box-shadow: 0 0 15px rgba(255, 69, 58, 0.6);
        }

        .progress-bar {
            width: 100%;
            height: 3px;
            background: rgba(68, 68, 68, 0.5);
            border-radius: 2px;
            overflow: hidden;
            position: absolute;
            bottom: 0;
            left: 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color, #00ff9f), var(--accent-color, #00d9ff));
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .remove-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 16px;
            margin-left: 10px;
        }

        .remove-btn:hover {
            background: #ff6666;
        }

        @media (max-width: 1200px) {
            .container {
                padding: 24px 16px;
            }

            .header h1 {
                font-size: 3rem;
            }

            .search-section,
            .player-section,
            .continue-watching-section,
            .watchlist-section {
                padding: 32px 24px;
            }
        }

        /* Responsive design for content player */
        @media (max-width: 1200px) {
            .current-content {
                padding: 12px;
                gap: 12px;
            }

            .standalone-poster {
                width: 140px;
                height: 210px;
            }

            .current-content-info {
                gap: 12px;
                width: 100%;
            }

            .omdb-details,
            .cast-section,
            .episode-description,
            .tv-controls {
                width: 100%;
                box-sizing: border-box;
            }

            .omdb-details,
            .cast-section,
            .episode-description {
                padding: 12px;
            }

            .cast-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 15px;
            }

            .cast-member {
                padding: 5px;
            }

            .cast-member-name {
                font-size: 18px;
            }

            .cast-member-character {
                font-size: 16px;
            }

            .tv-controls {
                padding: 16px;
            }

            .detail-item {
                font-size: 16px;
                margin-bottom: 6px;
            }

            .tv-controls {
                padding: 12px;
                display: flex;
                flex-direction: column;
                align-items: stretch;
            }

            .season-selector,
            .episode-selector {
                width: 100%;
                max-width: 100%;
                min-width: unset;
                padding: 10px 14px;
                font-size: 20px;
                margin: 4px 0;
            }

            .bg-animation-toggle {
                padding: 10px 18px;
                font-size: 20px;
                width: 100%;
                max-width: 100%;
                min-width: unset;
                margin: 4px 0;
                box-sizing: border-box;
            }

            #seasonButton,
            #episodeButton {
                width: 100%;
                max-width: 100%;
                min-width: unset !important;
                margin: 4px 0 !important;
            }
        }

        /* Tablet breakpoint */
        @media (max-width: 768px) {
            .current-content {
                padding: 14px;
                gap: 14px;
            }

            .standalone-poster {
                width: 120px;
                height: 180px;
            }

            .current-content-info h3 {
                font-size: 1.5rem;
            }

            .current-content-info p {
                font-size: 20px;
            }

            .ratings-container {
                gap: 10px;
            }

            .rating-item {
                padding: 8px 14px;
                min-width: 80px;
            }

            .rating-source {
                font-size: 13px;
            }

            .rating-value {
                font-size: 22px;
            }

            .player-container {
                height: 400px;
            }

            .tv-controls {
                display: grid;
                grid-template-columns: auto 1fr;
                gap: 10px;
                padding: 14px;
            }

            #seasonButton {
                width: auto;
                min-width: 120px !important;
                margin: 0 !important;
            }

            #episodeButton {
                width: 100%;
                min-width: unset !important;
                margin: 0 !important;
            }

            .episode-description {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 480px) {
            .current-content {
                padding: 12px;
            }

            .standalone-poster {
                width: 90px;
                height: 135px;
                margin-bottom: 10px;
            }

            .current-content-info {
                gap: 6px;
                width: 100%;
                min-width: 0;
            }

            .current-content-info h3 {
                font-size: 1.1rem;
                text-align: left;
                margin: 0;
                line-height: 1.2;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }

            .current-content-info > p:first-of-type {
                text-align: left;
                font-size: 16px;
                margin: 0;
            }

            /* Ratings inline with title area */
            .omdb-ratings {
                margin-top: 8px;
            }

            .ratings-container {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                justify-content: center;
            }

            .rating-item {
                padding: 4px 10px;
                min-width: auto;
                flex-direction: row;
                gap: 6px;
            }

            .rating-source {
                font-size: 11px;
                margin-bottom: 0;
            }

            .rating-value {
                font-size: 16px;
            }

            /* Overview spans full width below */
            #currentOverview {
                font-size: 16px;
                line-height: 1.5;
                text-align: center;
                margin-top: 4px;
            }

            /* Details section - full width below poster/info */
            .omdb-details {
                grid-column: 1 / -1;
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
                margin-top: 8px;
            }

            .cast-section {
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
            }

            .episode-description {
                width: 100%;
                box-sizing: border-box;
                padding: 10px;
            }

            .detail-item {
                font-size: 19px;
                margin-bottom: 4px;
                display: flex;
                flex-wrap: wrap;
            }

            .detail-item strong {
                margin-right: 4px;
            }

            /* Cast grid compact */
            .cast-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
                gap: 8px;
            }

            .cast-member {
                padding: 4px;
            }

            .cast-member-image {
                width: 60px;
                height: 60px;
            }

            .cast-member-name {
                font-size: 12px;
            }

            .cast-member-character {
                font-size: 11px;
            }

            #episodeDescriptionText {
                font-size: 15px;
                line-height: 1.4;
            }

            /* TV Controls - horizontal on mobile */
            .tv-controls {
                padding: 10px;
                margin: 8px 0 0 0;
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                width: 100%;
                box-sizing: border-box;
            }

            #seasonButton,
            #episodeButton {
                width: 100%;
                max-width: 100%;
                min-width: unset !important;
                margin: 0 !important;
                padding: 10px 12px;
                font-size: 14px;
                text-align: center;
            }

            #episodeButton {
                grid-column: 1 / -1;
                text-align: left;
            }

            .episode-description {
                grid-column: 1 / -1;
                margin-top: 8px;
            }

            /* Player controls compact */
            .player-controls {
                flex-wrap: wrap;
                gap: 8px;
                padding: 12px;
            }

            .player-controls .btn {
                padding: 8px 12px;
                font-size: 14px;
            }

            /* Player container height */
            .player-container {
                height: 220px;
            }

            /* User rating pill compact */
            .rating-item.user-pill {
                flex-wrap: wrap;
                padding: 6px 10px;
                gap: 6px;
            }

            .rating-item.user-pill input[type="number"] {
                width: 60px;
                padding: 4px 6px;
            }

            .rating-item.user-pill .post-btn {
                padding: 4px 8px;
                font-size: 14px;
                margin: 0;
            }

            .friends-ratings {
                gap: 4px;
            }

            .friend-pill {
                padding: 2px 6px;
                font-size: 12px;
            }
        }

        /* Extra small screens */
        @media (max-width: 360px) {
            .current-content {
                padding: 10px;
                gap: 10px;
            }

            .standalone-poster {
                width: 75px;
                height: 112px;
            }

            .current-content-info h3 {
                font-size: 1rem;
            }

            .rating-item {
                padding: 3px 8px;
            }

            .rating-source {
                font-size: 10px;
            }

            .rating-value {
                font-size: 14px;
            }

            .player-container {
                height: 180px;
            }

            .tv-controls {
                grid-template-columns: 1fr;
            }

            #seasonButton {
                grid-column: 1;
            }
        }

        /* Advanced animations and effects */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -468px 0;
            }
            100% {
                background-position: 468px 0;
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes dockPanelIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px) scale(0.92);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        .container {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .header {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.2s both;
        }

        .continue-watching-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.3s both;
        }

        .watchlist-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.4s both;
        }

        .search-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.5s both;
        }

        .player-section {
            animation: fadeInUp 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94) 0.6s both;
        }

        .content-card {
            animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        .content-card:nth-child(2) { animation-delay: 0.1s; }
        .content-card:nth-child(3) { animation-delay: 0.2s; }
        .content-card:nth-child(4) { animation-delay: 0.3s; }
        .content-card:nth-child(5) { animation-delay: 0.4s; }
        .content-card:nth-child(6) { animation-delay: 0.5s; }

        .continue-item {
            animation: slideInFromRight 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) both;
        }

        .continue-item:nth-child(2) { animation-delay: 0.1s; }
        .continue-item:nth-child(3) { animation-delay: 0.2s; }
        .continue-item:nth-child(4) { animation-delay: 0.3s; }

        /* Removed white gradient shine effect */

        .loading {
            animation: pulse 1.5s ease-in-out infinite;
        }

        .content-poster {
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .content-card:hover .content-poster {
            transform: scale(1.05);
        }

        .continue-poster {
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .continue-item:hover .continue-poster {
            transform: scale(1.1);
        }

        .watchlist-btn {
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .content-type-badge {
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .content-card:hover .content-type-badge {
            transform: scale(1.1);
        }

        .status-bar {
            position: relative;
            overflow: hidden;
        }

        .status-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(0, 122, 255, 0) 0%,
                rgba(0, 122, 255, 0.1) 50%,
                rgba(0, 122, 255, 0) 100%);
            animation: shimmer 2s infinite;
        }

        /* Smooth scrolling */
        * {
            scroll-behavior: smooth;
        }

        /* Focus states */
        .btn:focus-visible {
            outline: 2px solid #007AFF;
            outline-offset: 2px;
        }

        .search-input:focus,
        .year-input:focus {
            transform: translateY(-1px);
        }

        /* Glass morphism enhancement */
        .search-section,
        .player-section,
        .continue-watching-section,
        .watchlist-section {
            position: relative;
        }

        .continue-watching-section::before,
        .watchlist-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: inherit;
            background: linear-gradient(135deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.05) 50%,
                rgba(255, 255, 255, 0.02) 100%);
            pointer-events: none;
        }


        /* Progress bar animation */
        .progress-fill {
            position: relative;
            overflow: hidden;
        }

        .progress-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 1.5s infinite;
        }

        /* ============= WATCHPARTY STYLES ============= */

        .watchparty-sidebar {
            position: fixed;
            top: 70px;
            right: 20px;
            width: 280px;
            max-width: 50vw;
            height: auto;
            max-height: 50vh;
            background: transparent;
            border: none;
            box-shadow: none;
            transition: all 0.2s;
            z-index: 100000;
            display: none;
            flex-direction: column;
            opacity: 0;
            transform: translateY(10px);
            overflow: hidden;
        }

        .watchparty-sidebar.active {
            display: flex;
            opacity: 1;
            transform: translateY(0);
        }

        .watchparty-sidebar.minimized {
            width: 60px;
            height: 60px;
            max-height: 60px;
            border-radius: 50%;
            overflow: hidden;
        }

        .watchparty-sidebar.minimized .watchparty-header,
        .watchparty-sidebar.minimized .watchparty-users,
        .watchparty-sidebar.minimized .watchparty-chat {
            display: none;
        }

        /* Fullscreen mode - sidebar moves into player */
        .watchparty-sidebar.fullscreen-mode {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2147483647;
            max-height: 50vh;
            pointer-events: auto;
        }

        .watchparty-sidebar.fullscreen-mode .chat-input {
            pointer-events: auto;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .watchparty-sidebar.fullscreen-mode * {
            pointer-events: auto;
        }

        .player-container:fullscreen iframe,
        .player-container:-webkit-full-screen iframe,
        .player-container:-moz-full-screen iframe,
        .player-container:-ms-fullscreen iframe,
        .player-container:fullscreen video,
        .player-container:-webkit-full-screen video,
        .player-container:-moz-full-screen video,
        .player-container:-ms-fullscreen video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .watchparty-header {
            padding: 12px;
            border-bottom: 2px solid var(--secondary-color, #ff00ff);
            background: transparent;
            position: relative;
        }

        .watchparty-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            font-weight: 400;
            color: var(--secondary-color, #ff00ff);
            margin: 0;
            text-shadow: 1px 1px 0 var(--accent-color, #00d9ff);
            white-space: nowrap;
        }

        .watchparty-room-code {
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: var(--accent-color, #00d9ff);
            margin: 0;
            white-space: nowrap;
        }

        .room-code-display {
            background: var(--bg-medium, #1a1a2e);
            border: 2px solid var(--primary-color, #00ff9f);
            padding: 4px 8px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            font-weight: 700;
            text-align: center;
            letter-spacing: 2px;
            color: var(--primary-color, #00ff9f);
            display: inline-block;
            cursor: pointer;
            box-shadow:
                2px 2px 0 rgba(0, 0, 0, 0.4),
                0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .room-code-display:hover {
            background: var(--bg-dark, #0f0f1e);
            transform: translate(1px, 1px);
            box-shadow:
                1px 1px 0 rgba(0, 0, 0, 0.4),
                0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .copy-room-code {
            display: none;
        }

        .watchparty-users {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 100px;
            overflow-y: auto;
        }

        .watchparty-users-title {
            font-size: 10px;
            font-weight: 600;
            color: #a1a1a6;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .user-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #007AFF, #5856D6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 11px;
        }

        .user-name {
            flex: 1;
            font-size: 12px;
            color: #f5f5f7;
        }

        .host-badge {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 700;
        }

        .watchparty-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .chat-message {
            display: flex;
            flex-direction: column;
            gap: 3px;
            padding: 8px 12px;
            background: rgba(26, 26, 46, 0.4);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .chat-message:hover {
            background: rgba(26, 26, 46, 0.6);
        }

        .chat-message:nth-child(odd) {
            background: rgba(15, 15, 30, 0.4);
        }

        .chat-message:nth-child(odd):hover {
            background: rgba(15, 15, 30, 0.6);
        }

        .reply-indicator {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 13px;
            color: var(--accent-color, #00d9ff);
            padding: 4px 8px;
            background: var(--secondary-glow, rgba(0, 217, 255, 0.2));
            border-left: 3px solid var(--accent-color, #00d9ff);
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reply-indicator button {
            background: transparent;
            border: none;
            color: var(--secondary-color, #ff00ff);
            cursor: pointer;
            font-size: 18px;
            padding: 0 4px;
            line-height: 1;
        }

        .reply-indicator button:hover {
            color: var(--primary-color, #00ff9f);
        }

        .replying-to {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            color: var(--accent-color, #00d9ff);
            font-style: italic;
            margin-bottom: 2px;
        }

        .chat-message-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .chat-username {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 15px;
            font-weight: 600;
        }

        .chat-timestamp {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 12px;
            color: #999;
        }

        .chat-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            color: #e0e0e0;
            background: transparent;
            border: none;
            padding: 0;
            line-height: 1.4;
        }

        .chat-input-container {
            padding: 12px;
            border-top: none;
            background: transparent;
        }

        .chat-input-wrapper {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            flex: 1;
            padding: 8px 12px;
            background: rgba(26, 26, 46, 0.4);
            border: none;
            color: var(--primary-color, #00ff9f);
            font-size: 14px;
            outline: none;
            border-radius: 4px;
        }

        .chat-input:focus {
            background: rgba(22, 33, 62, 0.5);
        }

        .chat-send-btn {
            display: none;
            box-shadow: 1px 1px 0 rgba(0, 0, 0, 0.4);
        }

        .chat-send-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 0 0 0 rgba(0, 0, 0, 0.4);
        }

        .watchparty-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            line-height: 1;
            flex-shrink: 0;
            z-index: 10;
            position: relative;
            pointer-events: auto;
        }

        .watchparty-close:hover {
            background: rgba(255, 59, 48, 0.8);
        }

        .sync-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 122, 255, 0.9);
            padding: 12px 24px;
            border-radius: 24px;
            color: white;
            font-size: 14px;
            font-weight: 600;
            z-index: 99997;
            display: none;
            animation: fadeIn 0.3s;
        }

        .sync-indicator.show {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Sync Status Badge */
        .sync-status-badge {
            display: none;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }
        .sync-status-badge.full {
            display: inline-block;
            background: rgba(0, 200, 83, 0.2);
            color: #00c853;
            border: 1px solid rgba(0, 200, 83, 0.4);
        }
        .sync-status-badge.coordinated {
            display: inline-block;
            background: rgba(255, 152, 0, 0.2);
            color: #ff9800;
            border: 1px solid rgba(255, 152, 0, 0.4);
        }

        /* Re-Sync Button */
        .resync-btn {
            display: none;
            width: 100%;
            padding: 8px 12px;
            margin-top: 6px;
            background: rgba(255, 152, 0, 0.15);
            border: 1px solid rgba(255, 152, 0, 0.4);
            color: #ff9800;
            font-size: 12px;
            font-weight: 600;
            border-radius: 6px;
            cursor: pointer;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            transition: all 0.2s;
        }
        .resync-btn:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        /* Ready Check Overlay */
        .sync-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 999999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }
        .sync-overlay.active { display: flex; }
        .sync-overlay h2 {
            color: #fff;
            font-size: 22px;
            margin: 0;
            text-align: center;
        }
        .sync-overlay p {
            color: rgba(255,255,255,0.7);
            font-size: 15px;
            margin: 0;
            text-align: center;
        }
        .sync-overlay .ready-count {
            color: #ff9800;
            font-size: 18px;
            font-weight: 700;
        }
        .sync-overlay .ready-btn {
            padding: 14px 40px;
            font-size: 16px;
            font-weight: 700;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #00c853;
            color: #fff;
            transition: all 0.2s;
        }
        .sync-overlay .ready-btn:hover { background: #00e676; }
        .sync-overlay .ready-btn:disabled {
            background: rgba(255,255,255,0.2);
            cursor: default;
        }
        .sync-overlay .force-start-btn {
            padding: 10px 24px;
            font-size: 13px;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
            color: rgba(255,255,255,0.6);
            transition: all 0.2s;
        }
        .sync-overlay .force-start-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
        }

        /* Countdown Overlay */
        .countdown-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
        }
        .countdown-overlay.active { display: flex; }
        .countdown-overlay .countdown-number {
            font-size: 120px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 40px rgba(255,152,0,0.6);
            animation: countdownPulse 1s ease-in-out;
        }
        .countdown-overlay .countdown-label {
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            margin-top: 10px;
        }
        @keyframes countdownPulse {
            0% { transform: scale(1.3); opacity: 0.5; }
            50% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.95); opacity: 0.8; }
        }

        /* ============= END WATCHPARTY STYLES ============= */

        /* ============= THEME SYSTEM ============= */

        /* Theme Selector Button */
        .theme-selector-btn {
            padding: 10px 16px;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 20px;
            color: var(--primary-color, #00ff9f);
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .theme-selector-btn:hover {
            background: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        /* Theme Selector Panel */
        .theme-selector-panel {
            position: fixed;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 3px solid var(--primary-color, #00ff9f);
            border-radius: 16px;
            padding: 20px;
            z-index: 100000;
            display: none;
            flex-direction: column;
            gap: 16px;
            min-width: 280px;
            box-shadow: 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .theme-selector-panel.active {
            display: flex;
            animation: slideInFromRight 0.3s ease-out;
        }

        /* Dock-active: reposition theme panel above dock */
        body.glass-dock-active .theme-selector-panel {
            right: auto !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            bottom: 110px !important;
            z-index: 199999 !important;
        }

        body.glass-dock-active .theme-selector-panel.active {
            animation: dockPanelIn 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.4) !important;
            transform: translateX(-50%) !important;
        }

        .theme-selector-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: var(--primary-color, #00ff9f);
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .theme-option {
            padding: 12px 16px;
            background: rgba(15, 15, 30, 0.6);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .theme-option:hover {
            transform: translateX(5px);
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.8);
        }

        .theme-option.active {
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.9);
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .theme-color-preview {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .theme-name {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #e0e0e0;
        }

        /* Theme: Matrix (Default) - Green/Cyan/Magenta */
        [data-theme="matrix"] {
            --primary-color: #00ff9f;
            --secondary-color: #ff00ff;
            --accent-color: #00d9ff;
            --bg-dark: #0f0f1e;
            --bg-medium: #1a1a2e;
            --bg-light: #16213e;
            --primary-glow: rgba(0, 255, 159, 0.4);
            --secondary-glow: rgba(255, 0, 255, 0.4);
        }

        /* Theme: Hacker - Pure Green Terminal */
        [data-theme="hacker"] {
            --primary-color: #00ff00;
            --secondary-color: #00cc00;
            --accent-color: #33ff33;
            --bg-dark: #000000;
            --bg-medium: #0a0a0a;
            --bg-light: #1a1a1a;
            --primary-glow: rgba(0, 255, 0, 0.4);
            --secondary-glow: rgba(0, 204, 0, 0.4);
        }

        [data-theme="hacker"] body {
            background: #000000;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 0, 0.03) 2px, rgba(0, 255, 0, 0.03) 4px);
            color: #00ff00;
        }

        /* Theme: Sunset - Orange/Pink/Purple */
        [data-theme="sunset"] {
            --primary-color: #ff6b35;
            --secondary-color: #ff006e;
            --accent-color: #ffbe0b;
            --bg-dark: #1a0a0a;
            --bg-medium: #2a1515;
            --bg-light: #3a2020;
            --primary-glow: rgba(255, 107, 53, 0.4);
            --secondary-glow: rgba(255, 0, 110, 0.4);
        }

        [data-theme="sunset"] body {
            background: #1a0a0a;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 107, 53, 0.03) 2px, rgba(255, 107, 53, 0.03) 4px);
            color: #ff6b35;
        }

        /* Theme: Vaporwave - Pink/Cyan/Purple */
        [data-theme="vaporwave"] {
            --primary-color: #ff00ff;
            --secondary-color: #00ffff;
            --accent-color: #ff71ce;
            --bg-dark: #0a0a1a;
            --bg-medium: #1a0a2e;
            --bg-light: #2a1a3e;
            --primary-glow: rgba(255, 0, 255, 0.4);
            --secondary-glow: rgba(0, 255, 255, 0.4);
        }

        [data-theme="vaporwave"] body {
            background: #0a0a1a;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 0, 255, 0.03) 2px, rgba(255, 0, 255, 0.03) 4px);
            color: #ff00ff;
        }

        /* Theme: Ocean - Blue/Teal/Aqua */
        [data-theme="ocean"] {
            --primary-color: #00d4ff;
            --secondary-color: #00ffc8;
            --accent-color: #0088ff;
            --bg-dark: #001a2e;
            --bg-medium: #00243e;
            --bg-light: #003a5e;
            --primary-glow: rgba(0, 212, 255, 0.4);
            --secondary-glow: rgba(0, 255, 200, 0.4);
        }

        [data-theme="ocean"] body {
            background: #001a2e;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 212, 255, 0.03) 2px, rgba(0, 212, 255, 0.03) 4px);
            color: #00d4ff;
        }

        /* Theme: Dracula - Purple/Pink/Red */
        [data-theme="dracula"] {
            --primary-color: #bd93f9;
            --secondary-color: #ff79c6;
            --accent-color: #ff5555;
            --bg-dark: #1e1e2e;
            --bg-medium: #282a36;
            --bg-light: #44475a;
            --primary-glow: rgba(189, 147, 249, 0.4);
            --secondary-glow: rgba(255, 121, 198, 0.4);
        }

        [data-theme="dracula"] body {
            background: #1e1e2e;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(189, 147, 249, 0.03) 2px, rgba(189, 147, 249, 0.03) 4px);
            color: #bd93f9;
        }

        /* Theme: Midnight Oil - Deep Navy/Gold */
        [data-theme="midnight"] {
            --primary-color: #ffd700;
            --secondary-color: #ffb700;
            --accent-color: #ffa500;
            --bg-dark: #0a1628;
            --bg-medium: #152238;
            --bg-light: #1f2e48;
            --primary-glow: rgba(255, 215, 0, 0.4);
            --secondary-glow: rgba(255, 183, 0, 0.4);
        }

        [data-theme="midnight"] body {
            background: #0a1628;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 215, 0, 0.03) 2px, rgba(255, 215, 0, 0.03) 4px);
            color: #ffd700;
        }

        /* Theme: J's Special - Rainbow Multicolor */
        [data-theme="jspecial"] {
            --primary-color: #ff1493;
            --secondary-color: #00ff00;
            --accent-color: #00d4ff;
            --bg-dark: #0a0a0a;
            --bg-medium: #1a1a1a;
            --bg-light: #2a2a2a;
            --primary-glow: rgba(255, 20, 147, 0.5);
            --secondary-glow: rgba(0, 255, 0, 0.5);
        }

        [data-theme="jspecial"] body {
            background: #000;
            background-image:
                linear-gradient(45deg, rgba(255, 20, 147, 0.1) 0%, rgba(0, 255, 255, 0.1) 25%, rgba(0, 255, 0, 0.1) 50%, rgba(255, 165, 0, 0.1) 75%, rgba(138, 43, 226, 0.1) 100%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255, 255, 255, 0.02) 2px, rgba(255, 255, 255, 0.02) 4px);
            color: #fff;
        }

        /* J's Special - Rainbow buttons and elements */
        [data-theme="jspecial"] .btn:nth-child(10n+1),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+1) {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+2),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+2) {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border-color: #00bfff;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+3),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+3) {
            background: linear-gradient(135deg, #00ff00, #7fff00);
            border-color: #00ff00;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+4),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+4) {
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            border-color: #ff8c00;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+5),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+5) {
            background: linear-gradient(135deg, #8a2be2, #9370db);
            border-color: #8a2be2;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+6),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+6) {
            background: linear-gradient(135deg, #ffff00, #ffd700);
            border-color: #ffff00;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+7),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+7) {
            background: linear-gradient(135deg, #ff0000, #ff6347);
            border-color: #ff0000;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+8),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+8) {
            background: linear-gradient(135deg, #00ffff, #40e0d0);
            border-color: #00ffff;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+9),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+9) {
            background: linear-gradient(135deg, #ff00ff, #da70d6);
            border-color: #ff00ff;
            color: #000;
        }

        [data-theme="jspecial"] .btn:nth-child(10n+10),
        [data-theme="jspecial"] .nav-btn:nth-child(10n+10) {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            border-color: #ff69b4;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+1) {
            background: linear-gradient(135deg, #adff2f, #7fff00);
            border-color: #adff2f;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+2) {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+3) {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border-color: #00bfff;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+4) {
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            border-color: #ff8c00;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+5) {
            background: linear-gradient(135deg, #8a2be2, #9370db);
            border-color: #8a2be2;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+6) {
            background: linear-gradient(135deg, #ffff00, #ffd700);
            border-color: #ffff00;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+7) {
            background: linear-gradient(135deg, #ff0000, #ff6347);
            border-color: #ff0000;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+8) {
            background: linear-gradient(135deg, #00ffff, #40e0d0);
            border-color: #00ffff;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+9) {
            background: linear-gradient(135deg, #ff00ff, #da70d6);
            border-color: #ff00ff;
            color: #000;
        }

        [data-theme="jspecial"] .effects-btn:nth-child(10n+10) {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            border-color: #ff69b4;
            color: #000;
        }

        [data-theme="jspecial"] .content-card {
            border-color: #ff00ff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 0, 255, 0.5);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+3) {
            border-color: #00ff00;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+4) {
            border-color: #ffa500;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 165, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+5) {
            border-color: #8a2be2;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(138, 43, 226, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+6) {
            border-color: #ffff00;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+7) {
            border-color: #ff0000;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 0, 0, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+8) {
            border-color: #00ffff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 255, 255, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+9) {
            border-color: #ff00ff;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 0, 255, 0.6);
        }

        [data-theme="jspecial"] .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow:
                6px 6px 0 rgba(0, 0, 0, 0.5),
                0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Search Results */
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] .search-results .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Recommendations */
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] #recommendations .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Movies Tab */
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] #movies-content .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful TV Shows Tab */
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+3) {
            border-color: #ffd700;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+4) {
            border-color: #ff6b35;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+5) {
            border-color: #00ff9f;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+6) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+7) {
            border-color: #7fff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(127, 255, 0, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+8) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+9) {
            border-color: #00d9ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 217, 255, 0.6);
        }
        [data-theme="jspecial"] #tvshows-content .content-card:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        [data-theme="jspecial"] .header {
            border: none;
            background: transparent;
            box-shadow: none;
        }

        [data-theme="jspecial"] h1 {
            color: #ff1493;
            text-shadow:
                2px 2px 0 #00ffff,
                4px 4px 0 #00ff00,
                6px 6px 0 #ffa500,
                8px 8px 10px rgba(0, 0, 0, 0.5);
        }

        [data-theme="jspecial"] .search-container input {
            border-color: #ff00ff;
            color: #fff;
            background: #1a1a1a;
        }

        [data-theme="jspecial"] .search-container input:focus {
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        [data-theme="jspecial"] .content-title {
            color: #00ffff;
        }

        [data-theme="jspecial"] .content-year {
            color: #ffa500;
        }

        [data-theme="jspecial"] .watchlist-btn {
            border-color: #ff1493;
            background: rgba(255, 20, 147, 0.2);
        }

        [data-theme="jspecial"] .watchlist-btn:hover {
            background: #ff1493;
            box-shadow: 0 0 20px #ff1493;
        }

        [data-theme="jspecial"] .imdb-btn {
            background: linear-gradient(135deg, #ff00ff, #ff1493);
            border-color: #ff00ff;
        }

        [data-theme="jspecial"] .bg-animation-toggle {
            background: linear-gradient(135deg, #8a2be2, #9370db);
            border-color: #8a2be2;
            color: #000;
        }

        [data-theme="jspecial"] .theme-selector-btn {
            background: linear-gradient(135deg, #00ff00, #7fff00);
            border-color: #00ff00;
            color: #000;
        }

        [data-theme="jspecial"] .genre-btn {
            background: linear-gradient(135deg, #ff8c00, #ffa500);
            border-color: #ff8c00;
            color: #000;
        }

        [data-theme="jspecial"] .status-bar {
            background: linear-gradient(90deg, #ff1493, #00ffff, #00ff00, #ffa500, #8a2be2);
        }

        [data-theme="jspecial"] .omdb-ratings-tooltip {
            border-color: #00ffff;
            background: rgba(10, 10, 10, 0.98);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        /* Continue watching, search results, and other items */
        [data-theme="jspecial"] .continue-item:nth-child(10n+1),
        [data-theme="jspecial"] .result-item:nth-child(10n+1) {
            border-color: #ff1493;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+2),
        [data-theme="jspecial"] .result-item:nth-child(10n+2) {
            border-color: #00bfff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+3),
        [data-theme="jspecial"] .result-item:nth-child(10n+3) {
            border-color: #00ff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+4),
        [data-theme="jspecial"] .result-item:nth-child(10n+4) {
            border-color: #ffa500;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 165, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+5),
        [data-theme="jspecial"] .result-item:nth-child(10n+5) {
            border-color: #8a2be2;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(138, 43, 226, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+6),
        [data-theme="jspecial"] .result-item:nth-child(10n+6) {
            border-color: #ffff00;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+7),
        [data-theme="jspecial"] .result-item:nth-child(10n+7) {
            border-color: #ff0000;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 0, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+8),
        [data-theme="jspecial"] .result-item:nth-child(10n+8) {
            border-color: #00ffff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 255, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+9),
        [data-theme="jspecial"] .result-item:nth-child(10n+9) {
            border-color: #ff00ff;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 0, 255, 0.6);
        }

        [data-theme="jspecial"] .continue-item:nth-child(10n+10),
        [data-theme="jspecial"] .result-item:nth-child(10n+10) {
            border-color: #ff69b4;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 105, 180, 0.6);
        }

        /* J's Special - Colorful Particles */
        [data-theme="jspecial"] .particle:nth-child(10n+1) {
            background: #ff1493;
            box-shadow: 0 0 15px #ff1493, 0 0 30px #ff1493, 0 0 45px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+2) {
            background: #00bfff;
            box-shadow: 0 0 15px #00bfff, 0 0 30px #00bfff, 0 0 45px #00bfff, 0 0 60px #00bfff;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+3) {
            background: #ffd700;
            box-shadow: 0 0 15px #ffd700, 0 0 30px #ffd700, 0 0 45px #ffd700, 0 0 60px #ffd700;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+4) {
            background: #ff6b35;
            box-shadow: 0 0 15px #ff6b35, 0 0 30px #ff6b35, 0 0 45px #ff6b35, 0 0 60px #ff6b35;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+5) {
            background: #00ff9f;
            box-shadow: 0 0 15px #00ff9f, 0 0 30px #00ff9f, 0 0 45px #00ff9f, 0 0 60px #00ff9f;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+6) {
            background: #ff00ff;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #ff00ff, 0 0 45px #ff00ff, 0 0 60px #ff00ff;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+7) {
            background: #7fff00;
            box-shadow: 0 0 15px #7fff00, 0 0 30px #7fff00, 0 0 45px #7fff00, 0 0 60px #7fff00;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+8) {
            background: #ff1493;
            box-shadow: 0 0 15px #ff1493, 0 0 30px #ff1493, 0 0 45px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+9) {
            background: #00d9ff;
            box-shadow: 0 0 15px #00d9ff, 0 0 30px #00d9ff, 0 0 45px #00d9ff, 0 0 60px #00d9ff;
        }
        [data-theme="jspecial"] .particle:nth-child(10n+10) {
            background: #ff69b4;
            box-shadow: 0 0 15px #ff69b4, 0 0 30px #ff69b4, 0 0 45px #ff69b4, 0 0 60px #ff69b4;
        }

        /* J's Special - Colorful Stars */
        [data-theme="jspecial"] .pixel-star:nth-child(10n+1) {
            background: #ff1493;
            box-shadow: 0 0 10px #ff1493, 0 0 20px #ff1493, 0 0 30px #ff1493, 0 0 40px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+2) {
            background: #00bfff;
            box-shadow: 0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff, 0 0 60px #00bfff;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+3) {
            background: #ffd700;
            box-shadow: 0 0 10px #ffd700, 0 0 20px #ffd700, 0 0 30px #ffd700, 0 0 40px #ffd700, 0 0 60px #ffd700;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+4) {
            background: #ff6b35;
            box-shadow: 0 0 10px #ff6b35, 0 0 20px #ff6b35, 0 0 30px #ff6b35, 0 0 40px #ff6b35, 0 0 60px #ff6b35;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+5) {
            background: #00ff9f;
            box-shadow: 0 0 10px #00ff9f, 0 0 20px #00ff9f, 0 0 30px #00ff9f, 0 0 40px #00ff9f, 0 0 60px #00ff9f;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+6) {
            background: #ff00ff;
            box-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff, 0 0 60px #ff00ff;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+7) {
            background: #7fff00;
            box-shadow: 0 0 10px #7fff00, 0 0 20px #7fff00, 0 0 30px #7fff00, 0 0 40px #7fff00, 0 0 60px #7fff00;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+8) {
            background: #ff1493;
            box-shadow: 0 0 10px #ff1493, 0 0 20px #ff1493, 0 0 30px #ff1493, 0 0 40px #ff1493, 0 0 60px #ff1493;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+9) {
            background: #00d9ff;
            box-shadow: 0 0 10px #00d9ff, 0 0 20px #00d9ff, 0 0 30px #00d9ff, 0 0 40px #00d9ff, 0 0 60px #00d9ff;
        }
        [data-theme="jspecial"] .pixel-star:nth-child(10n+10) {
            background: #ff69b4;
            box-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4, 0 0 30px #ff69b4, 0 0 40px #ff69b4, 0 0 60px #ff69b4;
        }

        /* J's Special - Colorful Tab Buttons (Continue Watching, My Watchlist, Stats) */
        [data-theme="jspecial"] .tab:nth-child(1) {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border-color: #ff1493;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(2) {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border-color: #00bfff;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(3) {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            border-color: #ffd700;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(4) {
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border-color: #ff6b35;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(5) {
            background: linear-gradient(135deg, #00ff9f, #00d4aa);
            border-color: #00ff9f;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(6) {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
        }
        [data-theme="jspecial"] .tab:nth-child(7) {
            background: linear-gradient(135deg, #7fff00, #65d900);
            border-color: #7fff00;
            color: #000;
        }

        /* J's Special - Active tab state */
        [data-theme="jspecial"] .tab.active {
            border-width: 4px;
            transform: scale(1.08);
            box-shadow: 0 0 30px currentColor, inset 0 0 30px rgba(255, 255, 255, 0.4);
            font-weight: 700;
        }

        /* J's Special - Colorful bg-animation-toggle buttons (Season, Episode, Popular, Trending, etc) */
        [data-theme="jspecial"] #seasonButton {
            background: linear-gradient(135deg, #ff6b35, #ff8c42);
            border-color: #ff6b35;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.6);
        }
        [data-theme="jspecial"] #episodeButton {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
        }
        /* genre/language filter chip theme overrides moved to .filter-chip section */

        /* J's Special - Party and Effects buttons */
        [data-theme="jspecial"] .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
            background: linear-gradient(135deg, #ff00ff, #d946ef);
            border-color: #ff00ff;
            color: #000;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
        }
        [data-theme="jspecial"] .bg-animation-toggle[onclick*="toggleEffectsPanel"] {
            background: linear-gradient(135deg, #7fff00, #65d900);
            border-color: #7fff00;
            color: #000;
            box-shadow: 0 0 15px rgba(127, 255, 0, 0.6);
        }

        /* J's Special - Search Button */
        [data-theme="jspecial"] #searchBtn {
            background: linear-gradient(135deg, #00d9ff, #00bfff);
            border-color: #00d9ff;
            color: #fff;
        }

        /* J's Special - Colorful Container Borders in Content Player */
        [data-theme="jspecial"] .current-content {
            border: 3px solid #ffd700;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        [data-theme="jspecial"] .omdb-ratings {
            border: none;
            border-radius: 12px;
            padding: 16px;
            box-shadow: none;
        }

        /* J's Special - Colorful Rating Items */
        [data-theme="jspecial"] .rating-item:nth-child(1) {
            background: rgba(255, 215, 0, 0.08);
            border: 3px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
        }

        [data-theme="jspecial"] .rating-item:nth-child(2) {
            background: rgba(255, 20, 147, 0.08);
            border: 3px solid #ff1493;
            box-shadow: 0 0 15px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .rating-item:nth-child(3) {
            background: rgba(0, 191, 255, 0.08);
            border: 3px solid #00bfff;
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .omdb-details {
            background: rgba(0, 255, 159, 0.08);
            border: none;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
        }

        [data-theme="jspecial"] .cast-section {
            background: rgba(255, 0, 255, 0.08);
            border: none;
            border-radius: 12px;
            padding: 16px;
            box-shadow: none;
        }

        [data-theme="jspecial"] .tv-controls {
            border: none;
            box-shadow: none;
        }

        [data-theme="jspecial"] .episode-description {
            background: rgba(0, 191, 255, 0.08);
        }

        /* J's Special - All Buttons with Black Text */
        [data-theme="jspecial"] .btn,
        [data-theme="jspecial"] .btn-secondary {
            color: #000000;
        }

        [data-theme="jspecial"] .btn:hover,
        [data-theme="jspecial"] .btn-secondary:hover {
            color: #000000;
        }

        /* J's Special - Theme Selector button animation */
        [data-theme="jspecial"] .theme-selector-btn {
            background: linear-gradient(135deg, #ff1493, #00bfff, #ffd700, #00ff9f, #ff00ff);
            background-size: 300% 300%;
            animation: rainbowShift 3s ease infinite;
        }

        @keyframes rainbowShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* J's Special - User Menu Dropdown */
        [data-theme="jspecial"] .user-menu-dropdown {
            background: linear-gradient(145deg, rgba(15, 15, 30, 0.98), rgba(30, 15, 45, 0.98));
            border: 3px solid #ff1493;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.5), 0 0 60px rgba(0, 191, 255, 0.3);
        }

        [data-theme="jspecial"] .user-menu-item {
            color: #fff;
        }

        [data-theme="jspecial"] .user-menu-item:hover {
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.3), rgba(0, 191, 255, 0.3));
            border-color: #00bfff;
        }

        [data-theme="jspecial"] .user-menu-divider {
            background: linear-gradient(90deg, #ff1493, #00bfff, #ffd700);
            opacity: 0.6;
        }

        [data-theme="jspecial"] .user-menu-username {
            color: #ffd700;
            border-bottom-color: rgba(255, 215, 0, 0.4);
        }

        /* J's Special - Popup Panels (Theme, Effects, Party) positioned near user menu */
        [data-theme="jspecial"] .theme-selector-panel,
        [data-theme="jspecial"] #bgEffectsPanel,
        [data-theme="jspecial"] #watchpartyPanel {
            position: fixed !important;
            left: 20px !important;
            right: auto !important;
            top: 70px !important;
            bottom: auto !important;
            width: 340px;
            background: linear-gradient(145deg, rgba(15, 15, 30, 0.98), rgba(30, 15, 45, 0.98));
            border: 3px solid #ff1493;
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.5), 0 0 60px rgba(0, 191, 255, 0.3);
            backdrop-filter: blur(20px);
            transform: scale(0);
            transform-origin: top left;
            opacity: 0;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s ease;
            z-index: 100003;
            overflow: hidden;
            display: flex !important;
            flex-direction: column;
            visibility: hidden;
            pointer-events: none;
        }

        [data-theme="jspecial"] .theme-selector-panel.active,
        [data-theme="jspecial"] #bgEffectsPanel.active,
        [data-theme="jspecial"] #watchpartyPanel.active {
            transform: scale(1);
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        /* J's Special - Panel Headers */
        [data-theme="jspecial"] .theme-selector-panel .theme-selector-title,
        [data-theme="jspecial"] .bg-effects-panel .bg-effects-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 2px solid rgba(255, 20, 147, 0.4);
            background: linear-gradient(135deg, rgba(255, 20, 147, 0.2), rgba(0, 191, 255, 0.2));
            margin: 0;
        }

        [data-theme="jspecial"] .theme-selector-title .title-text,
        [data-theme="jspecial"] .bg-effects-title .title-text {
            color: #ffd700;
            font-weight: 600;
        }

        /* Theme: Phosphor Burn - Modern Minimalist Warm Amber */
        [data-theme="phosphor"] {
            --primary-color: #F5A623;
            --primary-muted: #D4912A;
            --secondary-color: #E8DCC4;
            --accent-color: #C7956D;
            --bg-dark: #1A1714;
            --bg-medium: #242019;
            --bg-light: #2E2A24;
            --bg-elevated: #3A352E;
            --text-primary: #F5F0E8;
            --text-secondary: #A39E94;
            --border-subtle: rgba(245, 166, 35, 0.15);
            --shadow-color: rgba(0, 0, 0, 0.4);
            --primary-glow: rgba(245, 166, 35, 0.3);
            --secondary-glow: rgba(232, 220, 196, 0.2);
        }

        [data-theme="phosphor"] body {
            background: var(--bg-dark);
            background-image: none;
            color: var(--text-primary);
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            animation: none !important;
        }

        /* Phosphor Modern - Typography */
        [data-theme="phosphor"] * {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        /* Phosphor Modern - Header */
        [data-theme="phosphor"] .header h1 {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            font-weight: 600;
            letter-spacing: -0.02em;
            color: var(--primary-color);
            text-shadow: none;
            animation: none;
        }

        [data-theme="phosphor"] .header p {
            font-family: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
            color: var(--text-secondary);
            text-shadow: none;
        }

        /* ============= HERO HEADER SECTION ============= */
        .hero-header {
            text-align: center;
            padding: 40px 20px 0;
            margin-bottom: 0;
        }

        .hero-nav-section {
            text-align: center;
            padding: 0 20px 20px;
            margin-bottom: 20px;
            width: 100%;
        }

        .hero-title-section {
            margin-bottom: 40px;
        }

        .hero-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 2.8rem;
            color: var(--primary-color, #F5A623);
            text-shadow:
                0 0 20px rgba(245, 166, 35, 0.6),
                0 0 40px rgba(245, 166, 35, 0.4),
                0 0 60px rgba(245, 166, 35, 0.2);
            margin-bottom: 16px;
            letter-spacing: 0.05em;
            animation: heroGlow 3s ease-in-out infinite alternate;
        }

        @keyframes heroGlow {
            0% { text-shadow: 0 0 20px rgba(245, 166, 35, 0.6), 0 0 40px rgba(245, 166, 35, 0.4); }
            100% { text-shadow: 0 0 30px rgba(245, 166, 35, 0.8), 0 0 60px rgba(245, 166, 35, 0.5), 0 0 80px rgba(245, 166, 35, 0.3); }
        }

        .hero-subtitle {
            font-family: 'VT323', monospace;
            font-size: 1.4rem;
            color: rgba(245, 166, 35, 0.7);
            letter-spacing: 0.15em;
            text-transform: lowercase;
        }

        /* Movies & TV Shows Navigation Buttons */
        .hero-nav-buttons {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 250px;
            margin-top: 30px;
            padding: 0 40px;
        }

        .hero-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 20px 30px;
            background: linear-gradient(145deg, rgba(26, 20, 8, 0.9) 0%, rgba(15, 12, 5, 0.95) 100%);
            border: 3px solid rgba(40, 32, 12, 0.6);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow:
                0 0 20px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.3),
                0 0 50px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.15),
                0 0 80px hsl(calc(var(--glow-hue) * 1deg) 100% 40% / 0.08);
            position: relative;
            overflow: hidden;
            animation: glowing-hue 4s linear infinite;
        }

        .hero-nav-btn:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow:
                0 0 30px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.5),
                0 0 60px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.3),
                0 0 100px hsl(calc(var(--glow-hue) * 1deg) 100% 40% / 0.15),
                0 0 calc(var(--white-shadow) * 1vw) calc(var(--white-shadow) * 0.15vw) rgb(255 255 255 / 20%),
                0 15px 40px rgba(0, 0, 0, 0.4);
            animation: glowing-hue 4s linear infinite, shadow-pulse 8s linear infinite;
        }

        .hero-nav-btn:active {
            transform: translateY(-4px) scale(1.02);
        }

        /* Active/Selected state for Movies/Shows buttons */
        .hero-nav-btn.active {
            background: linear-gradient(145deg, rgba(40, 32, 10, 0.95) 0%, rgba(25, 20, 8, 0.98) 100%);
            box-shadow:
                0 0 35px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.45),
                0 0 70px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.25),
                0 0 100px hsl(calc(var(--glow-hue) * 1deg) 100% 40% / 0.12),
                0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .hero-nav-btn.active .hero-nav-icon {
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
        }

        .hero-nav-btn.active .hero-nav-label {
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .hero-nav-icon {
            width: 64px;
            height: 64px;
            filter: drop-shadow(0 0 10px rgba(245, 166, 35, 0.5));
            transition: all 0.3s ease;
        }

        .hero-nav-btn:hover .hero-nav-icon {
            transform: scale(1.1);
            filter: drop-shadow(0 0 20px rgba(245, 166, 35, 0.8));
        }

        .hero-nav-label {
            font-family: 'VT323', monospace;
            font-size: 1.3rem;
            color: var(--primary-color, #F5A623);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-shadow: 0 0 10px rgba(245, 166, 35, 0.5);
        }

        .hero-nav-btn:hover .hero-nav-label {
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        /* ============= RADIAL MENU SYSTEM ============= */
        .radial-menu-container {
            position: relative;
            display: inline-block;
        }

        .radial-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }

        .radial-menu.active {
            pointer-events: auto;
        }

        .radial-option {
            position: absolute;
            width: 110px;
            height: 110px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background:
                linear-gradient(145deg, rgba(15, 15, 30, 0.95) 0%, rgba(26, 26, 46, 0.98) 100%) padding-box,
                linear-gradient(45deg, #fb0094, #0000ff, #00ff00, #ffff00, #ff0000, #fb0094, #0000ff, #00ff00, #ffff00, #ff0000) border-box;
            background-size: 100%, 400%;
            border: 2px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            transform: translate(-50%, -50%) scale(0);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            box-shadow:
                0 0 15px rgba(251, 0, 148, 0.2),
                0 0 25px rgba(0, 0, 255, 0.1);
            text-decoration: none;
            animation: rainbow 20s linear infinite;
        }

        .radial-option:hover {
            transform: translate(-50%, -50%) scale(1.15) !important;
            box-shadow:
                0 0 25px rgba(251, 0, 148, 0.4),
                0 0 40px rgba(0, 0, 255, 0.2),
                0 0 55px rgba(0, 255, 0, 0.15);
        }

        .radial-option:active {
            transform: translate(-50%, -50%) scale(1.05) !important;
        }

        /* Active/Selected state for radial menu options */
        .radial-option.selected {
            background-image:
                linear-gradient(145deg, rgba(40, 32, 10, 0.95) 0%, rgba(25, 20, 8, 0.98) 100%),
                linear-gradient(45deg, #fb0094, #0000ff, #00ff00, #ffff00, #ff0000, #fb0094, #0000ff, #00ff00, #ffff00, #ff0000);
            box-shadow:
                0 0 30px rgba(251, 0, 148, 0.4),
                0 0 50px rgba(0, 0, 255, 0.25),
                0 0 65px rgba(255, 215, 0, 0.2);
        }

        .radial-option.selected .radial-option-icon {
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
        }

        .radial-option.selected .radial-option-label {
            color: #FFD700;
            text-shadow: 0 0 12px rgba(255, 215, 0, 0.7);
        }

        .radial-option-icon {
            width: 40px;
            height: 40px;
            margin-bottom: 4px;
            filter: drop-shadow(0 0 6px rgba(0, 217, 255, 0.5));
            transition: all 0.3s ease;
        }

        .radial-option:hover .radial-option-icon {
            transform: scale(1.15);
            filter: drop-shadow(0 0 10px rgba(0, 255, 159, 0.7));
        }

        .radial-option-label {
            font-family: 'VT323', monospace;
            font-size: 16px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            text-align: center;
            line-height: 1.2;
            text-shadow: 0 0 8px rgba(0, 217, 255, 0.5);
        }

        .radial-option:hover .radial-option-label {
            color: #00ff9f;
            text-shadow: 0 0 12px rgba(0, 255, 159, 0.7);
        }

        /* Radial positions for Movies (3 options) - triangle layout, ~0.7cm gap from button */
        .radial-menu.active .radial-option:nth-child(1) {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            top: -150px;
            left: 0;
            transition-delay: 0s;
        }
        .radial-menu.active .radial-option:nth-child(2) {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            top: 80px;
            left: -140px;
            transition-delay: 0.05s;
        }
        .radial-menu.active .radial-option:nth-child(3) {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            top: 80px;
            left: 140px;
            transition-delay: 0.1s;
        }

        /* TV Shows has 3 options - triangle layout, ~0.7cm gap from button */
        .radial-menu.tv-menu.active .radial-option:nth-child(1) {
            top: -150px;
            left: 0;
        }
        .radial-menu.tv-menu.active .radial-option:nth-child(2) {
            top: 80px;
            left: -140px;
        }
        .radial-menu.tv-menu.active .radial-option:nth-child(3) {
            top: 80px;
            left: 140px;
        }

        /* Backdrop overlay when menu is open */
        .radial-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .radial-backdrop.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Pulse animation for active button */
        .hero-nav-btn.menu-open {
            animation: glowing-hue 4s linear infinite, radialPulse 1.5s infinite;
            z-index: 1001;
        }

        @keyframes radialPulse {
            0%, 100% {
                box-shadow:
                    0 0 25px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.4),
                    0 0 50px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.2);
            }
            50% {
                box-shadow:
                    0 0 45px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.6),
                    0 0 80px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.3);
            }
        }

        @keyframes rainbow {
            0% { background-position: 0 0, 0% 0; }
            50% { background-position: 0 0, 400% 0; }
            100% { background-position: 0 0, 0% 0; }
        }

        /* Glowing Shadow @property declarations */
        @property --glow-hue {
            syntax: "<number>";
            inherits: true;
            initial-value: 0;
        }
        @property --white-shadow {
            syntax: "<number>";
            inherits: true;
            initial-value: 0;
        }

        @keyframes glowing-hue {
            0% { --glow-hue: 0; }
            100% { --glow-hue: 360; }
        }

        @keyframes shadow-pulse {
            0%, 24%, 46%, 73%, 96% { --white-shadow: 0.5; }
            12%, 28%, 41%, 63%, 75%, 82%, 98% { --white-shadow: 2.5; }
            6%, 32%, 57% { --white-shadow: 1.3; }
            18%, 52%, 88% { --white-shadow: 3.5; }
        }

        /* Phosphor Theme Specific Hero Overrides */
        [data-theme="phosphor"] .hero-header {
            padding: 60px 20px 0;
        }

        [data-theme="phosphor"] .hero-title {
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            font-size: 3.5rem;
            letter-spacing: -0.02em;
        }

        [data-theme="phosphor"] .hero-subtitle {
            font-family: 'Outfit', sans-serif;
            font-weight: 400;
            font-size: 1.2rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        [data-theme="phosphor"] .hero-nav-btn {
            border-radius: 20px;
            padding: 24px 36px;
        }

        [data-theme="phosphor"] .hero-nav-label {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 1.1rem;
        }

        /* Responsive Hero */
        @media (max-width: 768px) {
            .hero-header {
                padding: 24px 12px 0;
                margin-bottom: 0;
            }

            .hero-nav-section {
                padding: 0 12px 16px;
                margin-bottom: 12px;
            }

            .hero-title {
                font-size: 1.8rem;
            }

            .hero-subtitle {
                font-size: 1rem;
            }

            .hero-nav-buttons {
                gap: 16px;
                flex-wrap: wrap;
                padding: 0 12px;
            }

            .hero-nav-btn {
                padding: 14px 20px;
                gap: 8px;
            }

            .hero-nav-icon {
                width: 44px;
                height: 44px;
            }

            .hero-nav-label {
                font-size: 1rem;
            }

            /* Radial menu options - tablet */
            .radial-option {
                width: 85px;
                height: 85px;
            }

            .radial-option-icon {
                width: 32px;
                height: 32px;
            }

            .radial-option-label {
                font-size: 10px;
            }

            .radial-menu.active .radial-option:nth-child(1) {
                top: -120px;
                left: 0;
            }

            .radial-menu.active .radial-option:nth-child(2) {
                top: 60px;
                left: -110px;
            }

            .radial-menu.active .radial-option:nth-child(3) {
                top: 60px;
                left: 110px;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(1) {
                top: -120px;
                left: 0;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(2) {
                top: 60px;
                left: -110px;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(3) {
                top: 60px;
                left: 110px;
            }

            /* Section header bar - tablet */
            .section-header-bar {
                max-width: 440px;
                padding: 12px 20px;
                margin-bottom: 14px;
            }

            .section-title {
                font-size: 1.2rem;
            }

            /* Filter chips - tablet */
            #contentTypeFilters {
                gap: 8px;
            }

            .filter-chip {
                padding: 8px 16px 8px 14px;
                font-size: 18px;
            }

            .filter-chip .filter-chip-icon-img {
                width: 20px;
                height: 20px;
            }

            /* User menu - tablet */
            .user-menu-container {
                top: 12px;
                left: 12px;
            }

            .user-menu-btn {
                padding: 10px 12px;
                font-size: 20px;
            }

            .user-menu-btn img {
                width: 24px !important;
                height: 24px !important;
            }

            /* Friend request icon - tablet */
            .friend-request-notification-left {
                margin-left: 8px;
            }

            .friend-request-notification-left img {
                width: 28px;
                height: 28px;
            }

            .friend-request-notification-left .request-count-badge {
                min-width: 16px;
                height: 16px;
                font-size: 10px;
            }

            /* Watchlist container - tablet */
            .watchlist-container {
                top: 72px;
                left: 12px;
            }

            .watchlist-trigger-btn {
                padding: 10px 16px;
                font-size: 15px;
            }

            .watchlist-trigger-btn img {
                width: 18px !important;
                height: 18px !important;
            }

            .watchlist-slide-panel {
                width: calc(100vw - 40px);
                max-width: 340px;
            }

            /* Live container - tablet */
            .live-container {
                top: 12px;
                right: 12px;
            }

            #liveTriggerBtn img {
                width: 48px !important;
                height: 48px !important;
            }

            .live-slide-panel {
                width: calc(100vw - 40px);
                max-width: 320px;
            }

            /* Content grid - tablet */
            .content-results {
                gap: 16px;
            }

            #continueWatchingDisplay,
            .horizontal-scroll-container {
                gap: 16px;
            }
        }

        @media (max-width: 480px) {
            .hero-header {
                padding: 16px 8px 0;
                margin-bottom: 0;
            }

            .hero-nav-section {
                padding: 0 8px 12px;
                margin-bottom: 8px;
            }

            .hero-title {
                font-size: 1.4rem;
            }

            .hero-subtitle {
                font-size: 0.85rem;
                letter-spacing: 0.1em;
            }

            .hero-nav-buttons {
                gap: 12px;
                padding: 0 8px;
            }

            .hero-nav-btn {
                padding: 12px 16px;
                gap: 6px;
                border-width: 2px;
                border-radius: 12px;
            }

            .hero-nav-icon {
                width: 36px;
                height: 36px;
            }

            .hero-nav-label {
                font-size: 0.85rem;
            }

            /* Radial menu options - mobile */
            .radial-option {
                width: 72px;
                height: 72px;
                border-width: 2px;
            }

            .radial-option-icon {
                width: 26px;
                height: 26px;
                margin-bottom: 2px;
            }

            .radial-option-label {
                font-size: 9px;
            }

            .radial-menu.active .radial-option:nth-child(1) {
                top: -100px;
                left: 0;
            }

            .radial-menu.active .radial-option:nth-child(2) {
                top: 50px;
                left: -88px;
            }

            .radial-menu.active .radial-option:nth-child(3) {
                top: 50px;
                left: 88px;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(1) {
                top: -100px;
                left: 0;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(2) {
                top: 50px;
                left: -88px;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(3) {
                top: 50px;
                left: 88px;
            }

            /* Section header bar - mobile */
            .section-header-bar {
                max-width: 100%;
                padding: 10px 16px;
                margin-bottom: 12px;
                margin-left: 8px;
                margin-right: 8px;
                border-radius: 10px;
            }

            .section-title {
                font-size: 1.05rem;
                letter-spacing: 0.1em;
            }

            /* Filter chips - mobile */
            #contentTypeFilters {
                gap: 6px;
            }

            .filter-chip {
                padding: 6px 14px 6px 10px;
                font-size: 16px;
                gap: 6px;
            }

            .filter-chip .filter-chip-icon-img {
                width: 18px;
                height: 18px;
            }

            /* User menu - mobile */
            .user-menu-container {
                top: 8px;
                left: 8px;
            }

            .user-menu-btn {
                padding: 8px 10px;
                font-size: 18px;
                border-radius: 50px;
                gap: 6px;
            }

            .user-menu-btn img {
                width: 22px !important;
                height: 22px !important;
            }

            .user-menu-dropdown {
                min-width: 170px;
            }

            .user-menu-item {
                padding: 10px 12px;
                font-size: 17px;
            }

            /* Watchlist container - mobile */
            .watchlist-container {
                top: 58px;
                left: 8px;
            }

            .watchlist-trigger-btn {
                padding: 8px 12px;
                font-size: 14px;
                border-radius: 8px;
                gap: 6px;
            }

            .watchlist-trigger-btn img {
                width: 16px !important;
                height: 16px !important;
            }

            .watchlist-slide-panel {
                width: calc(100vw - 24px);
                max-width: none;
                left: -8px;
            }

            /* Live container - mobile */
            .live-container {
                top: 8px;
                right: 8px;
            }

            #liveTriggerBtn img {
                width: 40px !important;
                height: 40px !important;
            }

            .live-slide-panel {
                width: calc(100vw - 24px);
                max-width: none;
                right: -8px;
            }

            .live-option-btn.live-option-btn-icon-only img {
                width: 40px !important;
                height: 40px !important;
            }

            /* Content grid - mobile */
            .content-results {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
            }

            #continueWatchingDisplay,
            .horizontal-scroll-container {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
                margin: 12px 0;
            }
        }

        @media (max-width: 360px) {
            .hero-title {
                font-size: 1.2rem;
            }

            .hero-nav-buttons {
                gap: 10px;
                padding: 0 4px;
            }

            .hero-nav-btn {
                padding: 10px 14px;
                gap: 5px;
            }

            .hero-nav-icon {
                width: 30px;
                height: 30px;
            }

            .hero-nav-label {
                font-size: 0.75rem;
            }

            /* Radial menu - very small screens */
            .radial-option {
                width: 62px;
                height: 62px;
            }

            .radial-option-icon {
                width: 22px;
                height: 22px;
                margin-bottom: 1px;
            }

            .radial-option-label {
                font-size: 8px;
            }

            .radial-menu.active .radial-option:nth-child(1) {
                top: -85px;
                left: 0;
            }

            .radial-menu.active .radial-option:nth-child(2) {
                top: 42px;
                left: -75px;
            }

            .radial-menu.active .radial-option:nth-child(3) {
                top: 42px;
                left: 75px;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(1) {
                top: -85px;
                left: 0;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(2) {
                top: 42px;
                left: -75px;
            }

            .radial-menu.tv-menu.active .radial-option:nth-child(3) {
                top: 42px;
                left: 75px;
            }

            .section-header-bar {
                padding: 8px 12px;
            }

            .section-title {
                font-size: 0.95rem;
            }

            .user-menu-btn {
                padding: 6px 8px;
                font-size: 16px;
            }

            .user-menu-btn img {
                width: 20px !important;
                height: 20px !important;
            }

            .watchlist-container {
                top: 50px;
            }

            .watchlist-trigger-btn {
                padding: 6px 10px;
                font-size: 13px;
            }

            #liveTriggerBtn img {
                width: 34px !important;
                height: 34px !important;
            }

            .content-results,
            #continueWatchingDisplay,
            .horizontal-scroll-container {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 10px;
            }
        }
        /* ============= END HERO HEADER SECTION ============= */

        /* Section Header Bar */
        .section-header-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px 24px;
            margin-bottom: 20px;
            margin-left: auto;
            margin-right: auto;
            max-width: 580px;
            position: relative;
            background: linear-gradient(145deg, rgba(26, 20, 8, 0.8) 0%, rgba(15, 12, 5, 0.9) 100%);
            border: 2px solid rgba(40, 32, 12, 0.6);
            border-radius: 12px;
            box-shadow:
                0 0 18px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.25),
                0 0 45px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.12),
                0 0 70px hsl(calc(var(--glow-hue) * 1deg) 100% 40% / 0.06);
            transition: all 0.3s ease;
            animation: glowing-hue 4s linear infinite;
        }

        .section-header-bar:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow:
                0 0 30px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.45),
                0 0 60px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.25),
                0 0 90px hsl(calc(var(--glow-hue) * 1deg) 100% 40% / 0.12),
                0 0 calc(var(--white-shadow) * 1vw) calc(var(--white-shadow) * 0.15vw) rgb(255 255 255 / 20%),
                0 10px 30px rgba(0, 0, 0, 0.4);
            animation: glowing-hue 4s linear infinite, shadow-pulse 8s linear infinite;
        }

        .section-header-bar:hover .section-title {
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        /* Active state for Continue Watching */
        .section-header-bar.active {
            background: linear-gradient(145deg, rgba(40, 32, 10, 0.9) 0%, rgba(25, 20, 8, 0.95) 100%);
            box-shadow:
                0 0 35px hsl(calc(var(--glow-hue) * 1deg) 100% 60% / 0.45),
                0 0 65px hsl(calc(var(--glow-hue) * 1deg) 100% 50% / 0.25),
                0 0 95px hsl(calc(var(--glow-hue) * 1deg) 100% 40% / 0.12),
                0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .section-header-bar.active .section-title {
            color: #FFD700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .section-title {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--primary-color, #F5A623);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            text-shadow: 0 0 10px rgba(245, 166, 35, 0.5);
            margin: 0;
        }

        [data-theme="phosphor"] .section-header-bar {
            background: var(--bg-elevated, #3A352E);
            border: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.15));
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        [data-theme="phosphor"] .section-title {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 1.2rem;
            letter-spacing: 0.1em;
            text-shadow: none;
        }

        /* J's Special - Section Header Layout (same as Phosphor) */
        [data-theme="jspecial"] .section-header-bar {
            max-width: 580px;
            margin-left: auto;
            margin-right: auto;
            border-radius: 16px;
            transition: all 0.3s ease;
        }

        [data-theme="jspecial"] .section-header-bar:hover {
            transform: translateY(-2px);
        }

        /* J's Special - Continue Watching Display Layout */
        [data-theme="jspecial"] #continueWatchingDisplay {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 24px;
            margin: 24px 0;
        }

        /* Phosphor Modern - Buttons (Flat, Refined) */
        [data-theme="phosphor"] .btn,
        [data-theme="phosphor"] .nav-btn {
            background: var(--primary-color);
            border: none;
            border-radius: 8px;
            color: var(--bg-dark);
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            padding: 12px 24px;
            box-shadow: none;
            transition: background 0.2s ease, transform 0.1s ease;
        }

        [data-theme="phosphor"] .btn:hover,
        [data-theme="phosphor"] .nav-btn:hover {
            background: var(--primary-muted);
            transform: translateY(-1px);
            box-shadow: none;
        }

        [data-theme="phosphor"] .btn:active,
        [data-theme="phosphor"] .nav-btn:active {
            transform: translateY(0);
        }

        [data-theme="phosphor"] .btn::before,
        [data-theme="phosphor"] .nav-btn::before {
            display: none;
        }

        [data-theme="phosphor"] .btn-secondary {
            background: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            box-shadow: none;
        }

        [data-theme="phosphor"] .btn-secondary:hover {
            background: rgba(245, 166, 35, 0.1);
            border-color: var(--primary-color);
            color: var(--primary-color);
            box-shadow: none;
        }

        /* Phosphor Modern - Effects buttons */
        [data-theme="phosphor"] .effects-btn {
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(245, 166, 35, 0.3);
            color: var(--primary-color, #F5A623);
            font-family: 'VT323', monospace;
            font-size: 16px;
            border-radius: 8px;
            padding: 10px 14px;
            margin: 4px 8px;
            transition: all 0.2s ease;
        }

        [data-theme="phosphor"] .effects-btn:hover {
            background: rgba(245, 166, 35, 0.15);
            border-color: rgba(245, 166, 35, 0.5);
            transform: translateX(4px);
        }

        [data-theme="phosphor"] .effects-btn.active {
            background: rgba(245, 166, 35, 0.2);
            border-color: var(--primary-color, #F5A623);
            box-shadow: 0 0 15px rgba(245, 166, 35, 0.3);
        }

        /* Phosphor Modern - Content Cards (Clean, Minimal) */
        [data-theme="phosphor"] .content-card {
            background: var(--bg-light);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-color);
            position: relative;
            overflow: visible;
            animation: none;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        [data-theme="phosphor"] .content-card .content-poster {
            border-radius: 12px 12px 0 0;
            overflow: hidden;
        }

        [data-theme="phosphor"] .content-card::before,
        [data-theme="phosphor"] .content-card::after {
            display: none !important;
        }

        [data-theme="phosphor"] .content-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px var(--shadow-color);
            border-color: var(--primary-color);
        }

        [data-theme="phosphor"] .content-card .rating {
            background: var(--primary-color);
            color: var(--bg-dark);
            box-shadow: none;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            border-radius: 6px;
        }

        [data-theme="phosphor"] .content-card h3 {
            color: var(--text-primary);
            text-shadow: none;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
        }

        [data-theme="phosphor"] .content-card p,
        [data-theme="phosphor"] .content-card .year {
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
        }

        [data-theme="phosphor"] .content-card .content-poster {
            filter: none;
            border-radius: 10px 10px 0 0;
        }

        /* Phosphor Modern - Input fields */
        [data-theme="phosphor"] input[type="text"],
        [data-theme="phosphor"] input[type="search"],
        [data-theme="phosphor"] .search-input {
            background: var(--bg-medium);
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            box-shadow: none;
        }

        [data-theme="phosphor"] input[type="text"]:focus,
        [data-theme="phosphor"] input[type="search"]:focus,
        [data-theme="phosphor"] .search-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(245, 166, 35, 0.1);
            outline: none;
        }

        [data-theme="phosphor"] input::placeholder {
            color: var(--text-secondary);
        }

        /* Phosphor Modern - Modals and panels */
        [data-theme="phosphor"] .modal-content,
        [data-theme="phosphor"] .panel {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
        }

        [data-theme="phosphor"] .theme-selector-panel,
        [data-theme="phosphor"] .effects-panel,
        [data-theme="phosphor"] .bg-effects-panel {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
        }

        /* Phosphor Modern - Theme selector button - HIDDEN */
        [data-theme="phosphor"] .theme-selector-btn {
            display: none !important;
        }

        /* Phosphor Modern - Scrollbar */
        [data-theme="phosphor"] ::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }

        [data-theme="phosphor"] ::-webkit-scrollbar-track {
            background: var(--bg-medium);
            border-radius: 4px;
        }

        [data-theme="phosphor"] ::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        [data-theme="phosphor"] ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-muted);
        }

        /* Phosphor Modern - Category tabs and filters */
        [data-theme="phosphor"] .category-tab,
        [data-theme="phosphor"] .filter-btn {
            background: transparent;
            border: 1px solid var(--border-subtle);
            border-radius: 8px;
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
            transition: all 0.2s ease;
        }

        [data-theme="phosphor"] .category-tab:hover,
        [data-theme="phosphor"] .filter-btn:hover,
        [data-theme="phosphor"] .category-tab.active,
        [data-theme="phosphor"] .filter-btn.active {
            background: var(--primary-color);
            color: var(--bg-dark);
            border-color: var(--primary-color);
            box-shadow: none;
        }

        /* Phosphor Modern - Navigation and links */
        [data-theme="phosphor"] a {
            color: var(--primary-color);
        }

        [data-theme="phosphor"] a:hover {
            color: var(--primary-muted);
            text-shadow: none;
        }

        /* ============= PHOSPHOR MODERN MINIMALIST REDESIGN ============= */

        /* Hide existing search bar in phosphor theme */
        [data-theme="phosphor"] .search-section {
            display: none !important;
        }

        /* Show floating search only, HIDE all CRT effects */
        [data-theme="phosphor"] .floating-search,
        [data-theme="phosphor"] .floating-watchlist {
            display: block;
        }

        /* Hide ALL retro CRT elements for modern look */
        [data-theme="phosphor"] .crt-scanlines-overlay,
        [data-theme="phosphor"] .crt-curvature-overlay,
        [data-theme="phosphor"] .crt-power-led,
        [data-theme="phosphor"] .crt-boot-overlay {
            display: none !important;
        }

        /* Hide external control buttons in phosphor theme - moved to user menu */
        [data-theme="phosphor"] .bg-animation-toggle[onclick*="toggleWatchpartyPanel"],
        [data-theme="phosphor"] .bg-animation-toggle[onclick*="toggleEffectsPanel"],
        [data-theme="phosphor"] div[style*="position: fixed"][style*="top: 20px"][style*="right: 20px"],
        [data-theme="phosphor"] div[style*="position: fixed"][style*="bottom: 20px"][style*="right: 20px"] {
            display: none !important;
        }

        /* CRT Boot Sequence Overlay */
        .crt-boot-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 999999;
            pointer-events: none;
        }

        .crt-boot-overlay.active {
            pointer-events: all;
        }

        .crt-boot-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .crt-boot-line {
            width: 0;
            height: 3px;
            background: #ffb000;
            box-shadow: 0 0 20px #ffb000, 0 0 40px #ffb000;
            margin: 0 auto 30px;
            transition: width 0.5s ease-out;
        }

        .crt-boot-line.expanding {
            width: 80vw;
        }

        .crt-boot-text {
            font-family: 'VT323', monospace;
            color: #ffb000;
            font-size: 24px;
            text-shadow: 0 0 10px #ffb000;
            white-space: pre-wrap;
            text-align: left;
            max-width: 600px;
            margin: 0 auto;
        }

        /* CRT Scanlines Overlay */
        .crt-scanlines-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99998;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            animation: scanlineMove 0.1s linear infinite;
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* CRT Curvature/Vignette Overlay */
        .crt-curvature-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99997;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 60%,
                rgba(0, 0, 0, 0.3) 80%,
                rgba(0, 0, 0, 0.7) 100%
            );
        }

        /* Screen Flicker Effect */
        [data-theme="phosphor"] body {
            animation: screenFlicker 8s ease-in-out infinite;
        }

        @keyframes screenFlicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.95; }
            94% { opacity: 1; }
            95% { opacity: 0.97; }
            96% { opacity: 1; }
        }

        /* Floating Search Styles */
        .floating-search {
            display: none;
            position: absolute;
            right: 20px;
            top: 100px;
            z-index: 100000;
        }

        .floating-search-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ffb000 0%, #cc8c00 100%);
            border: 3px solid #ffb000;
            color: #0a0800;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(255, 176, 0, 0.5),
                        inset 0 2px 0 rgba(255, 255, 255, 0.3),
                        inset 0 -2px 0 rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        .floating-search-btn:hover {
            background: linear-gradient(145deg, #33ff66 0%, #28cc52 100%);
            border-color: #33ff66;
            box-shadow: 0 0 30px rgba(51, 255, 102, 0.6);
            transform: scale(1.1);
        }

        .floating-search-btn svg {
            width: 28px;
            height: 28px;
        }

        .floating-search-panel {
            position: absolute;
            right: 0;
            top: 70px;
            transform: scaleY(0);
            transform-origin: top right;
            width: 400px;
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid #ffb000;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 176, 0, 0.4),
                        inset 0 0 60px rgba(255, 176, 0, 0.05);
            opacity: 0;
            overflow: hidden;
        }

        .floating-search-panel.active {
            transform: scaleY(1);
            opacity: 1;
        }

        .floating-search-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 2px solid rgba(255, 176, 0, 0.3);
            background: rgba(255, 176, 0, 0.1);
        }

        .terminal-prompt {
            font-family: 'VT323', monospace;
            color: #33ff66;
            font-size: 24px;
            text-shadow: 0 0 8px rgba(51, 255, 102, 0.5);
        }

        .floating-search-close {
            background: none;
            border: none;
            color: #ffb000;
            font-size: 32px;
            cursor: pointer;
            padding: 12px 16px;
            line-height: 1;
            transition: all 0.2s;
            margin: -8px -12px -8px 0;
        }

        .floating-search-close:hover {
            color: #33ff66;
            text-shadow: 0 0 10px rgba(51, 255, 102, 0.8);
        }

        .floating-search-input-wrapper {
            display: flex;
            align-items: center;
            padding: 20px;
            gap: 12px;
        }

        .terminal-cursor {
            font-family: 'VT323', monospace;
            color: #33ff66;
            font-size: 28px;
            animation: cursorBlink 1s step-end infinite;
        }

        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .floating-search-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #ffb000;
            font-family: 'VT323', monospace;
            font-size: 28px;
            outline: none;
            caret-color: #33ff66;
            padding: 8px 0;
        }

        .floating-search-input::placeholder {
            color: rgba(255, 176, 0, 0.4);
        }

        .floating-search-results {
            max-height: min(450px, calc(100vh - 300px));
            overflow-y: auto;
            border-top: 1px solid rgba(255, 176, 0, 0.2);
        }

        .floating-search-results::-webkit-scrollbar {
            width: 8px;
        }

        .floating-search-results::-webkit-scrollbar-track {
            background: #0a0800;
        }

        .floating-search-results::-webkit-scrollbar-thumb {
            background: #ffb000;
        }

        .floating-search-result-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 176, 0, 0.1);
            transition: all 0.2s;
        }

        .floating-search-result-item:hover {
            background: rgba(255, 176, 0, 0.15);
        }

        .floating-search-result-item img {
            width: 80px;
            height: 120px;
            object-fit: cover;
            border: 1px solid #ffb000;
            border-radius: 4px;
        }

        .floating-search-result-info {
            flex: 1;
        }

        .floating-search-result-title {
            color: #ffb000;
            font-family: 'VT323', monospace;
            font-size: 22px;
        }

        .floating-search-result-year {
            color: rgba(51, 255, 102, 0.7);
            font-family: 'VT323', monospace;
            font-size: 18px;
        }

        /* Floating Search Clear Button */
        .floating-search-clear {
            background: none;
            border: none;
            color: rgba(255, 176, 0, 0.5);
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            line-height: 1;
            transition: all 0.2s;
            display: none;
            flex-shrink: 0;
        }

        .floating-search-clear:hover {
            color: #ff6666;
            text-shadow: 0 0 8px rgba(255, 102, 102, 0.6);
        }

        .floating-search-clear.visible {
            display: block;
        }

        /* Floating Search Watchlist Heart Button */
        .floating-search-watchlist-btn {
            flex-shrink: 0;
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
        }

        .floating-search-watchlist-btn:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .floating-search-watchlist-btn img {
            width: 22px !important;
            height: 22px !important;
            object-fit: contain !important;
            border: none !important;
            border-radius: 0 !important;
        }

        /* Power LED Indicator */
        .crt-power-led {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 12px;
            height: 12px;
            background: #33ff66;
            border-radius: 50%;
            box-shadow: 0 0 10px #33ff66, 0 0 20px #33ff66;
            animation: powerLedPulse 2s ease-in-out infinite;
            z-index: 99999;
        }

        @keyframes powerLedPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 10px #33ff66, 0 0 20px #33ff66; }
            50% { opacity: 0.7; box-shadow: 0 0 5px #33ff66, 0 0 10px #33ff66; }
        }

        /* Phosphor Theme - Enhanced Content Cards (Mini CRT Monitors) */
        [data-theme="phosphor"] .content-card {
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid #ffb000;
            border-radius: 8px;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5),
                        0 0 15px rgba(255, 176, 0, 0.3),
                        inset 0 0 30px rgba(255, 176, 0, 0.05);
            position: relative;
            overflow: visible;
            transition: all 0.3s ease;
        }

        /* Card Power LED */
        [data-theme="phosphor"] .content-card::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            width: 8px;
            height: 8px;
            background: #33ff66;
            border-radius: 50%;
            box-shadow: 0 0 8px #33ff66;
            z-index: 10;
            animation: cardLedPulse 3s ease-in-out infinite;
        }

        @keyframes cardLedPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Card CRT Screen Effect (poster area) */
        [data-theme="phosphor"] .content-card .content-poster {
            position: relative;
            filter: contrast(1.1) saturate(0.9);
        }

        [data-theme="phosphor"] .content-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.1) 0px,
                    rgba(0, 0, 0, 0.1) 1px,
                    transparent 1px,
                    transparent 2px
                ),
                radial-gradient(
                    ellipse at center,
                    transparent 0%,
                    transparent 50%,
                    rgba(0, 0, 0, 0.2) 100%
                );
            pointer-events: none;
            z-index: 5;
            border-radius: 5px;
        }

        [data-theme="phosphor"] .content-card:hover {
            border-color: #33ff66;
            box-shadow: 6px 6px 0 rgba(0, 0, 0, 0.5),
                        0 0 30px rgba(51, 255, 102, 0.5),
                        inset 0 0 40px rgba(51, 255, 102, 0.1);
            transform: translate(-3px, -3px);
        }

        /* Phosphor ghost/trail effect on hover */
        [data-theme="phosphor"] .content-card:hover .content-poster {
            animation: phosphorTrail 0.3s ease-out;
        }

        @keyframes phosphorTrail {
            0% { filter: contrast(1.1) saturate(0.9) brightness(1); }
            50% { filter: contrast(1.3) saturate(1.2) brightness(1.2); }
            100% { filter: contrast(1.1) saturate(0.9) brightness(1); }
        }

        /* Enhanced Phosphor Buttons */
        [data-theme="phosphor"] .btn,
        [data-theme="phosphor"] .nav-btn {
            background: linear-gradient(180deg, #ffb000 0%, #cc8c00 50%, #a37000 100%);
            border: 3px solid #ffb000;
            border-top-color: #ffd466;
            border-left-color: #ffd466;
            border-bottom-color: #996600;
            border-right-color: #996600;
            color: #0a0800;
            font-family: 'VT323', monospace;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 0 #664400,
                        0 0 15px rgba(255, 176, 0, 0.4),
                        inset 0 1px 0 rgba(255, 255, 255, 0.3);
            transition: all 0.15s ease;
            position: relative;
            overflow: hidden;
        }

        /* Light sweep animation on hover */
        [data-theme="phosphor"] .btn::before,
        [data-theme="phosphor"] .nav-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            transition: left 0.4s ease;
        }

        [data-theme="phosphor"] .btn:hover::before,
        [data-theme="phosphor"] .nav-btn:hover::before {
            left: 100%;
        }

        [data-theme="phosphor"] .btn:hover,
        [data-theme="phosphor"] .nav-btn:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 50%, #1fa342 100%);
            border-color: #33ff66;
            border-top-color: #7fff99;
            border-left-color: #7fff99;
            border-bottom-color: #1a8035;
            border-right-color: #1a8035;
            box-shadow: 0 4px 0 #145528,
                        0 0 20px rgba(51, 255, 102, 0.5);
        }

        /* Button press effect */
        [data-theme="phosphor"] .btn:active,
        [data-theme="phosphor"] .nav-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #664400,
                        0 0 10px rgba(255, 176, 0, 0.3);
        }

        /* Secondary Button (green outline) */
        [data-theme="phosphor"] .btn-secondary {
            background: transparent;
            border: 3px solid #33ff66;
            color: #33ff66;
            box-shadow: 0 0 15px rgba(51, 255, 102, 0.3);
        }

        [data-theme="phosphor"] .btn-secondary:hover {
            background: linear-gradient(180deg, #33ff66 0%, #28cc52 100%);
            color: #0a0800;
            box-shadow: 0 0 25px rgba(51, 255, 102, 0.6);
        }

        /* Tertiary Button (subtle) */
        [data-theme="phosphor"] .btn-tertiary {
            background: transparent;
            border: 1px solid rgba(255, 176, 0, 0.3);
            color: rgba(255, 176, 0, 0.6);
            box-shadow: none;
        }

        [data-theme="phosphor"] .btn-tertiary:hover {
            border-color: #ffb000;
            color: #ffb000;
            background: rgba(255, 176, 0, 0.1);
        }

        /* Phosphor Theme Container Adjustments */
        [data-theme="phosphor"] .container {
            position: relative;
            z-index: 1;
        }

        /* Reduced header for phosphor theme */
        [data-theme="phosphor"] .header {
            padding: 16px 20px;
            margin-bottom: 24px;
        }

        [data-theme="phosphor"] .header h1 {
            font-size: 1.6rem;
        }

        /* Mobile adjustments for floating search */
        @media (max-width: 768px) {
            .floating-search {
                right: 12px;
                top: 84px;
            }

            .floating-search-btn {
                width: 50px;
                height: 50px;
            }

            .floating-search-panel {
                width: calc(100vw - 80px);
                right: 0;
                top: 60px;
            }

            .floating-search-panel.active {
                max-width: 350px;
            }
        }

        @media (max-width: 480px) {
            .floating-search {
                right: 8px;
                top: 76px;
            }

            .floating-search-btn {
                width: 46px;
                height: 46px;
            }

            .floating-search-panel {
                width: calc(100vw - 70px);
                right: 0;
                top: 56px;
            }
        }

        /* ============= PHOSPHOR MODERN - FLOATING SEARCH OVERRIDES ============= */
        [data-theme="phosphor"] .floating-search-btn {
            width: 56px;
            height: 56px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 50%;
            color: var(--text-primary);
            box-shadow: 0 4px 12px var(--shadow-color);
            transition: all 0.2s ease;
        }

        [data-theme="phosphor"] .floating-search-btn:hover {
            background: var(--primary-color);
            color: var(--bg-dark);
            border-color: var(--primary-color);
            transform: scale(1.05);
            box-shadow: 0 6px 20px var(--shadow-color);
        }

        [data-theme="phosphor"] .floating-search-panel {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        [data-theme="phosphor"] .floating-search-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-subtle);
            background: transparent;
        }

        [data-theme="phosphor"] .terminal-prompt,
        [data-theme="phosphor"] .terminal-cursor {
            display: none;
        }

        [data-theme="phosphor"] .floating-search-header::before {
            content: 'Search';
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
        }

        [data-theme="phosphor"] .floating-search-close {
            color: var(--text-secondary);
            font-size: 24px;
            transition: color 0.15s ease;
        }

        [data-theme="phosphor"] .floating-search-close:hover {
            color: var(--text-primary);
            text-shadow: none;
        }

        [data-theme="phosphor"] .floating-search-input-wrapper {
            padding: 16px 20px;
            gap: 0;
        }

        [data-theme="phosphor"] .floating-search-input {
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            color: var(--text-primary);
            caret-color: var(--primary-color);
        }

        [data-theme="phosphor"] .floating-search-input::placeholder {
            color: var(--text-secondary);
        }

        [data-theme="phosphor"] .floating-search-results {
            border-top: 1px solid var(--border-subtle);
        }

        [data-theme="phosphor"] .floating-search-result-item {
            padding: 12px 20px;
            border-bottom: 1px solid var(--border-subtle);
            transition: background 0.15s ease;
        }

        [data-theme="phosphor"] .floating-search-result-item:hover {
            background: rgba(245, 166, 35, 0.08);
        }

        [data-theme="phosphor"] .floating-search-result-item img {
            border: none;
            border-radius: 6px;
        }

        [data-theme="phosphor"] .floating-search-result-title {
            font-family: 'Outfit', sans-serif;
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
        }

        [data-theme="phosphor"] .floating-search-result-year {
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            color: var(--text-secondary);
        }

        [data-theme="phosphor"] .floating-search-clear {
            color: var(--text-secondary);
            font-size: 18px;
        }

        [data-theme="phosphor"] .floating-search-clear:hover {
            color: #ff6666;
        }

        [data-theme="phosphor"] .floating-search-watchlist-btn img {
            filter: brightness(0.8);
        }

        [data-theme="phosphor"] .floating-search-watchlist-btn:hover img {
            filter: brightness(1);
        }

        /* ============= PHOSPHOR MODERN - FLOATING WATCHLIST ============= */
        /* ============= WATCHLIST CONTAINER & PANEL (PHOSPHOR MODERN) ============= */
        .watchlist-container {
            display: none;
            position: absolute;
            top: 100px;
            left: 20px;
            right: auto;
            z-index: 100001;
        }

        .watchlist-trigger-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 18px;
            background: var(--bg-elevated, #3A352E);
            border: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.15));
            border-radius: 12px;
            color: var(--text-primary, #F5F0E8);
            font-family: 'Outfit', sans-serif;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .watchlist-trigger-btn:hover {
            background: var(--primary-color, #F5A623);
            color: var(--bg-dark, #1A1714);
            border-color: var(--primary-color, #F5A623);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(245, 166, 35, 0.25);
        }

        .watchlist-trigger-btn svg {
            transition: transform 0.2s ease;
        }

        .watchlist-trigger-btn:hover svg {
            transform: scale(1.1);
        }

        .watchlist-trigger-label {
            letter-spacing: 0.02em;
        }

        /* Slide Panel */
        .watchlist-slide-panel {
            position: absolute;
            top: calc(100% + 12px);
            left: 0;
            width: 380px;
            max-height: 75vh;
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid var(--primary-color, #F5A623);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(245, 166, 35, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateX(-100%);
            transform-origin: top left;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .watchlist-slide-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }

        /* Panel Header */
        .watchlist-slide-header {
            padding: 20px 24px 16px;
            border-bottom: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.1));
            background: linear-gradient(180deg, rgba(245, 166, 35, 0.04) 0%, transparent 100%);
        }

        .watchlist-slide-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .watchlist-slide-title {
            font-family: 'Outfit', sans-serif;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary, #F5F0E8);
            margin: 0;
            letter-spacing: -0.01em;
        }

        .watchlist-slide-close {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 10px;
            color: var(--text-secondary, #A39E94);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .watchlist-slide-close:hover {
            background: rgba(245, 166, 35, 0.12);
            color: var(--text-primary, #F5F0E8);
        }

        /* Lists View */
        .watchlist-slide-lists {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .watchlist-slide-list-card {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid transparent;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .watchlist-slide-list-card:hover {
            background: rgba(245, 166, 35, 0.08);
            border-color: rgba(245, 166, 35, 0.2);
            transform: translateX(4px);
        }

        .watchlist-slide-list-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--primary-color, #F5A623) 0%, var(--primary-muted, #D4912A) 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--bg-dark, #1A1714);
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(245, 166, 35, 0.25);
        }

        .watchlist-slide-list-icon svg {
            width: 22px;
            height: 22px;
        }

        .watchlist-slide-list-details {
            flex: 1;
            min-width: 0;
        }

        .watchlist-slide-list-name {
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary, #F5F0E8);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .watchlist-slide-list-count {
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            color: var(--text-secondary, #A39E94);
        }

        .watchlist-slide-list-arrow {
            color: var(--text-secondary, #A39E94);
            opacity: 0;
            transform: translateX(-8px);
            transition: all 0.2s ease;
        }

        .watchlist-slide-list-card:hover .watchlist-slide-list-arrow {
            opacity: 1;
            transform: translateX(0);
        }

        /* Delete list button - subtle, appears on hover */
        .watchlist-slide-list-delete {
            position: absolute;
            top: 50%;
            right: 40px;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: var(--text-secondary, #666);
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 2;
        }

        .watchlist-slide-list-delete svg {
            width: 14px;
            height: 14px;
            transition: transform 0.2s ease;
        }

        .watchlist-slide-list-card {
            position: relative;
        }

        .watchlist-slide-list-card:hover .watchlist-slide-list-delete {
            opacity: 0.5;
        }

        .watchlist-slide-list-delete:hover {
            opacity: 1 !important;
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }

        .watchlist-slide-list-delete:hover svg {
            transform: scale(1.1);
        }

        .watchlist-slide-list-delete:active svg {
            transform: scale(0.95);
        }

        .watchlist-slide-list-rename {
            position: absolute;
            top: 50%;
            right: 68px;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: var(--text-secondary, #666);
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 2;
        }

        .watchlist-slide-list-rename svg {
            width: 14px;
            height: 14px;
            transition: transform 0.2s ease;
        }

        .watchlist-slide-list-card:hover .watchlist-slide-list-rename {
            opacity: 0.5;
        }

        .watchlist-slide-list-rename:hover {
            opacity: 1 !important;
            color: var(--primary-color, #00ff9f);
            background: rgba(0, 255, 159, 0.1);
        }

        .watchlist-slide-list-rename:hover svg {
            transform: scale(1.1);
        }

        .watchlist-slide-list-rename:active svg {
            transform: scale(0.95);
        }

        /* Rename list modal */
        .rename-list-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100002;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }

        .rename-list-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .rename-list-modal {
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--primary-color, #00ff9f);
            padding: 0;
            width: 90%;
            max-width: 380px;
            transform: scale(0.95);
            transition: transform 0.2s ease;
            box-shadow: 0 0 30px rgba(0, 255, 159, 0.15);
        }

        .rename-list-modal-overlay.active .rename-list-modal {
            transform: scale(1);
        }

        .rename-list-modal-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(0, 255, 159, 0.2);
            background: rgba(0, 255, 159, 0.05);
        }

        .rename-list-modal-icon {
            width: 20px;
            height: 20px;
            color: var(--primary-color, #00ff9f);
        }

        .rename-list-modal-title {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--primary-color, #00ff9f);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rename-list-modal-body {
            padding: 20px;
        }

        .rename-list-modal-text {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: var(--text-primary, #e0e0e0);
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .rename-list-modal-input {
            width: 100%;
            padding: 12px 14px;
            background: rgba(0, 255, 159, 0.05);
            border: 1px solid rgba(0, 255, 159, 0.3);
            color: var(--text-primary, #e0e0e0);
            font-family: 'VT323', monospace;
            font-size: 18px;
            outline: none;
            transition: border-color 0.2s ease;
            box-sizing: border-box;
        }

        .rename-list-modal-input:focus {
            border-color: var(--primary-color, #00ff9f);
            box-shadow: 0 0 8px rgba(0, 255, 159, 0.15);
        }

        .rename-list-modal-input::placeholder {
            color: rgba(255, 255, 255, 0.25);
        }

        .rename-list-modal-error {
            font-family: 'VT323', monospace;
            font-size: 15px;
            color: #ff6b6b;
            margin-top: 8px;
            display: none;
        }

        .rename-list-modal-error.visible {
            display: block;
        }

        .rename-list-modal-actions {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(0, 0, 0, 0.2);
        }

        .rename-list-modal-btn {
            flex: 1;
            padding: 12px 16px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rename-list-modal-btn.cancel {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        .rename-list-modal-btn.cancel:hover {
            border-color: #666;
            color: #aaa;
            background: rgba(255, 255, 255, 0.02);
        }

        .rename-list-modal-btn.confirm {
            background: rgba(0, 255, 159, 0.15);
            border: 1px solid var(--primary-color, #00ff9f);
            color: var(--primary-color, #00ff9f);
        }

        .rename-list-modal-btn.confirm:hover {
            background: var(--primary-color, #00ff9f);
            color: #0f0f1e;
        }

        /* Delete confirmation modal */
        .delete-list-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100002;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }

        .delete-list-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .delete-list-modal {
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid #ff6b6b;
            padding: 0;
            width: 90%;
            max-width: 360px;
            transform: scale(0.95);
            transition: transform 0.2s ease;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.2);
        }

        .delete-list-modal-overlay.active .delete-list-modal {
            transform: scale(1);
        }

        .delete-list-modal-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(255, 107, 107, 0.2);
            background: rgba(255, 107, 107, 0.05);
        }

        .delete-list-modal-icon {
            width: 20px;
            height: 20px;
            color: #ff6b6b;
        }

        .delete-list-modal-title {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #ff6b6b;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .delete-list-modal-body {
            padding: 20px;
        }

        .delete-list-modal-text {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: var(--text-primary, #e0e0e0);
            line-height: 1.5;
            margin-bottom: 8px;
        }

        .delete-list-modal-name {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--primary-color, #00ff9f);
            padding: 8px 12px;
            background: rgba(0, 255, 159, 0.05);
            border-left: 2px solid var(--primary-color, #00ff9f);
            margin: 12px 0;
        }

        .delete-list-modal-warning {
            font-family: 'VT323', monospace;
            font-size: 15px;
            color: #888;
            margin-top: 8px;
        }

        .delete-list-modal-actions {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(0, 0, 0, 0.2);
        }

        .delete-list-modal-btn {
            flex: 1;
            padding: 12px 16px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .delete-list-modal-btn.cancel {
            background: transparent;
            border: 1px solid #444;
            color: #888;
        }

        .delete-list-modal-btn.cancel:hover {
            border-color: #666;
            color: #aaa;
            background: rgba(255, 255, 255, 0.02);
        }

        .delete-list-modal-btn.confirm {
            background: rgba(255, 107, 107, 0.15);
            border: 1px solid #ff6b6b;
            color: #ff6b6b;
        }

        .delete-list-modal-btn.confirm:hover {
            background: #ff6b6b;
            color: #0f0f1e;
        }

        /* Items View */
        .watchlist-slide-items {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .watchlist-slide-back {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            margin-bottom: 16px;
            background: rgba(245, 166, 35, 0.08);
            border: 1px solid rgba(245, 166, 35, 0.15);
            border-radius: 10px;
            color: var(--primary-color, #F5A623);
            font-family: 'Outfit', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .watchlist-slide-back:hover {
            background: rgba(245, 166, 35, 0.15);
            border-color: rgba(245, 166, 35, 0.3);
        }

        .watchlist-slide-items-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        /* Individual Item Card */
        .watchlist-item-card {
            display: flex;
            gap: 14px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid transparent;
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .watchlist-item-card:hover {
            background: rgba(245, 166, 35, 0.06);
            border-color: rgba(245, 166, 35, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .watchlist-item-poster {
            width: 64px;
            height: 96px;
            border-radius: 10px;
            object-fit: cover;
            background: var(--bg-medium, #242019);
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .watchlist-item-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0;
            padding: 4px 0;
        }

        .watchlist-item-title {
            font-family: 'Outfit', sans-serif;
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary, #F5F0E8);
            margin-bottom: 6px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .watchlist-item-meta {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .watchlist-item-type {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: rgba(245, 166, 35, 0.12);
            border-radius: 6px;
            font-family: 'Outfit', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: var(--primary-color, #F5A623);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .watchlist-item-rating {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            color: var(--text-secondary, #A39E94);
        }

        .watchlist-item-rating svg {
            width: 14px;
            height: 14px;
            color: #FFD700;
            fill: #FFD700;
        }

        .watchlist-item-rating-value {
            font-weight: 600;
            color: var(--text-primary, #F5F0E8);
        }

        /* Empty State */
        .watchlist-slide-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 48px 24px;
            text-align: center;
        }

        .watchlist-slide-empty-icon {
            width: 72px;
            height: 72px;
            margin-bottom: 20px;
            background: rgba(245, 166, 35, 0.08);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-color, #F5A623);
            opacity: 0.6;
        }

        .watchlist-slide-empty-icon svg {
            width: 32px;
            height: 32px;
        }

        .watchlist-slide-empty-text {
            font-family: 'Outfit', sans-serif;
            font-size: 15px;
            color: var(--text-secondary, #A39E94);
            line-height: 1.5;
        }

        /* Phosphor theme specific - show watchlist container */
        [data-theme="phosphor"] .watchlist-container {
            display: block;
        }

        /* ============= FRIEND REQUEST NOTIFICATION ICON (Left side, beside user menu) ============= */
        .friend-request-notification-left {
            display: none;
            position: relative;
            cursor: pointer;
            margin-left: 12px;
            order: 1;
            animation: friendRequestPulse 2s ease-in-out infinite;
        }

        .friend-request-notification-left.has-requests {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .friend-request-notification-left img {
            width: 36px;
            height: 36px;
            filter: drop-shadow(0 0 8px rgba(255, 0, 255, 0.6));
            transition: all 0.3s ease;
        }

        .friend-request-notification-left:hover img {
            transform: scale(1.15);
            filter: drop-shadow(0 0 15px rgba(255, 0, 255, 0.9));
        }

        .friend-request-notification-left .request-count-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: linear-gradient(135deg, #ff00ff, #ff0066);
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 12px;
            font-weight: bold;
            min-width: 18px;
            height: 18px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.8);
            border: 2px solid #0f0f1e;
        }

        @keyframes friendRequestPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        [data-theme="phosphor"] .friend-request-notification-left,
        [data-theme="jspecial"] .friend-request-notification-left {
            display: none;
        }

        [data-theme="phosphor"] .friend-request-notification-left.has-requests,
        [data-theme="jspecial"] .friend-request-notification-left.has-requests {
            display: flex;
        }

        /* ============= CREATE NEW LIST MODAL ============= */
        @keyframes createListModalIn {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        @keyframes createListShine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .create-list-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 100010;
            align-items: center;
            justify-content: center;
        }

        .create-list-modal-overlay.active {
            display: flex;
        }

        .create-list-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
            background: linear-gradient(145deg, rgba(10, 10, 25, 0.98), rgba(15, 15, 35, 0.98));
            border: none;
            padding: 0;
            z-index: 100011;
            overflow: hidden;
            clip-path: polygon(0 0, calc(100% - 25px) 0, 100% 25px, 100% 100%, 25px 100%, 0 calc(100% - 25px));
            animation: createListModalIn 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .create-list-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(90deg, rgba(0, 255, 159, 0.05) 1px, transparent 1px),
                linear-gradient(rgba(0, 255, 159, 0.05) 1px, transparent 1px);
            background-size: 15px 15px;
            pointer-events: none;
        }

        .create-list-header {
            background: linear-gradient(90deg, rgba(0, 255, 159, 0.2), rgba(0, 217, 255, 0.1), transparent);
            padding: 20px 25px;
            border-bottom: 2px solid;
            border-image: linear-gradient(90deg, #00ff9f, #00d9ff) 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .create-list-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: #00ff9f;
            display: flex;
            align-items: center;
            gap: 12px;
            text-shadow: 0 0 10px rgba(0, 255, 159, 0.5);
        }

        .create-list-title::before {
            content: '';
            font-size: 16px;
            color: #00d9ff;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        .create-list-close {
            width: 36px;
            height: 36px;
            background: transparent;
            border: 2px solid #ff00ff;
            color: #ff00ff;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            clip-path: polygon(15% 0%, 100% 0%, 100% 85%, 85% 100%, 0% 100%, 0% 15%);
        }

        .create-list-close:hover {
            background: #ff00ff;
            color: #0f0f1e;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }

        .create-list-body {
            padding: 30px 25px;
            position: relative;
        }

        .create-list-description {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #00d9ff;
            margin-bottom: 24px;
            text-align: center;
            line-height: 1.4;
        }

        .create-list-input-group {
            position: relative;
            margin-bottom: 20px;
        }

        .create-list-input-label {
            position: absolute;
            top: -10px;
            left: 16px;
            background: #0a0a19;
            padding: 0 10px;
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: #00ff9f;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .create-list-input {
            width: 100%;
            padding: 18px 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 159, 0.3);
            color: #00ff9f;
            font-family: 'VT323', monospace;
            font-size: 22px;
            outline: none;
            transition: all 0.3s ease;
        }

        .create-list-input::placeholder {
            color: rgba(0, 255, 159, 0.3);
        }

        .create-list-input:focus {
            border-color: #00ff9f;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.3), inset 0 0 30px rgba(0, 255, 159, 0.05);
        }

        .create-list-input.error {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.3);
        }

        .create-list-error {
            color: #ff4444;
            font-family: 'VT323', monospace;
            font-size: 16px;
            margin-top: 10px;
            display: none;
            text-align: center;
        }

        .create-list-error.visible {
            display: block;
        }

        .create-list-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .create-list-btn {
            flex: 1;
            padding: 16px 24px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .create-list-btn.primary {
            background: linear-gradient(135deg, #00ff9f, #00d9ff);
            border: none;
            color: #0f0f1e;
            clip-path: polygon(8% 0%, 100% 0%, 92% 100%, 0% 100%);
        }

        .create-list-btn.primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .create-list-btn.primary:hover::before {
            left: 100%;
        }

        .create-list-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 30px rgba(0, 255, 159, 0.5);
        }

        .create-list-btn.secondary {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: #888;
            clip-path: polygon(8% 0%, 100% 0%, 92% 100%, 0% 100%);
        }

        .create-list-btn.secondary:hover {
            border-color: #ff00ff;
            color: #ff00ff;
        }

        /* ============= CREATE NEW LIST BUTTON ============= */
        .watchlist-slide-create-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 14px 20px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, rgba(0, 255, 159, 0.15), rgba(0, 217, 255, 0.15));
            border: 2px dashed var(--primary-color, #00ff9f);
            border-radius: 12px;
            color: var(--primary-color, #00ff9f);
            font-family: 'VT323', monospace;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .watchlist-slide-create-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 159, 0.25), rgba(0, 217, 255, 0.25));
            border-style: solid;
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.4);
        }

        .watchlist-slide-create-btn svg {
            width: 20px;
            height: 20px;
        }

        /* ============= LIVE SECTION CONTAINER & PANEL ============= */
        .live-container {
            display: none;
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100002;
        }

        [data-theme="phosphor"] .live-container {
            display: block;
        }

        /* J's Special - Show watchlist container (My Lists) */
        [data-theme="jspecial"] .watchlist-container {
            display: block;
        }

        /* J's Special - Show live container */
        [data-theme="jspecial"] .live-container {
            display: block;
        }

        /* J's Special - Show floating search */
        [data-theme="jspecial"] .floating-search {
            display: block;
        }

        /* J's Special - Floating Search Button */
        [data-theme="jspecial"] .floating-search-btn {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            border: 3px solid #ffd700;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        [data-theme="jspecial"] .floating-search-btn:hover {
            background: linear-gradient(135deg, #ffb700, #ffd700);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            transform: translateY(-3px) scale(1.1);
        }

        /* J's Special - Floating Search Panel */
        [data-theme="jspecial"] .floating-search-panel {
            background: linear-gradient(145deg, rgba(15, 15, 30, 0.98), rgba(30, 15, 45, 0.98));
            border: 3px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        [data-theme="jspecial"] .floating-search-header {
            border-bottom: 2px solid rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 183, 0, 0.2));
            color: #ffd700;
        }

        [data-theme="jspecial"] .floating-search-input {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.4);
            color: #fff;
        }

        [data-theme="jspecial"] .floating-search-input:focus {
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        [data-theme="jspecial"] .floating-search-clear {
            color: rgba(255, 215, 0, 0.5);
        }

        [data-theme="jspecial"] .floating-search-clear:hover {
            color: #ff6666;
            text-shadow: 0 0 8px rgba(255, 102, 102, 0.6);
        }

        [data-theme="jspecial"] .floating-search-result-item {
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }

        [data-theme="jspecial"] .floating-search-result-item:hover {
            background: rgba(255, 215, 0, 0.15);
        }

        [data-theme="jspecial"] .floating-search-result-title {
            color: #fff;
        }

        [data-theme="jspecial"] .floating-search-result-year {
            color: #ffd700;
        }

        /* J's Special - Hide the Party button in top-right */
        [data-theme="jspecial"] .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
            display: none;
        }

        /* J's Special - Colorful Live Button */
        [data-theme="jspecial"] .live-trigger-btn {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            border: 3px solid #ff1493;
            color: #000;
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.6);
        }

        [data-theme="jspecial"] .live-trigger-btn:hover {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.8);
            transform: translateY(-3px) scale(1.05);
        }

        /* J's Special - Colorful Watchlist Button */
        [data-theme="jspecial"] .watchlist-trigger-btn {
            background: linear-gradient(135deg, #00bfff, #1e90ff);
            border: 3px solid #00bfff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 191, 255, 0.6);
        }

        [data-theme="jspecial"] .watchlist-trigger-btn:hover {
            background: linear-gradient(135deg, #1e90ff, #00bfff);
            box-shadow: 0 0 30px rgba(0, 191, 255, 0.8);
            transform: translateY(-3px) scale(1.05);
        }

        /* J's Special - Colorful icons (show original colors) */
        [data-theme="jspecial"] .live-icon,
        [data-theme="jspecial"] .watchlist-icon,
        [data-theme="jspecial"] .live-trigger-btn img,
        [data-theme="jspecial"] .watchlist-trigger-btn img {
            filter: none !important;
        }

        /* J's Special - Live Panel styling */
        [data-theme="jspecial"] .live-panel {
            background: linear-gradient(145deg, rgba(15, 15, 30, 0.98), rgba(30, 15, 45, 0.98));
            border: 3px solid #ff1493;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.5);
        }

        /* J's Special - Watchlist Slide Panel styling */
        [data-theme="jspecial"] .watchlist-slide-panel {
            background: linear-gradient(145deg, rgba(15, 15, 30, 0.98), rgba(30, 15, 45, 0.98));
            border: 3px solid #00bfff;
            box-shadow: 0 0 30px rgba(0, 191, 255, 0.5);
        }

        [data-theme="jspecial"] .watchlist-slide-header {
            border-bottom-color: rgba(0, 191, 255, 0.4);
            background: linear-gradient(135deg, rgba(0, 191, 255, 0.2), rgba(30, 144, 255, 0.2));
        }

        [data-theme="jspecial"] .watchlist-slide-title {
            color: #ffd700;
        }

        [data-theme="jspecial"] .watchlist-slide-list-card {
            border-color: rgba(0, 191, 255, 0.3);
        }

        [data-theme="jspecial"] .watchlist-slide-list-card:hover {
            border-color: #00bfff;
            background: rgba(0, 191, 255, 0.15);
        }

        [data-theme="jspecial"] .watchlist-slide-list-name {
            color: #fff;
        }

        [data-theme="jspecial"] .watchlist-slide-list-count {
            color: #00bfff;
        }

        .live-trigger-btn {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 20px;
            background: var(--primary-color, #F5A623);
            border: 2px solid var(--primary-color, #F5A623);
            border-radius: 12px;
            color: var(--bg-dark, #1A1714);
            font-family: 'Outfit', sans-serif;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(245, 166, 35, 0.4);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .live-trigger-btn img {
            width: 32px !important;
            height: 32px !important;
        }

        .live-trigger-btn:hover {
            background: #FFB938;
            border-color: #FFB938;
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(245, 166, 35, 0.6);
        }

        .live-trigger-btn:hover img {
            filter: brightness(0) !important;
        }

        .live-trigger-label {
            letter-spacing: 0.02em;
        }

        .live-slide-panel {
            position: absolute;
            top: calc(100% + 12px);
            right: 0;
            width: 360px;
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid var(--primary-color, #F5A623);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(245, 166, 35, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            transform-origin: top right;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .live-slide-panel.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(0);
        }

        .live-slide-header {
            padding: 20px 24px 16px;
            border-bottom: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.1));
            background: linear-gradient(180deg, rgba(245, 166, 35, 0.04) 0%, transparent 100%);
        }

        .live-slide-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .live-slide-title {
            font-family: 'Outfit', sans-serif;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary, #F5F0E8);
            margin: 0;
            letter-spacing: -0.01em;
        }

        .live-slide-close {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            border-radius: 10px;
            color: var(--text-secondary, #A39E93);
            cursor: pointer;
            transition: all 0.2s;
        }

        .live-slide-close:hover {
            background: rgba(255, 59, 48, 0.15);
            color: #FF453A;
        }

        .live-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 16px;
        }

        .live-option-btn {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.1));
            border-radius: 12px;
            color: var(--text-primary, #F5F0E8);
            font-family: 'Outfit', sans-serif;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .live-option-btn:hover {
            background: rgba(245, 166, 35, 0.1);
            border-color: var(--primary-color, #F5A623);
            transform: translateX(4px);
        }

        .live-option-btn:hover img {
            filter: brightness(0) saturate(100%) invert(72%) sepia(47%) saturate(1000%) hue-rotate(358deg) brightness(101%) contrast(94%) !important;
        }

        /* Icon-only button styles */
        .live-trigger-btn-icon-only {
            padding: 16px;
            border-radius: 12px;
        }

        .live-option-btn-icon-only {
            justify-content: center;
            padding: 20px;
            flex: 1;
        }

        .live-options {
            flex-direction: row !important;
            justify-content: center;
            gap: 16px !important;
        }

        .live-main-options {
            padding: 20px;
        }

        /* Category views */
        .live-categories {
            padding: 16px;
        }

        .live-back-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            border-radius: 10px;
            color: var(--text-secondary, #A39E93);
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 12px;
        }

        .live-back-btn:hover {
            background: rgba(245, 166, 35, 0.15);
            color: var(--primary-color, #F5A623);
        }

        .live-category-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .live-category-grid.sports-grid {
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .live-category-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.1));
            border-radius: 10px;
            color: var(--text-primary, #F5F0E8);
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 50px;
        }

        .live-category-btn:hover {
            background: rgba(245, 166, 35, 0.15);
            border-color: var(--primary-color, #F5A623);
            transform: scale(1.05);
        }

        .live-category-btn img {
            filter: brightness(0) invert(1);
            transition: filter 0.2s;
        }

        .live-category-btn:hover img {
            filter: brightness(0) saturate(100%) invert(72%) sepia(47%) saturate(1000%) hue-rotate(358deg) brightness(101%) contrast(94%);
        }

        /* ============= ICON FILTERS FOR NON-PHOSPHOR THEMES ============= */
        .watchlist-icon,
        .live-icon {
            filter: brightness(0) invert(1);
            transition: filter 0.2s;
        }

                /* ============= PHOSPHOR MODERN - SHOW ORIGINAL COLORED ICONS ============= */
        [data-theme="phosphor"] .live-category-btn img,
        [data-theme="phosphor"] .live-icon,
        [data-theme="phosphor"] .watchlist-icon {
            filter: none !important;
        }

        [data-theme="phosphor"] .live-category-btn:hover img {
            filter: brightness(1.1) !important;
        }

        [data-theme="phosphor"] .live-trigger-btn img,
        [data-theme="phosphor"] .live-option-btn img {
            filter: none !important;
        }

        [data-theme="phosphor"] .watchlist-trigger-btn img {
            filter: none !important;
        }

        /* ============= J'S SPECIAL - SHOW ORIGINAL COLORED ICONS ============= */
        [data-theme="jspecial"] .live-category-btn img,
        [data-theme="jspecial"] .live-icon,
        [data-theme="jspecial"] .watchlist-icon {
            filter: none !important;
        }

        [data-theme="jspecial"] .live-category-btn:hover img {
            filter: brightness(1.2) !important;
        }

        [data-theme="jspecial"] .live-trigger-btn img,
        [data-theme="jspecial"] .live-option-btn img {
            filter: none !important;
        }

        [data-theme="jspecial"] .watchlist-trigger-btn img {
            filter: none !important;
        }

                /* ============= PHOSPHOR MODERN - USER MENU OVERRIDES ============= */
        [data-theme="phosphor"] .user-menu-dropdown {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(20px);
            padding: 8px;
        }

        [data-theme="phosphor"] .user-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            font-size: 15px;
            border: none;
            transition: background 0.15s ease;
        }

        [data-theme="phosphor"] .user-menu-item:hover {
            background: rgba(245, 166, 35, 0.1);
            border-color: transparent;
            transform: none;
        }

        [data-theme="phosphor"] .user-menu-divider {
            height: 1px;
            background: var(--border-subtle);
            margin: 8px 0;
        }

        [data-theme="phosphor"] .user-menu-username {
            font-family: 'Outfit', sans-serif;
            color: var(--text-secondary);
            font-size: 14px;
            border-bottom: 1px solid var(--border-subtle);
        }

        [data-theme="phosphor"] .menu-icon {
            width: 20px;
            text-align: center;
            opacity: 0.7;
        }


        /* ============= PHOSPHOR MODERN - POPUP PANELS (Theme, Effects, Party) ============= */
        /* Panels appear next to user menu button and expand outward */
        [data-theme="phosphor"] .theme-selector-panel,
        [data-theme="phosphor"] #bgEffectsPanel,
        [data-theme="phosphor"] #watchpartyPanel {
            position: fixed !important;
            left: 20px !important;
            right: auto !important;
            top: 70px !important;
            bottom: auto !important;
            width: 340px;
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid var(--primary-color, #F5A623);
            border-radius: 12px;
            padding: 0;
            box-shadow: 0 0 30px rgba(245, 166, 35, 0.3),
                        inset 0 0 60px rgba(245, 166, 35, 0.03);
            backdrop-filter: blur(20px);
            transform: scale(0);
            transform-origin: top left;
            opacity: 0;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.25s ease;
            z-index: 100003;
            overflow: hidden;
            /* Override base display:none - use visibility for animation */
            display: flex !important;
            flex-direction: column;
            visibility: hidden;
            pointer-events: none;
        }

        [data-theme="phosphor"] .theme-selector-panel.active,
        [data-theme="phosphor"] #bgEffectsPanel.active,
        [data-theme="phosphor"] #watchpartyPanel.active {
            transform: scale(1);
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        /* Panel Header - match search panel header */
        [data-theme="phosphor"] .theme-selector-panel .theme-selector-title,
        [data-theme="phosphor"] .bg-effects-panel .bg-effects-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 2px solid rgba(245, 166, 35, 0.3);
            background: rgba(245, 166, 35, 0.1);
            margin: 0;
        }

        [data-theme="phosphor"] .theme-selector-panel .theme-selector-title .title-text,
        [data-theme="phosphor"] .bg-effects-panel .bg-effects-title .title-text {
            font-family: 'VT323', monospace;
            font-size: 18px;
            font-weight: 500;
            color: var(--primary-color, #F5A623);
            text-shadow: 0 0 10px rgba(245, 166, 35, 0.5);
        }

        [data-theme="phosphor"] .panel-close-btn {
            background: rgba(245, 166, 35, 0.1);
            border: 2px solid rgba(245, 166, 35, 0.3);
            color: var(--primary-color, #F5A623);
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        [data-theme="phosphor"] .panel-close-btn:hover {
            background: var(--primary-color, #F5A623);
            color: #0a0800;
            box-shadow: 0 0 15px rgba(245, 166, 35, 0.5);
        }

        /* Theme Options */
        [data-theme="phosphor"] .theme-selector-panel .theme-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            margin: 4px 8px;
            border: 2px solid transparent;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            color: var(--primary-color, #F5A623);
            font-family: 'VT323', monospace;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        [data-theme="phosphor"] .theme-selector-panel .theme-option:hover {
            background: rgba(245, 166, 35, 0.15);
            border-color: rgba(245, 166, 35, 0.5);
            transform: translateX(4px);
        }

        [data-theme="phosphor"] .theme-selector-panel .theme-option.active {
            background: rgba(245, 166, 35, 0.2);
            border-color: var(--primary-color, #F5A623);
            box-shadow: 0 0 15px rgba(245, 166, 35, 0.3);
        }

        [data-theme="phosphor"] .theme-color-preview {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid rgba(245, 166, 35, 0.3);
        }

        [data-theme="phosphor"] .theme-name {
            font-family: 'Outfit', sans-serif;
            color: var(--text-primary);
            text-shadow: none;
        }

        /* Effects Panel Options */
        [data-theme="phosphor"] .bg-effects-panel .effect-option,
        [data-theme="phosphor"] .bg-effects-panel .bg-animation-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            margin: 0;
            border: none;
            border-radius: 0;
            background: transparent;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            font-size: 15px;
            cursor: pointer;
            transition: background 0.15s ease;
            width: 100%;
            text-align: left;
            box-shadow: none;
        }

        [data-theme="phosphor"] .bg-effects-panel .effect-option:hover,
        [data-theme="phosphor"] .bg-effects-panel .bg-animation-toggle:hover {
            background: rgba(245, 166, 35, 0.08);
            transform: none;
            box-shadow: none;
        }

        [data-theme="phosphor"] .bg-effects-panel .effect-option.active,
        [data-theme="phosphor"] .bg-effects-panel .bg-animation-toggle.active {
            background: rgba(245, 166, 35, 0.15);
            color: var(--primary-color);
            transform: none;
            box-shadow: none;
        }

        /* Watchparty Panel - wider to fit content */
        [data-theme="phosphor"] #watchpartyPanel {
            width: 380px;
        }

        [data-theme="phosphor"] .theme-options-container {
            padding: 8px 0;
        }

        /* Watchparty Panel Specific */
        [data-theme="phosphor"] #watchpartyPanel {
            width: 420px;
        }

        [data-theme="phosphor"] #watchpartyPanel > div:first-child {
            padding: 12px 16px;
            border-bottom: 2px solid rgba(245, 166, 35, 0.3);
            background: rgba(245, 166, 35, 0.1);
        }

        [data-theme="phosphor"] #watchpartyPanel input[type="text"] {
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(245, 166, 35, 0.3);
            border-radius: 8px;
            padding: 12px 14px;
            color: var(--primary-color, #F5A623);
            font-family: 'VT323', monospace;
            font-size: 16px;
            margin: 12px 16px;
            width: calc(100% - 32px);
            transition: all 0.2s ease;
            box-sizing: border-box;
        }

        [data-theme="phosphor"] #watchpartyPanel input[type="text"]:focus {
            border-color: var(--primary-color, #F5A623);
            outline: none;
            box-shadow: 0 0 15px rgba(245, 166, 35, 0.3);
        }

        [data-theme="phosphor"] #watchpartyPanel input[type="text"]::placeholder {
            color: rgba(245, 166, 35, 0.5);
        }

        [data-theme="phosphor"] #watchpartyPanel button:not(.panel-close-btn) {
            background: linear-gradient(145deg, #F5A623 0%, #cc8c00 100%);
            border: 2px solid #F5A623;
            border-radius: 8px;
            padding: 12px 16px;
            color: #0a0800;
            font-family: 'VT323', monospace;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 8px 16px;
            width: calc(100% - 32px);
            transition: all 0.2s ease;
            box-shadow: 0 0 15px rgba(245, 166, 35, 0.3);
            box-sizing: border-box;
        }

        [data-theme="phosphor"] #watchpartyPanel button:not(.panel-close-btn):hover {
            background: linear-gradient(145deg, #FFB938 0%, #e6a020 100%);
            box-shadow: 0 0 25px rgba(245, 166, 35, 0.5);
            transform: translateY(-2px);
        }

        [data-theme="phosphor"] #watchpartyPanel .party-status,
        [data-theme="phosphor"] #watchpartyPanel .party-info,
        [data-theme="phosphor"] #watchpartyPanel div[style*="text-align: center"] {
            padding: 12px 16px;
            color: var(--primary-color, #F5A623);
            font-family: 'VT323', monospace;
            font-size: 16px;
        }

        [data-theme="phosphor"] #watchpartyPanel label {
            font-family: 'VT323', monospace !important;
            color: rgba(245, 166, 35, 0.7) !important;
            font-size: 14px !important;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }



        [data-theme="phosphor"] .theme-options-container {
            padding: 8px 0;
        }

        /* ============= PHOSPHOR MODERN - PAGE FADE IN ============= */
        [data-theme="phosphor"] .container {
            animation: modernFadeIn 0.5s ease-out;
        }

        @keyframes modernFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ============= END PHOSPHOR MODERN MINIMALIST REDESIGN ============= */

        /* Apply theme colors to existing elements */
        .header {
            border: none;
            box-shadow: none;
        }

        .header h1 {
            color: var(--primary-color, #00ff9f);
            text-shadow:
                3px 3px 0 var(--secondary-color, #ff00ff),
                6px 6px 0 rgba(0, 0, 0, 0.3),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .header p {
            color: var(--accent-color, #00d9ff);
        }

        .search-section {
            background: transparent;
            border: none;
            box-shadow: none;
        }

        .btn {
            border-color: var(--primary-color, #00ff9f);
            color: var(--bg-dark, #0f0f1e);
            background: var(--primary-color, #00ff9f);
            box-shadow:
                3px 3px 0 rgba(0, 0, 0, 0.4),
                0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .btn:hover {
            background: var(--bg-dark, #0f0f1e);
            color: var(--primary-color, #00ff9f);
            box-shadow:
                1px 1px 0 rgba(0, 0, 0, 0.4),
                0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        /* ============= ANIMATED BACKGROUNDS ============= */

        /* Background Animation Container */
        #shaderBackground {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        #shaderBackground canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #bgAnimation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
            opacity: 0.4;
        }

        /* Matrix Rain Effect */
        .matrix-rain {
            position: absolute;
            top: -100%;
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: var(--primary-color, #00ff9f);
            text-shadow: 0 0 8px var(--primary-color, #00ff9f);
            animation: matrixFall linear infinite;
            white-space: nowrap;
        }

        @keyframes matrixFall {
            to {
                top: 100%;
            }
        }

        /* Pixel Stars */
        .pixel-star {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--primary-color, #00ff9f);
            box-shadow:
                0 0 10px var(--primary-color, #00ff9f),
                0 0 20px var(--primary-color, #00ff9f),
                0 0 30px var(--primary-color, #00ff9f),
                0 0 40px var(--primary-color, #00ff9f),
                0 0 60px var(--primary-color, #00ff9f);
            animation: twinkle 3s ease-in-out infinite;
            filter: brightness(1.5);
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }

        /* Floating Particles */
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent-color, #00d9ff);
            border-radius: 50%;
            animation: float linear infinite;
            opacity: 1;
            box-shadow:
                0 0 15px var(--accent-color, #00d9ff),
                0 0 30px var(--accent-color, #00d9ff),
                0 0 45px var(--accent-color, #00d9ff),
                0 0 60px var(--accent-color, #00d9ff);
            filter: brightness(1.5);
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        /* Scan Lines */
        .scanline {
            position: absolute;
            width: 100%;
            height: 3px;
            background: var(--primary-color, #00ff9f);
            opacity: 0.4;
            box-shadow:
                0 0 10px var(--primary-color, #00ff9f),
                0 0 20px var(--primary-color, #00ff9f);
            animation: scan 8s linear infinite;
        }

        @keyframes scan {
            0% {
                top: 0%;
            }
            100% {
                top: 100%;
            }
        }

        /* Background Animation Toggle */
        .bg-animation-toggle {
            padding: 10px 16px;
            background: rgba(26, 26, 46, 0.9);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 20px;
            color: #fff;
            font-family: 'VT323', monospace;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .bg-animation-toggle:hover {
            background: var(--primary-color, #00ff9f);
            color: #000;
            box-shadow: 0 0 25px var(--primary-glow, rgba(0, 255, 159, 0.5));
        }

        .bg-animation-toggle.active {
            background: var(--primary-color, #00ff9f);
            color: #000;
            border-width: 3px;
            box-shadow: 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.8)),
                        inset 0 0 20px rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
            font-weight: 600;
        }

        /* ============= FILTER CHIP BUTTONS ============= */
        .filter-chip {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 10px 22px 10px 18px;
            font-family: 'VT323', monospace;
            font-size: 22px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            border: none;
            border-radius: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            clip-path: polygon(12px 0%, 100% 0%, calc(100% - 12px) 100%, 0% 100%);
        }

        .filter-chip::before {
            content: '';
            position: absolute;
            inset: 0;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .filter-chip:hover::before {
            opacity: 1;
        }

        .filter-chip:active {
            transform: scale(0.96);
        }

        .filter-chip .filter-chip-icon-img {
            width: 24px;
            height: 24px;
            object-fit: contain;
            filter: drop-shadow(0 0 4px currentColor);
            flex-shrink: 0;
        }

        .filter-chip .filter-chip-text {
            position: relative;
            z-index: 1;
            text-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }

        /* Genre chip  cyan/teal blade */
        #genreFilterBtn.filter-chip {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.15) 0%, rgba(0, 255, 159, 0.1) 100%);
            color: #00d9ff;
            box-shadow:
                inset 0 0 20px rgba(0, 217, 255, 0.1),
                0 0 12px rgba(0, 217, 255, 0.25),
                0 2px 8px rgba(0, 0, 0, 0.4);
            border-left: 3px solid #00d9ff;
            border-right: 3px solid rgba(0, 255, 159, 0.5);
        }

        #genreFilterBtn.filter-chip:hover {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.3) 0%, rgba(0, 255, 159, 0.2) 100%);
            color: #fff;
            box-shadow:
                inset 0 0 30px rgba(0, 217, 255, 0.15),
                0 0 24px rgba(0, 217, 255, 0.4),
                0 4px 16px rgba(0, 0, 0, 0.5);
        }

        #genreFilterBtn.filter-chip::before {
            background: linear-gradient(90deg, transparent, rgba(0, 217, 255, 0.08), transparent);
        }

        /* Language chip  magenta/pink blade */
        #languageFilterBtn.filter-chip {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.15) 0%, rgba(217, 70, 239, 0.1) 100%);
            color: #ff00ff;
            box-shadow:
                inset 0 0 20px rgba(255, 0, 255, 0.1),
                0 0 12px rgba(255, 0, 255, 0.25),
                0 2px 8px rgba(0, 0, 0, 0.4);
            border-left: 3px solid #ff00ff;
            border-right: 3px solid rgba(217, 70, 239, 0.5);
        }

        #languageFilterBtn.filter-chip:hover {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.3) 0%, rgba(217, 70, 239, 0.2) 100%);
            color: #fff;
            box-shadow:
                inset 0 0 30px rgba(255, 0, 255, 0.15),
                0 0 24px rgba(255, 0, 255, 0.4),
                0 4px 16px rgba(0, 0, 0, 0.5);
        }

        #languageFilterBtn.filter-chip::before {
            background: linear-gradient(90deg, transparent, rgba(255, 0, 255, 0.08), transparent);
        }

        /* J's Special theme overrides for filter chips */
        [data-theme="jspecial"] #genreFilterBtn.filter-chip {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 183, 0, 0.12) 100%);
            color: #ffd700;
            box-shadow:
                inset 0 0 20px rgba(255, 215, 0, 0.1),
                0 0 12px rgba(255, 215, 0, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.4);
            border-left: 3px solid #ffd700;
            border-right: 3px solid rgba(255, 183, 0, 0.5);
        }

        [data-theme="jspecial"] #genreFilterBtn.filter-chip:hover {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.35) 0%, rgba(255, 183, 0, 0.25) 100%);
            color: #fff;
            box-shadow:
                inset 0 0 30px rgba(255, 215, 0, 0.15),
                0 0 24px rgba(255, 215, 0, 0.5),
                0 4px 16px rgba(0, 0, 0, 0.5);
        }

        [data-theme="jspecial"] #languageFilterBtn.filter-chip {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.2) 0%, rgba(255, 140, 66, 0.12) 100%);
            color: #ff6b35;
            box-shadow:
                inset 0 0 20px rgba(255, 107, 53, 0.1),
                0 0 12px rgba(255, 107, 53, 0.3),
                0 2px 8px rgba(0, 0, 0, 0.4);
            border-left: 3px solid #ff6b35;
            border-right: 3px solid rgba(255, 140, 66, 0.5);
        }

        [data-theme="jspecial"] #languageFilterBtn.filter-chip:hover {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.35) 0%, rgba(255, 140, 66, 0.25) 100%);
            color: #fff;
            box-shadow:
                inset 0 0 30px rgba(255, 107, 53, 0.15),
                0 0 24px rgba(255, 107, 53, 0.5),
                0 4px 16px rgba(0, 0, 0, 0.5);
        }

        /* Filter chips container */
        #contentTypeFilters {
            display: none;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 16px;
        }

        /* Background Effects Panel */
        .bg-effects-panel {
            position: fixed;
            right: 20px;
            background: rgba(26, 26, 46, 0.95);
            border: 3px solid var(--primary-color, #00ff9f);
            border-radius: 16px;
            padding: 20px;
            z-index: 99999;
            display: none;
            flex-direction: column;
            gap: 12px;
            min-width: 250px;
            box-shadow: 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.4));
        }

        .bg-effects-panel.active {
            display: flex;
            animation: slideInFromRight 0.3s ease-out;
        }

        /* Dock-active: reposition effects panel above dock */
        body.glass-dock-active #bgEffectsPanel {
            right: auto !important;
            left: 50% !important;
            top: auto !important;
            transform: translateX(-50%) !important;
            bottom: 110px !important;
            z-index: 199999 !important;
            transform-origin: bottom center !important;
        }

        body.glass-dock-active #bgEffectsPanel.active {
            animation: dockPanelIn 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.4) !important;
            transform: translateX(-50%) !important;
        }

        /* Season & Episode Panel Animations */
        #seasonPanel,
        #episodePanel {
            opacity: 0;
            transform: translateY(-8px) scale(0.96);
            transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1),
                        transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }

        #seasonPanel.panel-visible,
        #episodePanel.panel-visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        #seasonPanel.panel-closing,
        #episodePanel.panel-closing {
            opacity: 0;
            transform: translateY(-8px) scale(0.96);
        }

        .bg-effects-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 11px;
            color: var(--primary-color, #00ff9f);
            text-align: center;
            margin-bottom: 8px;
            text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .panel-close-btn {
            font-family: 'VT323', monospace;
            font-size: 24px;
            color: var(--primary-color, #00ff9f);
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            opacity: 0.7;
        }

        .panel-close-btn:hover {
            opacity: 1;
            transform: scale(1.2);
            color: var(--secondary-color, #ff00ff);
            text-shadow: 0 0 10px currentColor;
        }

        .bg-effects-title .title-text {
            flex: 1;
            text-align: center;
        }

        .effect-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: rgba(15, 15, 30, 0.6);
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .effect-option:hover {
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.8);
        }

        .effect-option.active {
            border-color: var(--primary-color, #00ff9f);
            background: rgba(15, 15, 30, 0.9);
            box-shadow: 0 0 15px var(--primary-glow, rgba(0, 255, 159, 0.3));
        }

        .effect-name {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #e0e0e0;
        }

        .effect-toggle {
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            position: relative;
            transition: all 0.3s;
        }

        .effect-option.active .effect-toggle {
            background: var(--primary-color, #00ff9f);
        }

        .effect-toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .effect-option.active .effect-toggle::after {
            left: 22px;
        }

        .effects-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .effects-btn {
            flex: 1;
            padding: 8px;
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--accent-color, #00d9ff);
            color: var(--accent-color, #00d9ff);
            font-family: 'VT323', monospace;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px var(--secondary-glow, rgba(0, 217, 255, 0.3));
        }

        .effects-btn:hover {
            background: var(--accent-color, #00d9ff);
            color: var(--bg-dark, #0f0f1e);
            box-shadow: 0 0 15px var(--secondary-glow, rgba(0, 217, 255, 0.5));
        }

        /* ============= END ANIMATED BACKGROUNDS ============= */

        /* ============= USER MENU DROPDOWN ============= */
        .user-menu-container {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100002;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .user-menu-btn {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: var(--primary-color, #00ff9f);
            font-size: 24px;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: none;
            position: relative;
            z-index: 2;
        }

        .user-menu-btn:hover {
            transform: scale(1.1);
        }

        .user-menu-btn.menu-open {
        }

        .user-menu-btn.logged-in {
        }

        .user-menu-btn.logged-in:hover {
        }

        .user-menu-btn.logged-in.menu-open {
        }

        #userMenuIcon {
            image-rendering: pixelated;
            transition: transform 0.35s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
        }

        .user-menu-btn.menu-open #userMenuIcon {
            transform: rotate(45deg);
            opacity: 0.9;
        }

        .user-menu-btn.logged-in #userMenuIcon {
            width: 20px;
            height: 20px;
        }

        /* Dropdown is now a transparent flex container for floating pills */
        .user-menu-dropdown {
            position: absolute;
            top: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            z-index: 1;
        }

        .user-menu-dropdown.show {
            pointer-events: auto;
        }

        /* Each menu item is a standalone floating pill */
        .user-menu-item {
            font-family: 'VT323', monospace;
            padding: 10px 22px;
            background: rgba(15, 15, 30, 0.88);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1.5px solid rgba(0, 255, 159, 0.25);
            color: var(--primary-color, #00ff9f);
            font-size: 20px;
            cursor: pointer;
            border-radius: 50px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4), 0 0 10px rgba(0, 255, 159, 0.1);
            /* Hidden state for stagger animation */
            opacity: 0;
            transform: translateY(12px) scale(0.8);
            filter: blur(8px);
            transition: opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                        transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                        filter 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                        background 0.2s ease,
                        border-color 0.2s ease,
                        box-shadow 0.2s ease;
        }

        .user-menu-dropdown.show .user-menu-item {
            opacity: 1;
            transform: translateY(0) scale(1);
            filter: blur(0px);
        }

        /* Staggered delays  last items appear first (bottom-up feel) */
        .user-menu-dropdown.show .user-menu-item:nth-child(1) { transition-delay: 0.04s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(2) { transition-delay: 0.08s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(3) { transition-delay: 0.12s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(4) { transition-delay: 0.16s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(5) { transition-delay: 0.20s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(6) { transition-delay: 0.24s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(7) { transition-delay: 0.28s; }
        .user-menu-dropdown.show .user-menu-item:nth-child(8) { transition-delay: 0.32s; }

        .user-menu-item:hover {
            background: rgba(0, 255, 159, 0.15);
            border-color: var(--primary-color, #00ff9f);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5), 0 0 18px rgba(0, 255, 159, 0.3);
            transform: scale(1.05);
        }

        .user-menu-divider {
            display: none;
        }

        .user-menu-username {
            font-family: 'VT323', monospace;
            padding: 6px 18px;
            color: var(--accent-color, #00d9ff);
            font-size: 18px;
            text-align: center;
            background: rgba(15, 15, 30, 0.88);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1.5px solid rgba(0, 217, 255, 0.25);
            border-radius: 50px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4), 0 0 10px rgba(0, 217, 255, 0.1);
            opacity: 0;
            transform: translateY(12px) scale(0.8);
            filter: blur(8px);
            transition: opacity 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                        transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1),
                        filter 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .user-menu-dropdown.show .user-menu-username {
            opacity: 1;
            transform: translateY(0) scale(1);
            filter: blur(0px);
            transition-delay: 0.02s;
        }
        /* ============= END USER MENU DROPDOWN ============= */

        /* ============= SOURCE MENU DROPDOWN ============= */
        .source-menu-container {
            position: relative !important;
            display: inline-block;
            overflow: visible;
        }

        .source-menu-btn {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--primary-color, #00ff9f);
            color: var(--primary-color, #00ff9f);
            font-size: 20px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 15px rgba(0, 255, 159, 0.3);
        }

        .source-menu-btn:hover {
            background: rgba(0, 255, 159, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: translateY(-2px);
        }

        .source-menu-dropdown {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 0;
            min-width: 220px;
            background: rgba(15, 15, 30, 0.98);
            backdrop-filter: blur(20px);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 8px;
            padding: 8px;
            display: none;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(0, 255, 159, 0.3);
            animation: slideUp 0.3s ease;
        }

        .source-menu-dropdown.show {
            display: flex;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .source-menu-item {
            font-family: 'VT323', monospace;
            padding: 12px 16px;
            background: transparent;
            border: 2px solid transparent;
            color: var(--primary-color, #00ff9f);
            font-size: 20px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            text-align: left;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .source-menu-item:hover {
            background: rgba(0, 255, 159, 0.1);
            border-color: var(--primary-color, #00ff9f);
            transform: translateX(4px);
        }

        .source-menu-item.active {
            background: rgba(0, 255, 159, 0.15);
            border-color: var(--primary-color, #00ff9f);
        }

        .source-menu-divider {
            height: 2px;
            background: var(--secondary-color, #ff00ff);
            margin: 4px 0;
            opacity: 0.3;
        }

        .source-check {
            color: var(--accent-color, #00d9ff);
            font-size: 24px;
        }
        /* ============= END SOURCE MENU DROPDOWN ============= */

        /* ============= SOURCE TOOLTIP ARROW ============= */
        .source-tooltip-hint {
            position: absolute;
            left: calc(100% + 20px);
            top: 50%;
            transform: translateY(-50%);
            display: none;
            z-index: 100001;
            animation: gentleBounce 2s ease-in-out infinite;
        }

        .source-tooltip-hint.active {
            display: flex;
            align-items: center;
            gap: 0;
            flex-direction: row;
        }

        .source-tooltip-arrow-left {
            width: 0;
            height: 0;
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
            border-right: 15px solid var(--primary-color, #00ff9f);
            filter: drop-shadow(0 0 8px rgba(0, 255, 159, 0.5));
            flex-shrink: 0;
        }

        .source-tooltip-box {
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 8px;
            padding: 12px 40px 12px 16px;
            color: var(--primary-color, #00ff9f);
            font-family: 'VT323', monospace;
            font-size: 18px;
            white-space: nowrap;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.5);
            position: relative;
        }

        .source-tooltip-close {
            position: absolute;
            top: 4px;
            right: 6px;
            background: none;
            border: none;
            color: var(--secondary-color, #ff00ff);
            font-size: 24px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            line-height: 1;
            padding: 8px;
            transition: all 0.2s;
        }

        .source-tooltip-close:hover {
            color: var(--primary-color, #00ff9f);
            transform: scale(1.2);
        }

        @keyframes gentleBounce {
            0%, 100% {
                transform: translateY(-50%) translateX(0);
            }
            50% {
                transform: translateY(-50%) translateX(-8px);
            }
        }

        /* Responsive: Switch to top positioning on smaller screens */
        @media (max-width: 768px) {
            .source-tooltip-hint {
                left: auto;
                right: 0;
                top: auto;
                bottom: calc(100% + 15px);
                transform: none;
                animation: gentleBounceVertical 2s ease-in-out infinite;
            }

            .source-tooltip-hint.active {
                flex-direction: column;
                align-items: flex-end;
            }

            .source-tooltip-arrow-left {
                display: none;
            }

            .source-tooltip-hint::after {
                content: '';
                width: 0;
                height: 0;
                border-left: 12px solid transparent;
                border-right: 12px solid transparent;
                border-top: 15px solid var(--primary-color, #00ff9f);
                filter: drop-shadow(0 0 8px rgba(0, 255, 159, 0.5));
                margin-right: 20px;
            }

            .source-tooltip-box {
                white-space: normal;
                max-width: 200px;
                font-size: 16px;
                padding: 10px 36px 10px 14px;
            }

            @keyframes gentleBounceVertical {
                0%, 100% {
                    transform: translateY(0);
                }
                50% {
                    transform: translateY(5px);
                }
            }
        }

        /* Even smaller screens - compact text */
        @media (max-width: 480px) {
            .source-tooltip-box {
                max-width: 160px;
                font-size: 14px;
                padding: 8px 32px 8px 12px;
            }

            .source-tooltip-close {
                font-size: 20px;
                padding: 6px;
            }
        }
        /* ============= END SOURCE TOOLTIP ARROW ============= */

        /* ============================================================
           GLITCHBOX PREMIUM REDESIGNS - UNIQUE & MEMORABLE
           ============================================================ */

        /* ============= 1. FRIENDS PANEL - "NETWORK TERMINAL" ============= */
        @keyframes networkScan {
            0% { background-position: 0% 0%; }
            100% { background-position: 0% 100%; }
        }

        @keyframes glitchText {
            0%, 100% { text-shadow: 0 0 10px #00ff9f, 2px 2px 0 #ff00ff, -2px -2px 0 #00d9ff; transform: translate(0); }
            25% { text-shadow: -2px 0 10px #ff00ff, 0 2px 0 #00ff9f; transform: translate(-2px, 1px); }
            50% { text-shadow: 2px -1px 10px #00d9ff, -1px 0 0 #ff00ff; transform: translate(1px, -1px); }
            75% { text-shadow: 0 2px 10px #00ff9f, 1px -2px 0 #00d9ff; transform: translate(2px, 1px); }
        }

        @keyframes holoPulse {
            0%, 100% { opacity: 0.8; box-shadow: 0 0 20px rgba(0, 255, 159, 0.3), inset 0 0 30px rgba(0, 255, 159, 0.05); }
            50% { opacity: 1; box-shadow: 0 0 40px rgba(0, 255, 159, 0.5), inset 0 0 50px rgba(0, 255, 159, 0.1); }
        }

        @keyframes statusBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes dataStream {
            0% { background-position: 0 0; }
            100% { background-position: 0 20px; }
        }

        #friendsModal {
            backdrop-filter: blur(10px);
        }

        .friends-terminal {
            max-width: 800px;
            margin: 20px auto;
            background: linear-gradient(145deg, rgba(10, 10, 20, 0.98), rgba(15, 15, 35, 0.98));
            border: none;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            clip-path: polygon(0 0, calc(100% - 30px) 0, 100% 30px, 100% 100%, 30px 100%, 0 calc(100% - 30px));
        }

        .friends-terminal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 159, 0.03) 2px,
                rgba(0, 255, 159, 0.03) 4px
            );
            pointer-events: none;
            animation: dataStream 1s linear infinite;
        }

        .friends-terminal::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: linear-gradient(180deg,
                rgba(0, 255, 159, 0.1) 0%,
                transparent 10%,
                transparent 90%,
                rgba(0, 217, 255, 0.1) 100%
            );
            pointer-events: none;
        }

        .friends-terminal-header {
            background: linear-gradient(90deg, rgba(0, 255, 159, 0.15), rgba(0, 217, 255, 0.1), rgba(255, 0, 255, 0.1));
            padding: 20px 30px;
            border-bottom: 2px solid;
            border-image: linear-gradient(90deg, #00ff9f, #00d9ff, #ff00ff) 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .friends-terminal-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            color: #00ff9f;
            animation: glitchText 3s ease-in-out infinite;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .friends-terminal-title::before {
            content: '';
            font-size: 20px;
            color: #ff00ff;
            animation: statusBlink 1s ease-in-out infinite;
        }

        .friends-terminal-close {
            width: 40px;
            height: 40px;
            background: transparent;
            border: 2px solid #ff00ff;
            color: #ff00ff;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            clip-path: polygon(15% 0%, 100% 0%, 100% 85%, 85% 100%, 0% 100%, 0% 15%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .friends-terminal-close:hover {
            background: #ff00ff;
            color: #0f0f1e;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.8);
            transform: scale(1.1);
        }

        .friends-terminal-body {
            padding: 30px;
            position: relative;
            z-index: 1;
        }

        .friends-section {
            margin-bottom: 30px;
        }

        .friends-section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(0, 217, 255, 0.3);
        }

        .friends-section-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #00d9ff, #00ff9f);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .friends-section-title {
            font-family: 'VT323', monospace;
            font-size: 22px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        /* Friend Request Cards - Holographic Style */
        .friend-request-card {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.1), rgba(0, 217, 255, 0.05));
            border: 1px solid rgba(255, 0, 255, 0.4);
            border-left: 4px solid #ff00ff;
            padding: 16px 20px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            overflow: hidden;
            animation: holoPulse 3s ease-in-out infinite;
            transition: all 0.3s ease;
        }

        .friend-request-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent 40%,
                rgba(255, 0, 255, 0.1) 50%,
                transparent 60%
            );
            animation: networkScan 3s linear infinite;
        }

        .friend-request-card:hover {
            border-color: #ff00ff;
            transform: translateX(5px);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.4);
        }

        .friend-request-info {
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            z-index: 1;
        }

        .friend-avatar {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
            border: 2px solid #00d9ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00d9ff;
            font-family: 'VT323', monospace;
            font-size: 22px;
            position: relative;
        }

        .friend-avatar::after {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px solid transparent;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff9f, #00d9ff, #ff00ff) border-box;
            -webkit-mask: linear-gradient(#fff 0 0) padding-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            animation: statusBlink 2s ease-in-out infinite;
        }

        .friend-username {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #fff;
        }

        .friend-request-actions {
            display: flex;
            gap: 10px;
            position: relative;
            z-index: 1;
        }

        .friend-btn-accept {
            padding: 10px 20px;
            background: transparent;
            border: 2px solid #00ff9f;
            color: #00ff9f;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            clip-path: polygon(10% 0%, 100% 0%, 90% 100%, 0% 100%);
        }

        .friend-btn-accept:hover {
            background: #00ff9f;
            color: #0f0f1e;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
        }

        .friend-btn-reject {
            padding: 10px 20px;
            background: transparent;
            border: 2px solid #ff4444;
            color: #ff4444;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            clip-path: polygon(10% 0%, 100% 0%, 90% 100%, 0% 100%);
        }

        .friend-btn-reject:hover {
            background: #ff4444;
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.6);
        }

        /* Search Input - Terminal Scanner */
        .friends-search-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .friends-search-label {
            position: absolute;
            top: -10px;
            left: 20px;
            background: #0f0f1e;
            padding: 0 10px;
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: #00ff9f;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .friends-search-input {
            width: 100%;
            padding: 18px 20px 18px 50px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 159, 0.3);
            color: #00ff9f;
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
            transition: all 0.3s ease;
        }

        .friends-search-input::placeholder {
            color: rgba(0, 255, 159, 0.4);
        }

        .friends-search-input:focus {
            border-color: #00ff9f;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.3), inset 0 0 30px rgba(0, 255, 159, 0.05);
        }

        .friends-search-icon {
            position: absolute;
            left: 18px;
            top: 50%;
            transform: translateY(-50%);
            color: #00ff9f;
            font-size: 20px;
        }

        /* Friend Card - Online/Offline Status */
        .friend-card {
            background: rgba(0, 217, 255, 0.05);
            border: 1px solid rgba(0, 217, 255, 0.2);
            padding: 14px 18px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }

        .friend-card:hover {
            background: rgba(0, 217, 255, 0.1);
            border-color: #00d9ff;
            transform: translateX(5px);
        }

        .friend-card .friend-avatar {
            width: 42px;
            height: 42px;
            font-size: 18px;
        }

        .friend-status-online::before {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #00ff9f;
            border-radius: 50%;
            border: 2px solid #0f0f1e;
            animation: statusBlink 1.5s ease-in-out infinite;
        }

        .friend-status-offline::before {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            background: #666;
            border-radius: 50%;
            border: 2px solid #0f0f1e;
        }

        .friends-empty-state {
            text-align: center;
            padding: 40px;
            color: rgba(0, 217, 255, 0.5);
            font-family: 'VT323', monospace;
            font-size: 18px;
        }

        /* ============= 2. WATCHPARTY PANEL - "SYNC CHAMBER" ============= */
        @keyframes syncPulse {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.5); opacity: 0; }
        }

        @keyframes connectionLine {
            0% { stroke-dashoffset: 100; }
            100% { stroke-dashoffset: 0; }
        }

        @keyframes frequencyGlow {
            0%, 100% { text-shadow: 0 0 5px #00ff9f, 0 0 10px #00ff9f; }
            50% { text-shadow: 0 0 20px #00ff9f, 0 0 40px #00ff9f, 0 0 60px #00ff9f; }
        }

        #watchpartyPanel.sync-chamber {
            background: linear-gradient(180deg, rgba(10, 10, 25, 0.98), rgba(5, 5, 15, 0.98));
            border: none;
            border-radius: 0;
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%);
            box-shadow:
                0 0 50px rgba(0, 255, 159, 0.2),
                inset 0 0 100px rgba(0, 255, 159, 0.03);
            overflow: visible;
            min-width: 380px;
        }

        #watchpartyPanel.sync-chamber::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(90deg, rgba(0, 255, 159, 0.1) 1px, transparent 1px),
                linear-gradient(rgba(0, 255, 159, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
            pointer-events: none;
        }

        .sync-chamber-header {
            background: linear-gradient(90deg, rgba(0, 255, 159, 0.2), transparent);
            padding: 20px 24px;
            border-bottom: 2px solid #00ff9f;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
        }

        .sync-chamber-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: #00ff9f;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .sync-icon {
            width: 30px;
            height: 30px;
            position: relative;
        }

        .sync-icon::before,
        .sync-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid #00ff9f;
            border-radius: 50%;
        }

        .sync-icon::before {
            width: 10px;
            height: 10px;
            background: #00ff9f;
        }

        .sync-icon::after {
            width: 25px;
            height: 25px;
            animation: syncPulse 2s ease-out infinite;
        }

        .sync-chamber-body {
            padding: 24px;
        }

        .sync-description {
            font-family: 'VT323', monospace;
            color: #00d9ff;
            font-size: 18px;
            text-align: center;
            margin-bottom: 24px;
            padding: 12px;
            background: rgba(0, 217, 255, 0.05);
            border-left: 3px solid #00d9ff;
        }

        .sync-input-group {
            margin-bottom: 20px;
            position: relative;
        }

        .sync-input-label {
            font-family: 'VT323', monospace;
            color: #00ff9f;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
            display: block;
        }

        .sync-input {
            width: 100%;
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            border-bottom: 3px solid rgba(0, 255, 159, 0.3);
            color: #00ff9f;
            font-family: 'VT323', monospace;
            font-size: 20px;
            outline: none;
            transition: all 0.3s ease;
        }

        .sync-input:focus {
            border-bottom-color: #00ff9f;
            box-shadow: 0 5px 30px rgba(0, 255, 159, 0.2);
        }

        .sync-input::placeholder {
            color: rgba(0, 255, 159, 0.3);
        }

        .sync-action-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 24px;
        }

        .sync-action-card {
            padding: 24px 16px;
            background: linear-gradient(135deg, rgba(0, 255, 159, 0.1), transparent);
            border: 2px solid rgba(0, 255, 159, 0.3);
            text-align: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .sync-action-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 159, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .sync-action-card:hover::before {
            left: 100%;
        }

        .sync-action-card:hover {
            border-color: #00ff9f;
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 255, 159, 0.3);
        }

        .sync-action-card.primary {
            background: linear-gradient(135deg, rgba(0, 255, 159, 0.2), rgba(0, 255, 159, 0.05));
            border-color: #00ff9f;
        }

        .sync-action-icon {
            font-size: 32px;
            margin-bottom: 12px;
            display: block;
        }

        .sync-action-label {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #00ff9f;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .sync-divider {
            display: flex;
            align-items: center;
            gap: 16px;
            margin: 20px 0;
        }

        .sync-divider-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 159, 0.5), transparent);
        }

        .sync-divider-text {
            font-family: 'VT323', monospace;
            color: #666;
            font-size: 16px;
        }

        .frequency-code-display {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff9f;
            padding: 16px 24px;
            text-align: center;
            margin-top: 20px;
            position: relative;
        }

        .frequency-code-label {
            position: absolute;
            top: -10px;
            left: 20px;
            background: #0a0a19;
            padding: 0 10px;
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .frequency-code-value {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: #00ff9f;
            letter-spacing: 8px;
            animation: frequencyGlow 2s ease-in-out infinite;
            cursor: pointer;
        }

        /* ============= 3. COMMENTS SECTION - "TRANSMISSION LOG" ============= */
        @keyframes transmissionScan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }

        @keyframes messageReveal {
            0% { opacity: 0; transform: translateX(-20px); }
            100% { opacity: 1; transform: translateX(0); }
        }

        #commentsSection.transmission-log {
            background: linear-gradient(180deg, rgba(8, 8, 20, 0.98), rgba(12, 12, 28, 0.98));
            border: none;
            padding: 0;
            margin-top: 30px;
            position: relative;
            overflow: hidden;
            clip-path: polygon(0 0, calc(100% - 25px) 0, 100% 25px, 100% 100%, 0 100%);
        }

        #commentsSection.transmission-log::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #00ff9f, #00d9ff, #ff00ff);
        }

        #commentsSection.transmission-log::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: linear-gradient(180deg,
                rgba(0, 255, 159, 0.1),
                transparent 20%,
                transparent 80%,
                rgba(0, 217, 255, 0.1)
            );
            pointer-events: none;
        }

        .transmission-header {
            background: linear-gradient(90deg, rgba(0, 255, 159, 0.15), rgba(0, 217, 255, 0.1), transparent);
            padding: 20px 30px;
            border-bottom: 1px solid rgba(0, 255, 159, 0.3);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .transmission-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #00ff9f, #00d9ff);
            clip-path: polygon(20% 0%, 80% 0%, 100% 20%, 100% 80%, 80% 100%, 20% 100%, 0% 80%, 0% 20%);
            display: flex;
            align-items: center;
            justify-content: center;
            animation: statusBlink 2s ease-in-out infinite;
        }

        .transmission-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            color: #00d9ff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .transmission-status {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: #00ff9f;
        }

        .transmission-status::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #00ff9f;
            border-radius: 50%;
            animation: statusBlink 1s ease-in-out infinite;
        }

        .transmission-body {
            padding: 20px 30px;
            max-height: 400px;
            overflow-y: auto;
        }

        .transmission-body::-webkit-scrollbar {
            width: 6px;
        }

        .transmission-body::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        .transmission-body::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #00ff9f, #00d9ff);
            border-radius: 3px;
        }

        /* Message Card - Holographic */
        .transmission-message {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.08), rgba(0, 255, 159, 0.03));
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-left: 3px solid #00d9ff;
            padding: 16px 20px;
            margin-bottom: 16px;
            position: relative;
            animation: messageReveal 0.5s ease-out forwards;
            transition: all 0.3s ease;
        }

        .transmission-message:hover {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.12), rgba(0, 255, 159, 0.06));
            border-color: #00d9ff;
            transform: translateX(5px);
        }

        .transmission-message.own-message {
            border-left-color: #00ff9f;
            background: linear-gradient(135deg, rgba(0, 255, 159, 0.08), rgba(0, 217, 255, 0.03));
        }

        .transmission-message-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }

        .transmission-avatar {
            width: 38px;
            height: 38px;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1e);
            border: 2px solid #00d9ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00d9ff;
            font-family: 'VT323', monospace;
            font-size: 18px;
            position: relative;
        }

        .transmission-avatar::after {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            border: 1px solid;
            border-color: transparent #00d9ff transparent #00d9ff;
            animation: spin 3s linear infinite;
        }

        @keyframes spin {
            100% { transform: rotate(360deg); }
        }

        .transmission-username {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #00d9ff;
            font-weight: bold;
        }

        .own-message .transmission-username {
            color: #00ff9f;
        }

        .transmission-timestamp {
            margin-left: auto;
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.4);
        }

        .transmission-content {
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #e0e0e0;
            line-height: 1.5;
            padding-left: 50px;
        }

        .transmission-actions {
            display: flex;
            gap: 16px;
            padding-left: 50px;
            margin-top: 12px;
        }

        .transmission-action-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-family: 'VT323', monospace;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            padding: 4px 8px;
        }

        .transmission-action-btn:hover {
            color: #00d9ff;
            background: rgba(0, 217, 255, 0.1);
        }

        .transmission-action-btn.liked {
            color: #ff6b9d;
        }

        /* Reply Thread with Connection Lines */
        .transmission-reply {
            margin-left: 30px;
            padding-left: 20px;
            border-left: 2px solid rgba(255, 0, 255, 0.3);
            position: relative;
        }

        .transmission-reply::before {
            content: '';
            position: absolute;
            left: -2px;
            top: 20px;
            width: 20px;
            height: 2px;
            background: rgba(255, 0, 255, 0.3);
        }

        .transmission-reply .transmission-message {
            border-left-color: #ff00ff;
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.06), transparent);
        }

        /* Broadcast Input Terminal */
        .transmission-input-section {
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.5));
            padding: 20px 30px;
            border-top: 1px solid rgba(0, 255, 159, 0.2);
        }

        .transmission-input-wrapper {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 159, 0.3);
            padding: 4px;
        }

        .transmission-input-label {
            position: absolute;
            top: -12px;
            left: 16px;
            background: #0a0a19;
            padding: 2px 12px;
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: #00ff9f;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .transmission-textarea {
            width: 100%;
            min-height: 60px;
            max-height: 150px;
            padding: 16px;
            background: transparent;
            border: none;
            color: #00ff9f;
            font-family: 'VT323', monospace;
            font-size: 18px;
            resize: none;
            outline: none;
        }

        .transmission-textarea::placeholder {
            color: rgba(0, 255, 159, 0.3);
        }

        .transmission-input-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
        }

        .transmission-char-count {
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.4);
        }

        .transmission-submit-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #00ff9f, #00d9ff);
            border: none;
            color: #0f0f1e;
            font-family: 'VT323', monospace;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            clip-path: polygon(10% 0%, 100% 0%, 90% 100%, 0% 100%);
            transition: all 0.3s ease;
        }

        .transmission-submit-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 159, 0.5);
        }

        /* Reply Box Styling */
        .transmission-reply-box {
            background: rgba(255, 0, 255, 0.05);
            border: 1px solid rgba(255, 0, 255, 0.3);
            padding: 12px;
            margin-top: 12px;
            margin-left: 50px;
        }

        .transmission-reply-box textarea {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 0, 255, 0.3);
            color: #ff00ff;
            font-family: 'VT323', monospace;
            font-size: 16px;
            resize: none;
            outline: none;
            min-height: 50px;
        }

        .transmission-reply-box textarea:focus {
            border-color: #ff00ff;
        }

        .transmission-reply-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .transmission-reply-btn {
            padding: 8px 20px;
            background: transparent;
            border: 1px solid #ff00ff;
            color: #ff00ff;
            font-family: 'VT323', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .transmission-reply-btn:hover {
            background: #ff00ff;
            color: #0f0f1e;
        }

        .transmission-reply-btn.cancel {
            border-color: #666;
            color: #666;
        }

        .transmission-reply-btn.cancel:hover {
            background: #666;
            color: #fff;
        }

        /* ============= 4. SOURCE NOTIFICATION - NARROWER WIDTH ============= */
        .source-tooltip-box {
            background: var(--bg-dark, #0f0f1e);
            border: 2px solid var(--primary-color, #00ff9f);
            border-radius: 8px;
            padding: 12px 40px 12px 16px;
            color: var(--primary-color, #00ff9f);
            font-family: 'VT323', monospace;
            font-size: 16px;
            white-space: normal;
            max-width: 180px;
            text-align: center;
            line-height: 1.4;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.5);
            position: relative;
        }

        /* ============= 5. CARD HOVER PANEL - "DATA READOUT" ============= */
        @keyframes dataReadoutScan {
            0% { top: -100%; }
            100% { top: 100%; }
        }

        @keyframes readoutReveal {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); clip-path: polygon(0 50%, 100% 50%, 100% 50%, 0 50%); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); }
        }

        @keyframes gaugeLoad {
            0% { width: 0%; }
        }

        .omdb-ratings-tooltip {
            font-family: 'VT323', monospace;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid #00ff9f;
            padding: 16px 18px;
            z-index: 100;
            width: calc(100% - 24px);
            max-width: 280px;
            min-width: 180px;
            pointer-events: none;
            display: none;
            overflow: visible;
            box-shadow:
                0 0 0 3px rgba(10, 10, 20, 0.9),
                0 0 25px rgba(0, 255, 159, 0.4),
                inset 0 0 30px rgba(0, 255, 159, 0.05);
        }

        .content-card:hover .omdb-ratings-tooltip {
            display: block !important;
            animation: tooltipReveal 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes tooltipReveal {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.95); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .omdb-ratings-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(0, 255, 159, 0.08) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Corner accents */
        .omdb-ratings-tooltip::after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 2px solid transparent;
            background:
                linear-gradient(to right, #00ff9f 12px, transparent 12px) top left,
                linear-gradient(to left, #00ff9f 12px, transparent 12px) top right,
                linear-gradient(to right, #00ff9f 12px, transparent 12px) bottom left,
                linear-gradient(to left, #00ff9f 12px, transparent 12px) bottom right,
                linear-gradient(to bottom, #00ff9f 12px, transparent 12px) top left,
                linear-gradient(to top, #00ff9f 12px, transparent 12px) bottom left,
                linear-gradient(to bottom, #00ff9f 12px, transparent 12px) top right,
                linear-gradient(to top, #00ff9f 12px, transparent 12px) bottom right;
            background-size: 16px 16px;
            background-repeat: no-repeat;
            pointer-events: none;
            opacity: 0.6;
        }

        .data-readout-header {
            background: linear-gradient(90deg, rgba(0, 255, 159, 0.2), transparent);
            padding: 10px 14px;
            border-bottom: 1px solid rgba(0, 255, 159, 0.3);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .data-readout-title {
            font-size: 12px;
            color: #00ff9f;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .data-readout-body {
            padding: 14px;
        }

        .tooltip-rating-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(0, 217, 255, 0.2);
            gap: 12px;
        }

        .tooltip-rating-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .tooltip-rating-row:first-child {
            padding-top: 0;
        }

        .tooltip-rating-source {
            color: #00d9ff;
            font-size: 17px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .tooltip-rating-gauge {
            flex: 1;
            height: 6px;
            background: rgba(0, 0, 0, 0.5);
            margin: 0 12px;
            border-radius: 3px;
            overflow: hidden;
        }

        .tooltip-rating-gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff9f, #00d9ff);
            border-radius: 3px;
            animation: gaugeLoad 0.6s ease-out forwards;
        }

        .tooltip-rating-value {
            color: #00ff9f;
            font-size: 17px;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(0, 255, 159, 0.5);
            white-space: nowrap;
            flex-shrink: 0;
            text-align: right;
        }

        /* Vote count / sub-text styling */
        .omdb-ratings-tooltip > div:not(.tooltip-rating-row):not(.tooltip-loading) {
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: #666;
            padding: 2px 0 6px 0;
            border-bottom: 1px solid rgba(0, 217, 255, 0.1);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .tooltip-runtime-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-top: 10px;
            margin-top: 6px;
            border-top: 1px solid rgba(255, 0, 255, 0.2);
        }

        .tooltip-runtime-icon {
            color: #ff00ff;
            font-size: 16px;
        }

        .tooltip-runtime-value {
            color: #ff00ff;
            font-size: 16px;
        }

        .tooltip-loading {
            color: #00d9ff;
            font-size: 16px;
            text-align: center;
            padding: 20px;
        }

        /* ============= 6. LIVE SPORTS PANEL - WIDER WIDTH ============= */
        .live-slide-panel {
            position: absolute;
            top: calc(100% + 12px);
            right: 0;
            width: 480px;
            background: linear-gradient(145deg, #1a1408 0%, #0f0c05 100%);
            border: 3px solid var(--primary-color, #F5A623);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(245, 166, 35, 0.3);
            opacity: 0;
            visibility: hidden;
            transform: translateX(100%);
            transform-origin: top right;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .live-category-grid.sports-grid {
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .live-category-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-subtle, rgba(245, 166, 35, 0.1));
            border-radius: 10px;
            color: var(--text-primary, #F5F0E8);
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 70px;
        }

        /* ============= AUTH GATE & ONBOARDING STYLES ============= */

        /* Auth Gate - Full Screen Overlay */
        .auth-gate {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999999;
            background: #0a0a14;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            transition: opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .auth-gate.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .auth-gate::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 159, 0.03) 2px,
                    rgba(0, 255, 159, 0.03) 4px
                );
            pointer-events: none;
            animation: scanlines 8s linear infinite;
        }

        @keyframes scanlines {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        .auth-gate::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.4) 100%);
            pointer-events: none;
        }

        /* Floating particles background */
        .auth-particles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .auth-particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ff9f;
            border-radius: 50%;
            opacity: 0.6;
            animation: particleFloat 20s linear infinite;
        }

        @keyframes particleFloat {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-100vh) rotate(360deg); opacity: 0; }
        }

        /* Main terminal container */
        .auth-terminal {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 520px;
            margin: 0 20px;
            background: linear-gradient(145deg, #0f0f1e 0%, #0a0a14 100%);
            border: 3px solid #00ff9f;
            box-shadow:
                0 0 0 1px rgba(0, 255, 159, 0.3),
                0 0 40px rgba(0, 255, 159, 0.2),
                inset 0 0 60px rgba(0, 255, 159, 0.05),
                0 20px 60px rgba(0, 0, 0, 0.8);
            transform: perspective(1000px) rotateX(2deg);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .auth-terminal:hover {
            transform: perspective(1000px) rotateX(0deg);
            box-shadow:
                0 0 0 1px rgba(0, 255, 159, 0.5),
                0 0 60px rgba(0, 255, 159, 0.3),
                inset 0 0 80px rgba(0, 255, 159, 0.08),
                0 30px 80px rgba(0, 0, 0, 0.9);
        }

        /* Terminal header bar */
        .auth-terminal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: linear-gradient(90deg, #00ff9f 0%, #00d9ff 50%, #ff00ff 100%);
            position: relative;
        }

        .auth-terminal-dots {
            display: flex;
            gap: 8px;
        }

        .auth-terminal-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #0a0a14;
            box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .auth-terminal-dot.red { background: #ff5f56; }
        .auth-terminal-dot.yellow { background: #ffbd2e; }
        .auth-terminal-dot.green { background: #27ca40; }

        .auth-terminal-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            color: #0a0a14;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Terminal body */
        .auth-terminal-body {
            padding: 40px 36px;
        }

        /* Logo/Brand */
        .auth-brand {
            text-align: center;
            margin-bottom: 36px;
        }

        .auth-logo {
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: #00ff9f;
            text-shadow:
                3px 3px 0 #ff00ff,
                0 0 20px rgba(0, 255, 159, 0.6),
                0 0 40px rgba(0, 255, 159, 0.4);
            animation: logoGlitch 4s infinite;
            margin-bottom: 12px;
        }

        @keyframes logoGlitch {
            0%, 90%, 100% { transform: translate(0); filter: none; }
            91% { transform: translate(-3px, 2px); filter: hue-rotate(90deg); }
            92% { transform: translate(3px, -2px); filter: hue-rotate(-90deg); }
            93% { transform: translate(-2px, -1px); filter: none; }
            94% { transform: translate(2px, 1px); filter: hue-rotate(180deg); }
        }

        .auth-tagline {
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #00d9ff;
            opacity: 0.8;
        }

        /* Tab switcher */
        .auth-tabs {
            display: flex;
            margin-bottom: 28px;
            border: 2px solid #1a1a2e;
            background: #0a0a14;
        }

        .auth-tab {
            flex: 1;
            padding: 14px 20px;
            font-family: 'VT323', monospace;
            font-size: 22px;
            color: #4a5568;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .auth-tab:hover {
            color: #00d9ff;
            background: rgba(0, 217, 255, 0.05);
        }

        .auth-tab.active {
            color: #00ff9f;
            background: rgba(0, 255, 159, 0.1);
        }

        .auth-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00ff9f, #00d9ff);
            box-shadow: 0 0 10px rgba(0, 255, 159, 0.5);
        }

        /* Form panels */
        .auth-panel {
            display: none;
        }

        .auth-panel.active {
            display: block;
            animation: panelFade 0.3s ease;
        }

        @keyframes panelFade {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Form inputs */
        .auth-input-group {
            margin-bottom: 20px;
            position: relative;
        }

        .auth-input-label {
            display: block;
            font-family: 'VT323', monospace;
            font-size: 18px;
            color: #00d9ff;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .auth-input-label::before {
            content: '>';
            color: #00ff9f;
            margin-right: 8px;
        }

        .auth-input {
            width: 100%;
            padding: 14px 16px;
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #00ff9f;
            background: #0a0a14;
            border: 2px solid #1a1a2e;
            transition: all 0.2s;
        }

        .auth-input:focus {
            outline: none;
            border-color: #00ff9f;
            box-shadow:
                0 0 0 1px rgba(0, 255, 159, 0.3),
                0 0 20px rgba(0, 255, 159, 0.2),
                inset 0 0 20px rgba(0, 255, 159, 0.05);
        }

        .auth-input::placeholder {
            color: #2d3748;
        }

        /* Submit button */
        .auth-submit {
            width: 100%;
            padding: 16px 24px;
            margin-top: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 12px;
            color: #0a0a14;
            background: linear-gradient(135deg, #00ff9f 0%, #00d9ff 100%);
            border: none;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }

        .auth-submit:hover {
            transform: translateY(-2px);
            box-shadow:
                0 8px 25px rgba(0, 255, 159, 0.4),
                0 0 40px rgba(0, 255, 159, 0.2);
        }

        .auth-submit:active {
            transform: translateY(0);
        }

        .auth-submit::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: buttonShimmer 3s infinite;
        }

        @keyframes buttonShimmer {
            0%, 100% { left: -100%; }
            50% { left: 100%; }
        }

        /* Error display */
        .auth-error {
            display: none;
            padding: 12px 16px;
            margin-bottom: 20px;
            background: rgba(255, 107, 107, 0.1);
            border: 2px solid #ff6b6b;
            color: #ff6b6b;
            font-family: 'VT323', monospace;
            font-size: 18px;
        }

        .auth-error.visible {
            display: block;
            animation: errorShake 0.5s ease;
        }

        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            50% { transform: translateX(8px); }
            75% { transform: translateX(-4px); }
        }

        /* ============= ONBOARDING OVERLAY ============= */

        .onboarding-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999998;
            background: rgba(10, 10, 20, 0.97);
            display: none;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            overflow: hidden;
        }

        .onboarding-overlay.active {
            display: flex;
            opacity: 1;
        }

        .onboarding-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 3px,
                    rgba(0, 255, 159, 0.015) 3px,
                    rgba(0, 255, 159, 0.015) 6px
                );
            pointer-events: none;
        }

        /* Onboarding container */
        .onboarding-container {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: 800px;
            margin: 0 20px;
            text-align: center;
        }

        /* Progress indicator */
        .onboarding-progress {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-bottom: 48px;
        }

        .onboarding-progress-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #1a1a2e;
            border: 2px solid #2d3748;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .onboarding-progress-dot.active {
            background: #00ff9f;
            border-color: #00ff9f;
            box-shadow: 0 0 20px rgba(0, 255, 159, 0.6);
            transform: scale(1.2);
        }

        .onboarding-progress-dot.completed {
            background: #00d9ff;
            border-color: #00d9ff;
        }

        /* Slide container */
        .onboarding-slide {
            display: none;
            opacity: 0;
            transform: translateX(50px);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .onboarding-slide.active {
            display: block;
            opacity: 1;
            transform: translateX(0);
        }

        .onboarding-slide.exiting {
            opacity: 0;
            transform: translateX(-50px);
        }

        /* Slide icon/illustration */
        .onboarding-icon {
            width: 140px;
            height: 140px;
            margin: 0 auto 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(145deg, rgba(0, 255, 159, 0.1), rgba(0, 217, 255, 0.1));
            border: 3px solid #00ff9f;
            border-radius: 50%;
            position: relative;
            animation: iconPulse 3s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 159, 0.3); }
            50% { box-shadow: 0 0 50px rgba(0, 255, 159, 0.5), 0 0 80px rgba(0, 217, 255, 0.3); }
        }

        .onboarding-icon img {
            width: 70px;
            height: 70px;
            filter: drop-shadow(0 0 10px rgba(0, 255, 159, 0.5));
        }

        .onboarding-icon-emoji {
            font-size: 64px;
            filter: drop-shadow(0 0 10px rgba(0, 255, 159, 0.5));
        }

        /* Slide text */
        .onboarding-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #00ff9f;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 159, 0.5);
            line-height: 1.6;
        }

        .onboarding-description {
            font-family: 'VT323', monospace;
            font-size: 26px;
            color: #e0e0e0;
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto 40px;
            opacity: 0.9;
        }

        .onboarding-highlight {
            color: #00d9ff;
            font-weight: bold;
        }

        /* Feature list */
        .onboarding-features {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
            margin-bottom: 40px;
        }

        .onboarding-feature {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            background: rgba(0, 255, 159, 0.05);
            border: 2px solid #1a1a2e;
            font-family: 'VT323', monospace;
            font-size: 20px;
            color: #00d9ff;
            transition: all 0.3s;
        }

        .onboarding-feature:hover {
            border-color: #00ff9f;
            background: rgba(0, 255, 159, 0.1);
            transform: translateY(-2px);
        }

        .onboarding-feature-icon {
            width: 28px;
            height: 28px;
        }

        /* Navigation buttons */
        .onboarding-nav {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .onboarding-btn {
            padding: 16px 40px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            color: #00ff9f;
            background: transparent;
            border: 3px solid #00ff9f;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .onboarding-btn:hover {
            color: #0a0a14;
            background: #00ff9f;
            box-shadow: 0 0 30px rgba(0, 255, 159, 0.5);
        }

        .onboarding-btn.primary {
            color: #0a0a14;
            background: linear-gradient(135deg, #00ff9f 0%, #00d9ff 100%);
            border: none;
        }

        .onboarding-btn.primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 40px rgba(0, 255, 159, 0.4);
        }

        .onboarding-btn.skip {
            color: #4a5568;
            border-color: #2d3748;
        }

        .onboarding-btn.skip:hover {
            color: #ff00ff;
            border-color: #ff00ff;
            background: rgba(255, 0, 255, 0.1);
        }

        /* Welcome slide special styling */
        .onboarding-welcome-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 36px;
            color: #00ff9f;
            margin-bottom: 16px;
            text-shadow:
                4px 4px 0 #ff00ff,
                0 0 30px rgba(0, 255, 159, 0.6);
            animation: welcomeGlitch 5s infinite;
        }

        @keyframes welcomeGlitch {
            0%, 92%, 100% { transform: translate(0); }
            93% { transform: translate(-4px, 3px); }
            94% { transform: translate(4px, -3px); }
            95% { transform: translate(-3px, -2px); }
            96% { transform: translate(3px, 2px); }
        }

        .onboarding-username {
            color: #ff00ff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }

        /* Final slide confetti effect */
        .onboarding-confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }

        .onboarding-confetti.active {
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .auth-terminal {
                margin: 0 12px;
                transform: none;
            }

            .auth-terminal:hover {
                transform: none;
            }

            .auth-terminal-body {
                padding: 28px 24px;
            }

            .auth-logo {
                font-size: 22px;
            }

            .auth-tab {
                font-size: 18px;
                padding: 12px 16px;
            }

            .onboarding-title {
                font-size: 16px;
            }

            .onboarding-welcome-title {
                font-size: 24px;
            }

            .onboarding-description {
                font-size: 22px;
            }

            .onboarding-icon {
                width: 100px;
                height: 100px;
            }

            .onboarding-icon img,
            .onboarding-icon-emoji {
                width: 50px;
                height: 50px;
                font-size: 48px;
            }

            .onboarding-btn {
                padding: 14px 28px;
                font-size: 20px;
            }

            .onboarding-features {
                flex-direction: column;
                align-items: center;
            }
        }

        /* ============= END AUTH GATE & ONBOARDING STYLES ============= */

        /* ============= SPOTLIGHT CARD BORDER EFFECT ============= */
        .spotlight-card {
            --spotlight-size: 200;
            --spotlight-base: 180;
            --spotlight-spread: 200;
            --spotlight-hue: calc(var(--spotlight-base) + (var(--mouse-xp, 0) * var(--spotlight-spread)));
            --spotlight-border-size: calc(var(--spotlight-border, 2) * 1px);
            --spotlight-spot-size: calc(var(--spotlight-size) * 1px);
            position: relative;
        }

        /* Per-card border width */
        .content-card.spotlight-card,
        .continue-item.spotlight-card {
            --spotlight-border: 3;
        }

        .sync-action-card.spotlight-card {
            --spotlight-border: 2;
        }

        .player-watchlist-list-card.spotlight-card,
        .watchlist-slide-list-card.spotlight-card,
        .watchlist-item-card.spotlight-card,
        .friend-request-card.spotlight-card,
        .friend-card.spotlight-card {
            --spotlight-border: 1;
        }

        /* Override border-color across all states */
        .spotlight-card,
        .spotlight-card:hover,
        .spotlight-card:active,
        .spotlight-card.active,
        .spotlight-card.selected {
            border-color: hsl(0 0% 60% / 0.12) !important;
        }

        /* Normalize friend-request-card left border */
        .friend-request-card.spotlight-card {
            border-left-width: 1px !important;
        }

        /* Override overflow for cards that clip pseudo-elements */
        .continue-item.spotlight-card,
        .friend-request-card.spotlight-card,
        .sync-action-card.spotlight-card {
            overflow: visible !important;
        }

        /* Shared pseudo-element styles for spotlight border */
        .spotlight-card::before,
        .spotlight-card::after {
            content: "" !important;
            display: block !important;
            position: absolute !important;
            inset: calc(var(--spotlight-border-size) * -1) !important;
            border: var(--spotlight-border-size) solid transparent !important;
            border-radius: inherit !important;
            background-attachment: fixed !important;
            background-size: calc(100% + (2 * var(--spotlight-border-size))) calc(100% + (2 * var(--spotlight-border-size))) !important;
            background-repeat: no-repeat !important;
            background-position: 50% 50% !important;
            background-color: transparent !important;
            pointer-events: none !important;
            z-index: 2 !important;
            width: auto !important;
            height: auto !important;
            transform: none !important;
            animation: none !important;
            padding: 0 !important;
            margin: 0 !important;
            mask: linear-gradient(transparent, transparent), linear-gradient(white, white);
            mask-clip: padding-box, border-box;
            mask-composite: intersect;
            -webkit-mask: linear-gradient(transparent, transparent), linear-gradient(white, white);
            -webkit-mask-clip: padding-box, border-box;
            -webkit-mask-composite: xor;
        }

        /* Colored glow border */
        .spotlight-card::before {
            background-image: radial-gradient(
                calc(var(--spotlight-spot-size) * 0.75) calc(var(--spotlight-spot-size) * 0.75) at
                calc(var(--mouse-x, 0) * 1px) calc(var(--mouse-y, 0) * 1px),
                hsl(var(--spotlight-hue, 210) 100% 50% / 1),
                transparent 100%
            ) !important;
            filter: brightness(2) !important;
        }

        /* White highlight border */
        .spotlight-card::after {
            background-image: radial-gradient(
                calc(var(--spotlight-spot-size) * 0.5) calc(var(--spotlight-spot-size) * 0.5) at
                calc(var(--mouse-x, 0) * 1px) calc(var(--mouse-y, 0) * 1px),
                hsl(0 100% 100% / 1),
                transparent 100%
            ) !important;
            filter: none !important;
            opacity: 1 !important;
        }
        /* ============= END SPOTLIGHT CARD BORDER EFFECT ============= */

        /* ============= LIQUID GLASS DOCK ============= */
        .glass-dock-wrapper {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
            pointer-events: none;
        }

        .glass-dock {
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 10px 14px;
            border-radius: 24px;
            position: relative;
            cursor: default;
            box-shadow: 0 6px 32px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(255,255,255,0.08);
            transition: padding 0.7s cubic-bezier(0.175, 0.885, 0.32, 2.2),
                        border-radius 0.7s cubic-bezier(0.175, 0.885, 0.32, 2.2),
                        gap 0.7s cubic-bezier(0.175, 0.885, 0.32, 2.2);
        }

        .glass-dock:hover {
            padding: 12px 18px;
            gap: 10px;
            border-radius: 28px;
        }

        /* Glass layers */
        .glass-dock-blur {
            position: absolute;
            inset: 0;
            z-index: 0;
            overflow: hidden;
            border-radius: inherit;
            backdrop-filter: blur(18px) saturate(1.6);
            -webkit-backdrop-filter: blur(18px) saturate(1.6);
            filter: url(#glass-distortion);
            isolation: isolate;
        }

        .glass-dock-tint {
            position: absolute;
            inset: 0;
            z-index: 1;
            border-radius: inherit;
            background: rgba(255, 255, 255, 0.12);
        }

        .glass-dock-specular {
            position: absolute;
            inset: 0;
            z-index: 2;
            border-radius: inherit;
            overflow: hidden;
            box-shadow:
                inset 1.5px 1.5px 1px 0 rgba(255,255,255,0.45),
                inset -1px -1px 1px 0.5px rgba(255,255,255,0.25);
        }

        .glass-dock-items {
            position: relative;
            z-index: 3;
            display: flex;
            align-items: center;
            gap: inherit;
        }

        /* Dock icon buttons */
        .glass-dock-btn {
            width: 52px;
            height: 52px;
            border-radius: 16px;
            border: none;
            background: rgba(255,255,255,0.06);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 2.2);
            position: relative;
            color: rgba(255,255,255,0.85);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            padding: 0;
        }

        .glass-dock-btn:hover {
            transform: scale(1.18) translateY(-4px);
            background: rgba(255,255,255,0.14);
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        }

        .glass-dock-btn:active {
            transform: scale(0.95);
        }

        .glass-dock-btn.dock-active {
            background: rgba(255,255,255,0.22);
            box-shadow: 0 4px 20px rgba(255,255,255,0.1), 0 0 0 1.5px rgba(255,255,255,0.2);
        }

        .glass-dock-btn img {
            width: 30px;
            height: 30px;
            pointer-events: none;
            filter: brightness(1.1);
        }

        .glass-dock-btn svg {
            width: 24px;
            height: 24px;
            pointer-events: none;
        }

        /* Active dot indicator under button */
        .glass-dock-btn.dock-active::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: rgba(255,255,255,0.7);
            box-shadow: 0 0 6px rgba(255,255,255,0.4);
        }

        /* Dock separator */
        .glass-dock-sep {
            width: 1px;
            height: 28px;
            background: rgba(255,255,255,0.12);
            border-radius: 1px;
            flex-shrink: 0;
        }

        /* Tooltip */
        .glass-dock-btn::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%) scale(0.8);
            padding: 5px 12px;
            border-radius: 8px;
            background: rgba(30,30,30,0.85);
            backdrop-filter: blur(12px);
            color: rgba(255,255,255,0.9);
            font-family: 'Outfit', 'VT323', sans-serif;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.02em;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 2.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .glass-dock-btn:hover::before {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

        /* ---- DOCK PANEL ANIMATIONS ---- */
        /* Panels now rise from the dock area */
        .dock-panel-anchor {
            position: fixed;
            bottom: 90px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 199999;
            pointer-events: none;
            display: flex;
            justify-content: center;
            width: 420px;
            max-width: 94vw;
        }

        .dock-panel-anchor > * {
            pointer-events: auto;
        }

        /* Override panel animations for dock-driven panels */
        /* User menu dropdown - now anchored to dock */
        .user-menu-dropdown.dock-panel {
            position: fixed !important;
            bottom: 110px !important;
            left: 50% !important;
            top: auto !important;
            right: auto !important;
            transform: translateX(-50%) translateY(20px) scale(0.92) !important;
            transform-origin: bottom center !important;
            opacity: 0 !important;
            visibility: hidden !important;
            min-width: 240px !important;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.4) !important;
            z-index: 199999 !important;
            max-height: 70vh;
            overflow-y: auto;
            background: none !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
            padding: 8px !important;
        }

        .user-menu-dropdown.dock-panel.show {
            transform: translateX(-50%) translateY(0) scale(1) !important;
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Logout button in dock panel  no pill styling */
        .user-menu-dropdown.dock-panel .user-menu-item:last-child {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            backdrop-filter: none !important;
            -webkit-backdrop-filter: none !important;
        }

        /* Watchlist panel - dock driven */
        .watchlist-slide-panel.dock-panel {
            position: fixed !important;
            bottom: 110px !important;
            left: 50% !important;
            top: auto !important;
            right: auto !important;
            transform: translateX(-50%) translateY(30px) scale(0.9) !important;
            transform-origin: bottom center !important;
            opacity: 0 !important;
            visibility: hidden !important;
            width: 400px !important;
            max-width: 94vw !important;
            max-height: 70vh !important;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.4) !important;
            z-index: 199999 !important;
            border-radius: 16px !important;
        }

        .watchlist-slide-panel.dock-panel.active {
            transform: translateX(-50%) translateY(0) scale(1) !important;
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Live panel - dock driven */
        .live-slide-panel.dock-panel {
            position: fixed !important;
            bottom: 110px !important;
            left: 50% !important;
            top: auto !important;
            right: auto !important;
            transform: translateX(-50%) translateY(30px) scale(0.9) !important;
            transform-origin: bottom center !important;
            opacity: 0 !important;
            visibility: hidden !important;
            width: 500px !important;
            max-width: 94vw !important;
            max-height: 70vh !important;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.4) !important;
            z-index: 199999 !important;
            border-radius: 16px !important;
        }

        .live-slide-panel.dock-panel.active {
            transform: translateX(-50%) translateY(0) scale(1) !important;
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Search panel - dock driven */
        .floating-search-panel.dock-panel {
            position: fixed !important;
            bottom: 110px !important;
            left: 50% !important;
            top: auto !important;
            right: auto !important;
            transform: translateX(-50%) translateY(30px) scale(0.9) !important;
            transform-origin: bottom center !important;
            opacity: 0 !important;
            visibility: hidden !important;
            width: 420px !important;
            max-width: 94vw !important;
            max-height: 70vh !important;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.4) !important;
            z-index: 199999 !important;
            border-radius: 16px !important;
        }

        .floating-search-panel.dock-panel.active {
            transform: translateX(-50%) translateY(0) scale(1) !important;
            opacity: 1 !important;
            visibility: visible !important;
        }

        /* Hide original standalone buttons when dock is active */
        body.glass-dock-active .user-menu-container > .user-menu-btn,
        body.glass-dock-active .user-menu-container > .friend-request-notification-left,
        body.glass-dock-active .user-menu-container > .user-menu-dropdown:not(.dock-panel) {
            display: none !important;
        }
        body.glass-dock-active #watchlistContainer > .watchlist-trigger-btn {
            display: none !important;
        }
        body.glass-dock-active #liveContainer > #liveTriggerBtn {
            display: none !important;
        }
        body.glass-dock-active #floatingSearch > .floating-search-btn {
            display: none !important;
        }
        /* Also hide the party button in top-right since dock replaces top nav */
        body.glass-dock-active .bg-animation-toggle[onclick*="toggleWatchpartyPanel"] {
            display: none !important;
        }

        /* Dock responsive */
        @media (max-width: 480px) {
            .glass-dock-wrapper {
                bottom: 12px;
            }
            .glass-dock {
                padding: 8px 10px;
                gap: 4px;
            }
            .glass-dock-btn {
                width: 44px;
                height: 44px;
                border-radius: 14px;
            }
            .glass-dock-btn img {
                width: 24px;
                height: 24px;
            }
            .glass-dock-btn svg {
                width: 20px;
                height: 20px;
            }
            .user-menu-dropdown.dock-panel,
            .watchlist-slide-panel.dock-panel,
            .live-slide-panel.dock-panel,
            .floating-search-panel.dock-panel {
                bottom: 96px !important;
            }
        }
        /* ============= END LIQUID GLASS DOCK ============= */

    </style>

    <!-- Monetag Ads Integration -->
    <!-- Push Notifications - Zone 10039525 -->
    <!-- <script src="//cdn.webpushs.com/js/push/af80e01f7f3e9a2cfc87f4f7c24833c8_1.js" async></script> -->

    <!-- In-Page Push - Zone 10039522 -->
    <!-- <script type="text/javascript" src="//pl25015888.cpmrevenuegate.com/bc/b9/07/bcb907ef732c6ac0daed2e2ad61d9bb0.js"></script> -->
    <script src="base64-images.js"></script>
</head>
<body>
    <!-- ============= AUTH GATE OVERLAY ============= -->
    <div class="auth-gate" id="authGate">
        <!-- Floating particles -->
        <div class="auth-particles" id="authParticles"></div>

        <!-- Main terminal -->
        <div class="auth-terminal">
            <div class="auth-terminal-header">
                <div class="auth-terminal-dots">
                    <div class="auth-terminal-dot red"></div>
                    <div class="auth-terminal-dot yellow"></div>
                    <div class="auth-terminal-dot green"></div>
                </div>
                <div class="auth-terminal-title">Access Terminal</div>
                <div style="width: 52px;"></div>
            </div>

            <div class="auth-terminal-body">
                <div class="auth-brand">
                    <div class="auth-logo">GlitchBox</div>
                    <div class="auth-tagline">// initialize your streaming experience</div>
                </div>

                <!-- Tab switcher -->
                <div class="auth-tabs">
                    <button class="auth-tab active" id="authLoginTab" onclick="switchAuthTab('login')">Sign In</button>
                    <button class="auth-tab" id="authSignupTab" onclick="switchAuthTab('signup')">Sign Up</button>
                </div>

                <!-- Login Panel -->
                <div class="auth-panel active" id="authLoginPanel">
                    <div class="auth-error" id="authLoginError"></div>
                    <form id="authLoginForm" onsubmit="handleAuthGateLogin(event)">
                        <div class="auth-input-group">
                            <label class="auth-input-label">Username</label>
                            <input type="text" class="auth-input" id="authLoginUsername" placeholder="enter_username" required autocomplete="username">
                        </div>
                        <div class="auth-input-group">
                            <label class="auth-input-label">Password</label>
                            <input type="password" class="auth-input" id="authLoginPassword" placeholder="********" required autocomplete="current-password">
                        </div>
                        <button type="submit" class="auth-submit">Initialize Session</button>
                    </form>
                </div>

                <!-- Signup Panel -->
                <div class="auth-panel" id="authSignupPanel">
                    <div class="auth-error" id="authSignupError"></div>
                    <form id="authSignupForm" onsubmit="handleAuthGateSignup(event)">
                        <div class="auth-input-group">
                            <label class="auth-input-label">Username</label>
                            <input type="text" class="auth-input" id="authSignupUsername" placeholder="choose_username" required autocomplete="username">
                        </div>
                        <div class="auth-input-group">
                            <label class="auth-input-label">Email</label>
                            <input type="email" class="auth-input" id="authSignupEmail" placeholder="user@domain.com" required autocomplete="email">
                        </div>
                        <div class="auth-input-group">
                            <label class="auth-input-label">Password</label>
                            <input type="password" class="auth-input" id="authSignupPassword" placeholder="min 6 characters" required minlength="6" autocomplete="new-password">
                        </div>
                        <button type="submit" class="auth-submit">Create Account</button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- ============= ONBOARDING OVERLAY ============= -->
    <div class="onboarding-overlay" id="onboardingOverlay">
        <div class="onboarding-container">
            <!-- Progress dots -->
            <div class="onboarding-progress" id="onboardingProgress"></div>

            <!-- Slide 0: Welcome -->
            <div class="onboarding-slide" id="onboardingSlide0">
                <div class="onboarding-icon">
                    <span class="onboarding-icon-emoji">&#127881;</span>
                </div>
                <h2 class="onboarding-welcome-title">Welcome, <span class="onboarding-username" id="onboardingUsername">User</span>!</h2>
                <p class="onboarding-description">
                    Your account is ready. Let's take a quick tour of <span class="onboarding-highlight">GlitchBox</span> and discover everything you can do.
                </p>
            </div>

            <!-- Slide 1: Browse Content -->
            <div class="onboarding-slide" id="onboardingSlide1">
                <div class="onboarding-icon">
                    <img src="Icons/movie.png" alt="Movies" onerror="this.parentElement.innerHTML='<span class=onboarding-icon-emoji>&#127916;</span>'">
                </div>
                <h2 class="onboarding-title">Browse Movies & TV Shows</h2>
                <p class="onboarding-description">
                    Explore thousands of <span class="onboarding-highlight">movies</span> and <span class="onboarding-highlight">TV series</span>. Use the navigation buttons or search to find your favorites.
                </p>
                <div class="onboarding-features">
                    <div class="onboarding-feature">
                        <img src="Icons/popular.png" alt="Popular" class="onboarding-feature-icon" onerror="this.style.display='none'">
                        <span>Popular</span>
                    </div>
                    <div class="onboarding-feature">
                        <img src="Icons/trending.png" alt="Trending" class="onboarding-feature-icon" onerror="this.style.display='none'">
                        <span>Trending</span>
                    </div>
                    <div class="onboarding-feature">
                        <img src="Icons/upcoming.png" alt="Upcoming" class="onboarding-feature-icon" onerror="this.style.display='none'">
                        <span>Upcoming</span>
                    </div>
                </div>
            </div>

            <!-- Slide 2: Watchlist -->
            <div class="onboarding-slide" id="onboardingSlide2">
                <div class="onboarding-icon">
                    <img src="Icons/playlist.png" alt="Watchlist" onerror="this.parentElement.innerHTML='<span class=onboarding-icon-emoji>&#128278;</span>'">
                </div>
                <h2 class="onboarding-title">Create Watchlists</h2>
                <p class="onboarding-description">
                    Save movies and shows to your personal <span class="onboarding-highlight">watchlists</span>. Create multiple lists and organize your content however you like.
                </p>
                <div class="onboarding-features">
                    <div class="onboarding-feature">
                        <span>&#43;</span>
                        <span>Add to List</span>
                    </div>
                    <div class="onboarding-feature">
                        <span>&#9654;</span>
                        <span>Continue Watching</span>
                    </div>
                </div>
            </div>

            <!-- Slide 3: Friends -->
            <div class="onboarding-slide" id="onboardingSlide3">
                <div class="onboarding-icon">
                    <img src="Icons/friends.png" alt="Friends" onerror="this.parentElement.innerHTML='<span class=onboarding-icon-emoji>&#128101;</span>'">
                </div>
                <h2 class="onboarding-title">Connect With Friends</h2>
                <p class="onboarding-description">
                    Add friends and see what they're watching. <span class="onboarding-highlight">Rate content</span>, leave <span class="onboarding-highlight">comments</span>, and share recommendations.
                </p>
                <div class="onboarding-features">
                    <div class="onboarding-feature">
                        <span>&#9733;</span>
                        <span>Rate Movies</span>
                    </div>
                    <div class="onboarding-feature">
                        <span>&#128172;</span>
                        <span>Comments</span>
                    </div>
                </div>
            </div>

            <!-- Slide 4: Watch Party -->
            <div class="onboarding-slide" id="onboardingSlide4">
                <div class="onboarding-icon">
                    <img src="Icons/party.png" alt="Watch Party" onerror="this.parentElement.innerHTML='<span class=onboarding-icon-emoji>&#127881;</span>'">
                </div>
                <h2 class="onboarding-title">Host Watch Parties</h2>
                <p class="onboarding-description">
                    Watch together in <span class="onboarding-highlight">real-time</span> with friends! Create a room, share the code, and enjoy synchronized playback.
                </p>
                <div class="onboarding-features">
                    <div class="onboarding-feature">
                        <span>&#128250;</span>
                        <span>Synced Playback</span>
                    </div>
                    <div class="onboarding-feature">
                        <span>&#128490;</span>
                        <span>Live Chat</span>
                    </div>
                </div>
            </div>

            <!-- Slide 5: Live TV & Sports -->
            <div class="onboarding-slide" id="onboardingSlide5">
                <div class="onboarding-icon">
                    <img src="Icons/live-now.png" alt="Live TV" onerror="this.parentElement.innerHTML='<span class=onboarding-icon-emoji>&#128250;</span>'">
                </div>
                <h2 class="onboarding-title">Live TV & Sports</h2>
                <p class="onboarding-description">
                    Stream <span class="onboarding-highlight">live channels</span> from around the world and catch <span class="onboarding-highlight">live sports</span> events as they happen.
                </p>
                <div class="onboarding-features">
                    <div class="onboarding-feature">
                        <span>&#127760;</span>
                        <span>Global Channels</span>
                    </div>
                    <div class="onboarding-feature">
                        <span>&#9917;</span>
                        <span>Sports Streams</span>
                    </div>
                </div>
            </div>

            <!-- Slide 6: Themes -->
            <div class="onboarding-slide" id="onboardingSlide6">
                <div class="onboarding-icon">
                    <img src="Icons/theme.png" alt="Themes" onerror="this.parentElement.innerHTML='<span class=onboarding-icon-emoji>&#127912;</span>'">
                </div>
                <h2 class="onboarding-title">Customize Your Look</h2>
                <p class="onboarding-description">
                    Choose from multiple <span class="onboarding-highlight">themes</span> and toggle visual <span class="onboarding-highlight">effects</span> to make GlitchBox uniquely yours.
                </p>
                <div class="onboarding-features">
                    <div class="onboarding-feature">
                        <span>&#127752;</span>
                        <span>Themes</span>
                    </div>
                    <div class="onboarding-feature">
                        <span>&#10024;</span>
                        <span>Effects</span>
                    </div>
                </div>
            </div>

            <!-- Slide 7: Ready -->
            <div class="onboarding-slide" id="onboardingSlide7">
                <div class="onboarding-icon" style="border-color: #ff00ff; animation-name: none; background: linear-gradient(145deg, rgba(255, 0, 255, 0.15), rgba(0, 255, 159, 0.15));">
                    <span class="onboarding-icon-emoji">&#128640;</span>
                </div>
                <h2 class="onboarding-title" style="color: #ff00ff;">You're All Set!</h2>
                <p class="onboarding-description">
                    Start exploring and enjoy your <span class="onboarding-highlight">GlitchBox</span> experience. Happy streaming!
                </p>
            </div>

            <!-- Navigation -->
            <div class="onboarding-nav">
                <button class="onboarding-btn skip" id="onboardingSkip" onclick="skipOnboarding()">Skip</button>
                <button class="onboarding-btn primary" id="onboardingNext" onclick="nextOnboardingSlide()">Next</button>
            </div>
        </div>
    </div>

    <!-- Monetag Ads - OnClick Popunder - Zone 10039521 -->
    <!-- <script type="text/javascript">
        atOptions = {
            'key' : '8af468976c973602ab1d62e5e750e8e3',
            'format' : 'iframe',
            'height' : 90,
            'width' : 728,
            'params' : {}
        };
    </script>
    <script type="text/javascript" src="//www.highperformanceformat.com/8af468976c973602ab1d62e5e750e8e3/invoke.js"></script>
-->

    <!-- CRT Boot Sequence Overlay (Phosphor Theme Only) -->
    <div id="crtBootOverlay" class="crt-boot-overlay">
        <div class="crt-boot-screen">
            <div class="crt-boot-line"></div>
            <div class="crt-boot-text"></div>
        </div>
    </div>

    <!-- CRT Scanlines Overlay (Phosphor Theme Only) -->
    <div id="crtScanlines" class="crt-scanlines-overlay"></div>

    <!-- CRT Curvature/Vignette Overlay (Phosphor Theme Only) -->
    <div id="crtCurvature" class="crt-curvature-overlay"></div>

    <!-- Floating Search (Below Live Button) -->
    <div id="floatingSearch" class="floating-search">
        <button class="floating-search-btn" onclick="toggleFloatingSearch()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <path d="m21 21-4.35-4.35"/>
            </svg>
        </button>
        <div class="floating-search-panel">
            <div class="floating-search-header">
                <span class="terminal-prompt">&gt; SEARCH DATABASE</span>
                <button class="floating-search-close" onclick="toggleFloatingSearch()">&times;</button>
            </div>
            <div class="floating-search-input-wrapper">
                <span class="terminal-cursor">&gt;</span>
                <input type="text" id="floatingSearchInput" class="floating-search-input" placeholder="Enter search query..." autocomplete="off">
                <button class="floating-search-clear" id="floatingSearchClear" onclick="clearFloatingSearch()" title="Clear search">&times;</button>
            </div>
            <div id="floatingSearchResults" class="floating-search-results"></div>
        </div>
    </div>

    <!-- Watchlist Button & Panel (Below User Menu) -->
    <div id="watchlistContainer" class="watchlist-container">
        <button class="watchlist-trigger-btn" id="watchlistTriggerBtn" onclick="toggleWatchlistPanel()">
            <img src="to-do-list.png" alt="My Lists" class="watchlist-icon" style="width: 22px; height: 22px;">
            <span class="watchlist-trigger-label">My Lists</span>
        </button>

        <div class="watchlist-slide-panel" id="watchlistSlidePanel">
            <div class="watchlist-slide-header">
                <div class="watchlist-slide-title-row">
                    <h2 class="watchlist-slide-title" id="watchlistSlideTitle">My Watchlists</h2>
                    <button class="watchlist-slide-close" onclick="toggleWatchlistPanel()">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M18 6L6 18M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- Lists View -->
            <div class="watchlist-slide-lists" id="watchlistSlideLists">
                <!-- Lists populated by JS -->
            </div>

            <!-- Items View (hidden by default) -->
            <div class="watchlist-slide-items" id="watchlistSlideItems" style="display: none;">
                <button class="watchlist-slide-back" onclick="showWatchlistListsView()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                    Back to Lists
                </button>
                <div class="watchlist-slide-items-grid" id="watchlistSlideItemsGrid">
                    <!-- Items populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Live Section Button & Panel -->
    <div id="liveContainer" class="live-container">
        <button id="liveTriggerBtn" onclick="toggleLivePanel()" style="padding: 0; margin: 0; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center;">
            <img src="live-stream.png" alt="Live" class="live-icon" style="width: 64px; height: 64px; display: block;">
        </button>

        <div class="live-slide-panel" id="liveSlidePanel">
            <!-- Main Options View -->
            <div class="live-main-options" id="liveMainOptions">
                <div class="live-options">
                    <button class="live-option-btn live-option-btn-icon-only" onclick="showLiveCategories('channels')" title="Live Channels" style="flex-direction: column; gap: 8px;">
                        <img src="live-tv.png" alt="Channels" class="live-icon" style="width: 64px; height: 64px;">
                        <span style="font-family: 'VT323', monospace; font-size: 16px; color: var(--text-primary, #F5F0E8); text-transform: uppercase; letter-spacing: 0.05em;">Channels</span>
                    </button>
                    <button class="live-option-btn live-option-btn-icon-only" onclick="showLiveCategories('sports')" title="Live Sports" style="flex-direction: column; gap: 8px;">
                        <img src="Icons/LiveIcons/sports.png" alt="Sports" class="live-icon" style="width: 64px; height: 64px;">
                        <span style="font-family: 'VT323', monospace; font-size: 16px; color: var(--text-primary, #F5F0E8); text-transform: uppercase; letter-spacing: 0.05em;">Sports</span>
                    </button>
                </div>
            </div>

            <!-- Channels Categories View -->
            <div class="live-categories" id="liveChannelsCategories" style="display: none;">
                <button class="live-back-btn" onclick="showLiveMainOptions()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                </button>
                <div class="live-category-grid">
                    <button class="live-category-btn" onclick="loadChannelCategory('favourites')" title="Favourites"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('all')" title="All Channels"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('canada')" title="Canada"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('germany')" title="Germany"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('lebanon')" title="Lebanon"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('saudi')" title="Saudi Arabia"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('uae')" title="UAE"></button>
                    <button class="live-category-btn" onclick="loadChannelCategory('usa')" title="USA"></button>
                </div>
            </div>

            <!-- Sports Categories View -->
            <div class="live-categories" id="liveSportsCategories" style="display: none;">
                <button class="live-back-btn" onclick="showLiveMainOptions()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 12H5M12 19l-7-7 7-7"/>
                    </svg>
                </button>
                <div class="live-category-grid sports-grid">
                    <button class="live-category-btn" onclick="loadSportsCategory('football')" title="Football">
                        <img src="Icons/LiveIcons/soccer.png" alt="Football" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('basketball')" title="Basketball">
                        <img src="Icons/LiveIcons/basketball.png" alt="Basketball" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('american-football')" title="American Football">
                        <img src="Icons/LiveIcons/american-football.png" alt="American Football" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('hockey')" title="Hockey">
                        <img src="Icons/LiveIcons/ice-hockey.png" alt="Hockey" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('baseball')" title="Baseball">
                        <img src="Icons/LiveIcons/baseball-player.png" alt="Baseball" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('motor-sports')" title="Motor Sports">
                        <img src="Icons/LiveIcons/f1.png" alt="Motor Sports" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('fight')" title="Fight">
                        <img src="Icons/LiveIcons/wrestling.png" alt="Fight" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('tennis')" title="Tennis">
                        <img src="Icons/LiveIcons/smash.png" alt="Tennis" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('rugby')" title="Rugby">
                        <img src="Icons/LiveIcons/rugby.png" alt="Rugby" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('golf')" title="Golf">
                        <img src="Icons/LiveIcons/golf-player.png" alt="Golf" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('cricket')" title="Cricket">
                        <img src="Icons/LiveIcons/cricket.png" alt="Cricket" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('darts')" title="Darts">
                        <img src="Icons/LiveIcons/dart.png" alt="Darts" style="width: 56px; height: 56px;">
                    </button>
                    <button class="live-category-btn" onclick="loadSportsCategory('other')" title="Other">
                        <img src="Icons/LiveIcons/other.png" alt="Other" style="width: 56px; height: 56px;">
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Power LED Indicator (Phosphor Theme Only) -->
    <div id="crtPowerLed" class="crt-power-led"></div>


    <div id="shaderBackground"></div>
    <div id="bgAnimation"></div>

    <!-- User Menu Dropdown -->
    <div class="user-menu-container">
        <!-- Friend Request Notification Icon - beside user menu -->
        <div id="friendRequestNotification" class="friend-request-notification-left" onclick="showFriendsModal()">
            <img src="/Icons/friend-request.png" alt="Friend Requests">
            <span id="friendRequestBadge" class="request-count-badge">0</span>
        </div>
        <button class="user-menu-btn" id="userMenuBtn" onclick="toggleUserMenu()">
            <img id="userMenuIcon" src="Icons/user.png" alt="User" style="width: 30px; height: 30px;">
            <span id="userMenuText" style="display: none;"></span>
        </button>
        <div class="user-menu-dropdown" id="userMenuDropdown">
            <button class="user-menu-item" onclick="showLoginModal(); closeUserMenu();">
                <span style="font-size: 28px; margin-right: 10px;"></span> Login
            </button>
            <button class="user-menu-item" onclick="showRegisterModal(); closeUserMenu();">
                <span style="font-size: 28px; margin-right: 10px;"></span> Sign Up
            </button>
        </div>
    </div>

    <!-- Theme Selector Button -->
    <!-- Top-right Control Button -->
    <div style="position: absolute; top: 20px; right: 20px; z-index: 100001;">
        <button class="bg-animation-toggle" onclick="toggleWatchpartyPanel()"> Party</button>
    </div>


    <!-- Theme Selector Panel -->
    <div id="themeSelectorPanel" class="theme-selector-panel" style="bottom: 70px;">
        <div class="theme-selector-title">
            <span style="width: 24px;"></span>
            <span class="title-text">SELECT THEME</span>
            <button class="panel-close-btn" onclick="document.getElementById('themeSelectorPanel').classList.remove('active')"></button>
        </div>
        <div class="theme-options-container"></div>
    </div>

    <!-- Watchparty Panel -->
    <div id="watchpartyPanel" class="bg-effects-panel sync-chamber" style="top: 70px;">
        <div class="sync-chamber-header">
            <div class="sync-chamber-title">
                <div class="sync-icon"></div>
                SYNC CHAMBER
            </div>
            <button class="friends-terminal-close" onclick="document.getElementById('watchpartyPanel').classList.remove('active')"></button>
        </div>

        <div class="sync-chamber-body">
            <div class="sync-description">
                 Synchronize viewing sessions with friends in real-time
            </div>

            <div class="sync-input-group">
                <label class="sync-input-label">Identity Code</label>
                <input type="text" id="usernameInput" class="sync-input" placeholder="Enter your display name...">
            </div>

            <div class="sync-action-cards">
                <div class="sync-action-card primary" onclick="createWatchparty()">
                    <span class="sync-action-icon"></span>
                    <span class="sync-action-label">Create</span>
                </div>
                <div class="sync-action-card" onclick="document.getElementById('joinRoomCodeInput').focus()">
                    <span class="sync-action-icon"></span>
                    <span class="sync-action-label">Join</span>
                </div>
            </div>

            <div class="sync-divider">
                <div class="sync-divider-line"></div>
                <span class="sync-divider-text">FREQUENCY</span>
                <div class="sync-divider-line"></div>
            </div>

            <div class="sync-input-group">
                <label class="sync-input-label">Room Frequency</label>
                <input type="text" id="joinRoomCodeInput" class="sync-input" placeholder="Enter room code..." style="text-align: center; text-transform: uppercase; letter-spacing: 4px;">
            </div>

            <div class="sync-action-card" onclick="joinWatchparty()" style="margin-top: 16px;">
                <span class="sync-action-label"> Connect to Frequency </span>
            </div>
        </div>
    </div>

    <!-- Background Effects Panel -->
    <div id="bgEffectsPanel" class="bg-effects-panel" style="bottom: 70px;">
        <div class="bg-effects-title">
            <span style="width: 24px;"></span>
            <span class="title-text">BG EFFECTS</span>
            <button class="panel-close-btn" onclick="document.getElementById('bgEffectsPanel').classList.remove('active')"></button>
        </div>
        <div class="effect-option" data-effect="matrix" onclick="toggleEffect('matrix')">
            <span class="effect-name">Matrix Rain</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effect-option" data-effect="stars" onclick="toggleEffect('stars')">
            <span class="effect-name">Pixel Stars</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effect-option" data-effect="particles" onclick="toggleEffect('particles')">
            <span class="effect-name">Particles</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effect-option" data-effect="scanline" onclick="toggleEffect('scanline')">
            <span class="effect-name">Scanline</span>
            <div class="effect-toggle"></div>
        </div>
        <div class="effects-actions">
            <button class="effects-btn" onclick="enableAllEffects()">All ON</button>
            <button class="effects-btn" onclick="disableAllEffects()">All OFF</button>
        </div>
    </div>

    <div class="container">
        <!-- New Hero Header Section -->
        <div class="hero-header">
            <div class="hero-title-section">
                <h1 class="hero-title" onclick="location.reload()" style="cursor: pointer;">GlitchBox</h1>
                <p class="hero-subtitle">your one stop streaming shop</p>
            </div>
        </div>

        <!-- Movies and TV Shows buttons with radial menus (separate for flex ordering) -->
        <div class="hero-nav-section">
            <div class="hero-nav-buttons">
                <div class="radial-menu-container">
                    <button class="hero-nav-btn hero-nav-movies" id="moviesRadialBtn" onclick="toggleRadialMenu('movies')">
                        <img src="Icons/movie.png" alt="Movies" class="hero-nav-icon">
                        <span class="hero-nav-label">Movies</span>
                    </button>
                    <div class="radial-menu" id="moviesRadialMenu">
                        <div class="radial-option" onclick="selectMovieFilter('popular')">
                            <img src="Icons/popular.png" alt="Popular" class="radial-option-icon">
                            <span class="radial-option-label">Popular</span>
                        </div>
                        <div class="radial-option" onclick="selectMovieFilter('trending')">
                            <img src="Icons/trending.png" alt="Trending" class="radial-option-icon">
                            <span class="radial-option-label">Trending</span>
                        </div>
                        <div class="radial-option" onclick="selectMovieFilter('upcoming')">
                            <img src="Icons/upcoming.png" alt="Upcoming" class="radial-option-icon">
                            <span class="radial-option-label">Upcoming</span>
                        </div>
                    </div>
                </div>

                <div class="hero-center-spacer"></div>

                <div class="radial-menu-container">
                    <button class="hero-nav-btn hero-nav-shows" id="tvShowsRadialBtn" onclick="toggleRadialMenu('tv-shows')">
                        <img src="Icons/tv-show.png" alt="Shows" class="hero-nav-icon">
                        <span class="hero-nav-label">Shows</span>
                    </button>
                    <div class="radial-menu tv-menu" id="tvShowsRadialMenu">
                        <div class="radial-option" onclick="selectTvFilter('popular')">
                            <img src="Icons/popular.png" alt="Popular" class="radial-option-icon">
                            <span class="radial-option-label">Popular</span>
                        </div>
                        <div class="radial-option" onclick="selectTvFilter('trending')">
                            <img src="Icons/trending.png" alt="Trending" class="radial-option-icon">
                            <span class="radial-option-label">Trending</span>
                        </div>
                        <div class="radial-option" onclick="selectTvFilter('now-playing')">
                            <img src="Icons/live-now.png" alt="On Air" class="radial-option-icon">
                            <span class="radial-option-label">On Air</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Radial menu backdrop -->
            <div class="radial-backdrop" id="radialBackdrop" onclick="closeAllRadialMenus()"></div>
        </div>

        <!-- Old elements hidden -->
        <div class="header" style="display: none;">
            <div id="authButtons" style="display: none;">
                <button class="btn" onclick="showLoginModal()" style="padding: 10px 20px;">Login</button>
                <button class="btn" onclick="showRegisterModal()" style="padding: 10px 20px;">Sign Up</button>
            </div>
            <div id="userMenu" style="display: none;">
                <span id="usernameDisplay" style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 20px;"></span>
                <button class="btn" onclick="showFriendsModal()" style="padding: 10px 20px; display: flex; align-items: center; gap: 8px;">
                    <img src="${BASE64_IMAGES.FRIENDS_ICON}" alt="Friends" style="width: 20px; height: 20px; image-rendering: pixelated;">
                    <span>Friends</span>
                    <span id="friendRequestCount" style="display: none; color: var(--secondary-color); font-weight: bold;"></span>
                </button>
                <button class="btn" onclick="logout()" style="padding: 10px 20px;">Logout</button>
            </div>
        </div>

        <!-- Search section hidden - using floating search instead -->
        <div class="search-section" style="display: none;">
            <div class="search-box">
                <div class="search-container">
                    <input type="text" id="searchInput" class="search-input"
                           placeholder="Search movies & TV shows..."
                           autocomplete="off">
                    <div id="searchAutocomplete" class="search-autocomplete"></div>
                </div>
                <button onclick="searchContent()" class="btn" id="searchBtn">Search</button>
            </div>

            <div id="statusBar" class="status-bar" style="display: none;"></div>
            <div id="errorMessage" class="error" style="display: none;"></div>
        </div>

        <img id="currentPoster" class="standalone-poster" alt="Poster" style="display: none;">
        <div class="player-section" id="playerSection" style="display: none;">
            <button class="player-close-btn" onclick="stopPlayback()" title="Close player">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </button>
            <button id="playerWatchlistBtn" class="player-heart-btn" onclick="togglePlayerWatchlist()" style="display: none;" title="Add to Watchlist">
                <img id="playerWatchlistIcon" src="Icons/heart-nofill.png" alt="Watchlist">
            </button>
            <div id="currentContent" class="current-content" style="display: none;">
                <div id="backdropImage" class="backdrop-image"></div>
                <div id="playerBgAnimation" class="player-bg-animation"></div>
                <div class="current-content-info">
                    <h3 id="currentTitle">Title</h3>
                    <p id="currentYear">Year</p>

                    <!-- OMDB Ratings -->
                    <div id="omdbRatings" class="omdb-ratings" style="display: none;">
                        <div class="ratings-container">
                            <div class="rating-item">
                                <span class="rating-source">IMDb</span>
                                <span class="rating-value" id="imdbRating">N/A</span>
                            </div>
                            <div class="rating-item">
                                <span class="rating-source">Rotten Tomatoes</span>
                                <span class="rating-value" id="rtRating">N/A</span>
                            </div>
                            <div class="rating-item">
                                <span class="rating-source">Metacritic</span>
                                <span class="rating-value" id="metacriticRating">N/A</span>
                            </div>
                        </div>
                    </div>

                    <p id="currentOverview">Overview...</p>
                </div>
            </div>

            <!-- OMDB Details (outside grid for full-width centering) -->
            <div id="omdbDetails" class="omdb-details" style="display: none;">
                <div id="castSection" class="cast-section" style="display: none;">
                    <h3 style="color: var(--primary-color); font-family: 'VT323', monospace; font-size: 28px; margin-bottom: 12px;">Cast</h3>
                    <div id="castGrid" class="cast-grid"></div>
                </div>
                <p id="omdbActors" class="detail-item" style="display: none;"><strong>Cast:</strong> <span></span></p>
                <p id="omdbDirector" class="detail-item"><strong>Director:</strong> <span></span></p>
                <p id="omdbGenre" class="detail-item"><strong>Genre:</strong> <span></span></p>
                <p id="omdbRated" class="detail-item"><strong>Rating:</strong> <span></span></p>
                <p id="omdbRuntime" class="detail-item"><strong>Runtime:</strong> <span></span></p>
                <p id="omdbAwards" class="detail-item awards"><strong>Awards:</strong> <span></span></p>
            </div>

            <!-- Episode Selection and Description Container (outside grid for full-width centering) -->
            <div id="tvControls" class="tv-controls" style="display: none;">
                <button id="seasonButton" class="bg-animation-toggle" onclick="toggleSeasonPanel()" style="margin-right: 12px;">
                    <span id="seasonButtonText">Season 1</span>
                </button>
                <button id="episodeButton" class="bg-animation-toggle" onclick="toggleEpisodePanel()" style="min-width: 400px; text-align: center;">
                    <span id="episodeButtonText">Episode 1</span>
                </button>

                <!-- Episode Description -->
                <div id="episodeDescription" class="episode-description" style="display: none;">
                    <p id="episodeDescriptionText"></p>
                </div>
            </div>

            <div class="player-container">
                <div id="playerPlaceholder" class="player-placeholder">
                    <div>
                        <h3>Select content to start watching</h3>
                        <p>Search for movies or TV shows above, or browse popular content</p>
                    </div>
                </div>
                <iframe id="contentPlayer" src="about:blank" allowfullscreen webkitallowfullscreen mozallowfullscreen allow="autoplay; fullscreen" style="display: none;"></iframe>
                <video id="playerVideo" controls style="display: none; width: 100%; height: 100%; max-width: 100%; background: #000; object-fit: contain;"></video>
            </div>

            <div class="player-controls">
                <!-- Left group: Next Episode + Comments -->
                <div class="player-controls-left">
                    <button onclick="playNextEpisode()" class="btn player-icon-btn" id="nextEpisodeBtn" style="display: none;" title="Next Episode"><img src="Icons/next-episode.png" alt="Next Episode" class="player-control-icon"></button>
                    <button onclick="toggleComments()" class="btn btn-secondary player-icon-btn" id="commentsBtn" style="display: none;" title="Comments"><img src="Icons/comments.png" alt="Comments" class="player-control-icon"></button>
                </div>

                <!-- Center group: Source + Copy URL -->
                <div class="player-controls-center">
                    <button id="sportsSourceBtn" class="btn btn-secondary" onclick="switchSportsSource()" style="display: none;">
                        <span id="sportsSourceBtnText">Source 1</span>
                    </button>
                    <!-- Source Dropdown Menu -->
                    <div class="source-menu-container" id="sourceMenuContainer" style="display: none;">
                        <button class="source-menu-btn" id="videoSourceBtn" onclick="toggleSourceMenu()">
                            <span id="videoSourceBtnText">Source: VidSrc</span>
                        </button>
                        <div class="source-menu-dropdown" id="sourceMenuDropdown">
                            <button class="source-menu-item" onclick="selectVideoSource('vidsrc'); closeSourceMenu();">
                                <span>VidSrc</span>
                                <span class="source-check" id="vidsrc-check"></span>
                            </button>
                            <button class="source-menu-item" onclick="selectVideoSource('vidking'); closeSourceMenu();">
                                <span>VidKing</span>
                                <span class="source-check" id="vidking-check" style="display: none;"></span>
                            </button>
                            <button class="source-menu-item" onclick="selectVideoSource('superembed'); closeSourceMenu();">
                                <span>SuperEmbed</span>
                                <span class="source-check" id="superembed-check" style="display: none;"></span>
                            </button>
                            <button class="source-menu-item" onclick="selectVideoSource('moviesapi'); closeSourceMenu();">
                                <span>MoviesAPI</span>
                                <span class="source-check" id="moviesapi-check" style="display: none;"></span>
                            </button>
                        </div>

                        <!-- Tooltip beside source button -->
                        <div class="source-tooltip-hint" id="sourceTooltipHint">
                            <div class="source-tooltip-arrow-left"></div>
                            <div class="source-tooltip-box">
                                <button class="source-tooltip-close" onclick="dismissSourceHint()"></button>
                                Change source if stuck or not loading
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right group: Fullscreen + Stop -->
                <div class="player-controls-right">
                    <button onclick="toggleFullscreen()" class="btn btn-secondary player-icon-btn" title="Fullscreen"><img src="Icons/fullscreen.png" alt="Fullscreen" class="player-control-icon"></button>
                    <button onclick="stopPlayback()" class="btn btn-secondary player-icon-btn" id="stopBtn" style="display: none;" title="Stop"><img src="Icons/stop-sign.png" alt="Stop" class="player-control-icon"></button>
                </div>
            </div>

            <!-- Old Watchparty Menu Modal (Hidden - Using Panel Instead) -->
            <div id="watchpartyMenuModal" style="display: none !important; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 99999; align-items: center; justify-content: center; padding: 20px;" onclick="closeWatchpartyMenu()">
                <div style="max-width: 450px; width: 90%; background: #0f0f1e; border: 4px solid #ff00ff; padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px rgba(255, 0, 255, 0.5), inset 0 0 20px rgba(255, 0, 255, 0.1);" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="margin: 0; font-family: 'Press Start 2P', cursive; color: #ff00ff; font-size: 18px; font-weight: 400; text-shadow: 2px 2px 0 #00d9ff;">Watchparty</h2>
                        <button onclick="closeWatchpartyMenu()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>

                    <div style="margin-bottom: 24px;">
                        <p style="font-family: 'VT323', monospace; color: #00d9ff; font-size: 20px; margin-bottom: 20px;">Watch together with friends! Host controls playback and everyone can chat.</p>

                        <div style="margin-bottom: 20px;">
                            <label style="font-family: 'VT323', monospace; color: #00ff9f; font-size: 20px; display: block; margin-bottom: 8px;">Display Name</label>
                            <input type="text" id="usernameInput" placeholder="Enter your name..."
                                   style="font-family: 'VT323', monospace; width: 100%; padding: 16px; background: #1a1a2e; border: 3px solid #ff00ff; color: #00ff9f; font-size: 22px; box-shadow: inset 2px 2px 0 rgba(0, 0, 0, 0.3);">
                        </div>

                        <button onclick="createWatchparty()" class="btn" style="width: 100%; margin-bottom: 12px; padding: 16px;">
                            Create Watchparty
                        </button>

                        <div style="font-family: 'VT323', monospace; text-align: center; color: #888; margin: 16px 0; font-size: 20px;">OR</div>

                        <input type="text" id="joinRoomCodeInput" placeholder="Enter Room Code (e.g., ABC123)"
                               style="font-family: 'VT323', monospace; width: 100%; padding: 16px; background: #1a1a2e; border: 3px solid #00d9ff; color: #00ff9f; font-size: 22px; margin-bottom: 12px; text-align: center; text-transform: uppercase; letter-spacing: 3px; font-weight: 600; box-shadow: inset 2px 2px 0 rgba(0, 0, 0, 0.3);">

                        <button onclick="joinWatchparty()" class="btn btn-secondary" style="width: 100%; padding: 16px;">
                            Join Watchparty
                        </button>
                    </div>
                </div>
            </div>

            <!-- Sync Indicator -->
            <div id="syncIndicator" class="sync-indicator"></div>

            <!-- Comments Section -->
            <div id="commentsSection" class="transmission-log" style="display: none;">
                <div class="transmission-header">
                    <div class="transmission-icon"></div>
                    <span class="transmission-title">Transmission Log</span>
                    <div class="transmission-status">LIVE</div>
                </div>

                <div id="commentsList" class="transmission-body">
                    <!-- Comments will be loaded here with new styling -->
                </div>

                <div id="addCommentSection" class="transmission-input-section">
                    <div class="transmission-input-wrapper">
                        <span class="transmission-input-label">Broadcast</span>
                        <textarea id="commentTextarea" class="transmission-textarea" placeholder="Transmit your message..."
                                  maxlength="500"
                                  rows="1"
                                  oninput="autoResizeTextarea(this); updateCharCount();"></textarea>
                    </div>
                    <div class="transmission-input-footer">
                        <span id="commentCharCount" class="transmission-char-count">0/500</span>
                        <button onclick="submitComment()" class="transmission-submit-btn"> Transmit</button>
                    </div>
                </div>
            </div>

            <!-- Watchlist Modal -->
            <div id="watchlistModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 2147483647; align-items: center; justify-content: center; padding: 20px;" onclick="closeWatchlistModal()">
                <div style="max-width: 600px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 id="watchlistModalTitle" style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> ADD TO WATCHLIST</h2>
                        <button onclick="closeWatchlistModal()" class="btn btn-secondary" style="padding: 12px 24px;"> Close</button>
                    </div>
                    <div id="watchlistModalContent">
                        <!-- Content for manage lists will be loaded here -->
                    </div>
                    <div id="watchlistPanelContent" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Watchlist options will be loaded dynamically -->
                    </div>
                    <div id="watchlistCreateSection" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid var(--primary-color, #00ff9f);">
                        <div style="font-family: 'VT323', monospace; font-size: 24px; margin-bottom: 12px; color: var(--primary-color, #00ff9f); text-align: center; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));">CREATE NEW WATCHLIST</div>
                        <input type="text" id="newWatchlistName" placeholder="Enter watchlist name..."
                               style="font-family: 'VT323', monospace; width: 100%; padding: 12px; background: var(--bg-dark, #0f0f1e); border: 2px solid var(--primary-color, #00ff9f); color: var(--primary-color, #00ff9f); font-size: 18px; margin-bottom: 12px;">
                        <button onclick="createNewWatchlist()" class="effects-btn" style="width: 100%; padding: 12px;">Create Watchlist</button>
                    </div>
                </div>
            </div>

            <!-- Video Source Selector Modal -->
            <div id="sourceSelectorModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 10000; align-items: center; justify-content: center; padding: 20px;" onclick="closeSourceSelector()">
                <div style="max-width: 500px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> SELECT SOURCE</h2>
                        <button onclick="closeSourceSelector()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>

                    <p style="font-family: 'VT323', monospace; color: #00d9ff; font-size: 20px; margin-bottom: 24px; line-height: 1.4;">
                        Choose a streaming source. Different sources may have better quality or reliability.
                    </p>

                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="selectVideoSource('vidsrc')" class="btn" style="width: 100%; padding: 16px; text-align: left; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 18px;"> VidSrc</span>
                            <span id="vidsrc-check" style="color: #00ff9f; display: none;"></span>
                        </button>
                        <button onclick="selectVideoSource('vidking')" class="btn" style="width: 100%; padding: 16px; text-align: left; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 18px;"> VidKing</span>
                            <span id="vidking-check" style="color: #00ff9f; display: none;"></span>
                        </button>
                        <button onclick="selectVideoSource('superembed')" class="btn" style="width: 100%; padding: 16px; text-align: left; display: flex; align-items: center; justify-content: space-between;">
                            <span style="font-size: 18px;"> SuperEmbed</span>
                            <span id="superembed-check" style="color: #00ff9f; display: none;"></span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Subtitle Selection Modal -->
            <div id="subtitleModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; padding: 40px; overflow-y: auto;">
                <div style="max-width: 800px; margin: 0 auto; background: #0f0f1e; border: 4px solid #00d9ff; padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px rgba(0, 217, 255, 0.5), inset 0 0 20px rgba(0, 217, 255, 0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 class="section-title" style="margin: 0;">Select Subtitles</h2>
                        <button onclick="closeSubtitleModal()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="color: #a1a1a6; display: block; margin-bottom: 8px;">Language:</label>
                        <select id="subtitleLanguage" class="year-input" style="width: 200px;" onchange="loadSubtitles()">
                            <option value="eng">English</option>
                            <option value="spa">Spanish</option>
                            <option value="fre">French</option>
                            <option value="ger">German</option>
                            <option value="ita">Italian</option>
                            <option value="por">Portuguese</option>
                            <option value="ara">Arabic</option>
                            <option value="chi">Chinese</option>
                            <option value="jpn">Japanese</option>
                            <option value="kor">Korean</option>
                            <option value="rus">Russian</option>
                            <option value="hin">Hindi</option>
                        </select>
                    </div>

                    <!-- Info Box -->
                    <div style="background: rgba(0, 122, 255, 0.1); border: 1px solid rgba(0, 122, 255, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <div style="font-size: 24px;"></div>
                            <div style="flex: 1;">
                                <div style="color: #007AFF; font-weight: 600; margin-bottom: 4px;">How Subtitles Work</div>
                                <div style="color: #a1a1a6; font-size: 13px;">
                                    Click "Open Search" to find subtitles, then download and paste the URL below. The subtitle will be converted to VTT format and ready to download or use with external players.
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="subtitleList" style="max-height: 400px; overflow-y: auto;">
                        <div style="text-align: center; color: #666; padding: 40px;">
                            Loading subtitles...
                        </div>
                    </div>

                    <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                        <label style="color: #a1a1a6; display: block; margin-bottom: 8px;">Or paste subtitle URL (SRT/VTT):</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="customSubtitleUrl" class="search-input" placeholder="https://example.com/subtitle.srt" style="flex: 1;">
                            <button onclick="loadCustomSubtitle()" class="btn">Load</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Login Modal -->
        <div id="loginModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; padding: 20px;">
            <div style="max-width: 450px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5));" onclick="event.stopPropagation()">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-family: 'Press Start 2P', cursive; font-size: 18px; color: var(--primary-color, #00ff9f); margin: 0;">Login</h2>
                    <button onclick="closeLoginModal()" style="background: none; border: none; color: #ff00ff; font-size: 40px; cursor: pointer; padding: 8px 16px; line-height: 1; transition: color 0.2s;"></button>
                </div>
                <div id="loginError" style="display: none; color: #ff6b6b; margin-bottom: 16px; padding: 12px; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 4px;"></div>
                <form id="loginForm" onsubmit="handleLogin(event)">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Username</label>
                        <input type="text" id="loginUsername" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Password</label>
                        <input type="password" id="loginPassword" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <button type="submit" class="btn" style="width: 100%; padding: 14px; font-size: 16px;">Login</button>
                    <div style="text-align: center; margin-top: 16px; color: #a1a1a6;">
                        Don't have an account? <a href="#" onclick="event.preventDefault(); closeLoginModal(); showRegisterModal();" style="color: var(--primary-color); text-decoration: none;">Sign up</a>
                    </div>
                </form>
            </div>
        </div>

        <!-- Register Modal -->
        <div id="registerModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; padding: 20px;">
            <div style="max-width: 450px; width: 90%; background: #0f0f1e; border: 4px solid var(--secondary-color, #ff00ff); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--secondary-glow, rgba(255, 0, 255, 0.5));" onclick="event.stopPropagation()">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-family: 'Press Start 2P', cursive; font-size: 18px; color: var(--secondary-color, #ff00ff); margin: 0;">Sign Up</h2>
                    <button onclick="closeRegisterModal()" style="background: none; border: none; color: #ff00ff; font-size: 40px; cursor: pointer; padding: 8px 16px; line-height: 1; transition: color 0.2s;"></button>
                </div>
                <div id="registerError" style="display: none; color: #ff6b6b; margin-bottom: 16px; padding: 12px; background: rgba(255, 107, 107, 0.1); border: 1px solid #ff6b6b; border-radius: 4px;"></div>
                <form id="registerForm" onsubmit="handleRegister(event)">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Username</label>
                        <input type="text" id="registerUsername" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Email</label>
                        <input type="email" id="registerEmail" class="search-input" required style="width: 100%; padding: 12px;">
                    </div>
                    <div style="margin-bottom: 24px;">
                        <label style="display: block; color: #a1a1a6; margin-bottom: 8px; font-family: 'VT323', monospace; font-size: 18px;">Password</label>
                        <input type="password" id="registerPassword" class="search-input" required minlength="6" style="width: 100%; padding: 12px;">
                    </div>
                    <button type="submit" class="btn" style="width: 100%; padding: 14px; font-size: 16px;">Create Account</button>
                    <div style="text-align: center; margin-top: 16px; color: #a1a1a6;">
                        Already have an account? <a href="#" onclick="event.preventDefault(); closeRegisterModal(); showLoginModal();" style="color: var(--secondary-color); text-decoration: none;">Login</a>
                    </div>
                </form>
            </div>
        </div>

        <!-- Create New List Modal -->
        <div id="createListModalOverlay" class="create-list-modal-overlay" onclick="closeCreateListModal()">
            <div class="create-list-modal" onclick="event.stopPropagation()">
                <div class="create-list-header">
                    <div class="create-list-title">Create New List</div>
                    <button class="create-list-close" onclick="closeCreateListModal()"></button>
                </div>
                <div class="create-list-body">
                    <p class="create-list-description">
                         Give your new collection a unique name
                    </p>
                    <div class="create-list-input-group">
                        <span class="create-list-input-label">List Name</span>
                        <input type="text" id="createListNameInput" class="create-list-input" placeholder="Enter list name..." maxlength="50" autocomplete="off">
                    </div>
                    <div id="createListError" class="create-list-error">
                        A list with this name already exists
                    </div>
                    <div class="create-list-actions">
                        <button class="create-list-btn secondary" onclick="closeCreateListModal()">Cancel</button>
                        <button class="create-list-btn primary" onclick="confirmCreateList()"> Create List</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Delete List Confirmation Modal -->
        <div id="deleteListModalOverlay" class="delete-list-modal-overlay" onclick="closeDeleteListModal()">
            <div class="delete-list-modal" onclick="event.stopPropagation()">
                <div class="delete-list-modal-header">
                    <svg class="delete-list-modal-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14zM10 11v6M14 11v6"/>
                    </svg>
                    <span class="delete-list-modal-title">Delete List</span>
                </div>
                <div class="delete-list-modal-body">
                    <p class="delete-list-modal-text">Are you sure you want to delete this list?</p>
                    <div class="delete-list-modal-name" id="deleteListName"></div>
                    <p class="delete-list-modal-warning">This action cannot be undone.</p>
                </div>
                <div class="delete-list-modal-actions">
                    <button class="delete-list-modal-btn cancel" onclick="closeDeleteListModal()">Cancel</button>
                    <button class="delete-list-modal-btn confirm" onclick="confirmDeleteList()">Delete</button>
                </div>
            </div>
        </div>

        <!-- Rename List Modal -->
        <div id="renameListModalOverlay" class="rename-list-modal-overlay" onclick="closeRenameListModal()">
            <div class="rename-list-modal" onclick="event.stopPropagation()">
                <div class="rename-list-modal-header">
                    <svg class="rename-list-modal-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                    <span class="rename-list-modal-title">Rename List</span>
                </div>
                <div class="rename-list-modal-body">
                    <p class="rename-list-modal-text">Enter a new name for this list:</p>
                    <input type="text" id="renameListInput" class="rename-list-modal-input" placeholder="New list name..." maxlength="50" autocomplete="off">
                    <div id="renameListError" class="rename-list-modal-error"></div>
                </div>
                <div class="rename-list-modal-actions">
                    <button class="rename-list-modal-btn cancel" onclick="closeRenameListModal()">Cancel</button>
                    <button class="rename-list-modal-btn confirm" onclick="confirmRenameList()">Rename</button>
                </div>
            </div>
        </div>

        <!-- Friends Modal - NETWORK TERMINAL -->
        <div id="friendsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; padding: 20px; overflow-y: auto; backdrop-filter: blur(10px);">
            <div class="friends-terminal">
                <div class="friends-terminal-header">
                    <div class="friends-terminal-title">
                        NETWORK TERMINAL
                    </div>
                    <button class="friends-terminal-close" onclick="closeFriendsModal()"></button>
                </div>

                <div class="friends-terminal-body">
                    <!-- Friend Requests Section -->
                    <div class="friends-section" id="friendRequestsSection">
                        <div class="friends-section-header">
                            <div class="friends-section-icon"></div>
                            <span class="friends-section-title">Incoming Requests</span>
                        </div>
                        <div id="friendRequestsList">
                            <!-- Friend requests will be populated here -->
                        </div>
                    </div>

                    <!-- Add Friend Section -->
                    <div class="friends-section">
                        <div class="friends-section-header">
                            <div class="friends-section-icon" style="background: linear-gradient(135deg, #ff00ff, #00d9ff);"></div>
                            <span class="friends-section-title">Scan for Users</span>
                        </div>
                        <div class="friends-search-wrapper">
                            <span class="friends-search-label">Username Query</span>
                            <span class="friends-search-icon"></span>
                            <input type="text" id="friendSearchInput" class="friends-search-input" placeholder="Enter username to scan..." oninput="searchFriends()">
                        </div>
                        <div id="friendSearchResults"></div>
                    </div>

                    <!-- My Friends Section -->
                    <div class="friends-section">
                        <div class="friends-section-header">
                            <div class="friends-section-icon" style="background: linear-gradient(135deg, #00ff9f, #00d9ff);"></div>
                            <span class="friends-section-title">Connected Users</span>
                        </div>
                        <div id="friendsList">
                            <!-- Friends will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="popular-section">
            <!-- Continue Watching Header -->
            <div class="section-header-bar" id="continueWatchingBar" onclick="toggleContinueWatching()" style="cursor: pointer;">
                <h2 class="section-title">Continue Watching</h2>
            </div>

            <!-- Hidden tabs for functionality (Movies/TV Shows now in hero) -->
            <div class="tabs" style="display: none;">
                <button class="tab active" onclick="showTab('continue-watching')" id="continueWatchingTab">Continue Watching</button>
                <button class="tab" onclick="showTab('statistics')" id="statisticsTab">Stats</button>
                <button class="tab" onclick="showTab('movies')" id="moviesTab">Movies</button>
                <button class="tab" onclick="showTab('tv-shows')" id="tvShowsTab">TV Shows</button>
            </div>

            <!-- Content Type Filters (shown for Movies/TV Shows tabs) -->
            <div id="contentTypeFilters">
                <button class="filter-chip" onclick="toggleGenreModal()" id="genreFilterBtn">
                    <img src="Icons/genre.png" alt="Genre" class="filter-chip-icon-img">
                    <span class="filter-chip-text">Genre</span>
                </button>
                <button class="filter-chip" onclick="toggleLanguageModal()" id="languageFilterBtn">
                    <img src="Icons/language.png" alt="Language" class="filter-chip-icon-img">
                    <span class="filter-chip-text">Language</span>
                </button>
            </div>

            <!-- Active Filters Display -->
            <div id="activeFiltersDisplay" style="display: none; margin-top: 12px; text-align: center; font-family: 'VT323', monospace; font-size: 18px;">
                <span id="activeGenreDisplay" style="display: none; color: var(--primary-color, #00ff9f); text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5)); margin-right: 16px;">
                    GENRE: <span id="genreName" style="color: var(--accent-color, #00d9ff);"></span>
                    <button onclick="clearGenreFilter()" style="background: none; border: none; color: var(--secondary-color, #ff00ff); cursor: pointer; font-family: 'VT323', monospace; font-size: 18px; margin-left: 4px;"></button>
                </span>
                <span id="activeLanguageDisplay" style="display: none; color: var(--primary-color, #00ff9f); text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));">
                    LANGUAGE: <span id="languageName" style="color: var(--accent-color, #00d9ff);"></span>
                    <button onclick="clearLanguageFilter()" style="background: none; border: none; color: var(--secondary-color, #ff00ff); cursor: pointer; font-family: 'VT323', monospace; font-size: 18px; margin-left: 4px;"></button>
                </span>
            </div>

            <!-- Genre Filter Button (legacy - now integrated into contentTypeFilters) -->
            <div id="genreFilterContainer" style="display: none; margin-top: 16px; text-align: center;">
                <button class="bg-animation-toggle" onclick="toggleGenreModal()">
                     Filter by Genre
                </button>
            </div>

            <!-- Genre Modal Popup -->
            <div id="genreModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 2147483647; align-items: center; justify-content: center; padding: 20px;" onclick="closeGenreModal()">
                <div style="max-width: 600px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> SELECT GENRE</h2>
                        <button onclick="closeGenreModal()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>
                    <div id="genreList" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Genres will be loaded dynamically -->
                    </div>
                </div>
            </div>

            <!-- Language Modal Popup -->
            <div id="languageModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.90); z-index: 2147483647; align-items: center; justify-content: center; padding: 20px;" onclick="closeLanguageModal()">
                <div style="max-width: 500px; width: 90%; background: #0f0f1e; border: 4px solid var(--primary-color, #00ff9f); padding: 32px; box-shadow: 0 0 0 4px #1a1a2e, 0 0 30px var(--primary-glow, rgba(0, 255, 159, 0.5)), inset 0 0 20px var(--primary-glow, rgba(0, 255, 159, 0.1)); max-height: 80vh; overflow-y: auto;" onclick="event.stopPropagation()">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                        <h2 style="font-family: 'VT323', monospace; font-size: 32px; color: var(--primary-color, #00ff9f); margin: 0; text-shadow: 0 0 10px var(--primary-glow, rgba(0, 255, 159, 0.5));"> SELECT LANGUAGE</h2>
                        <button onclick="closeLanguageModal()" class="btn btn-secondary" style="padding: 8px 16px;"> Close</button>
                    </div>
                    <div id="languageList" style="display: flex; flex-direction: column; gap: 8px;">
                        <button class="btn btn-primary" onclick="filterByLanguage(null)" style="width: 100%; padding: 12px; text-align: left;">All Languages</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('en')" style="width: 100%; padding: 12px; text-align: left;">English</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('ar')" style="width: 100%; padding: 12px; text-align: left;">Arabic</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('ko')" style="width: 100%; padding: 12px; text-align: left;">Korean</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('ja')" style="width: 100%; padding: 12px; text-align: left;">Japanese</button>
                        <button class="btn btn-primary" onclick="filterByLanguage('zh')" style="width: 100%; padding: 12px; text-align: left;">Chinese</button>
                    </div>
                </div>
            </div>

            <!-- Season Panel -->
            <div id="seasonPanel" class="bg-effects-panel" style="position: absolute; display: none; width: 180px; max-height: 400px; overflow-y: auto; z-index: 2147483647;">
                <div class="bg-effects-title">
                    <span style="width: 24px;"></span>
                    <span class="title-text">SELECT SEASON</span>
                    <button class="panel-close-btn" onclick="closePanelAnimated(document.getElementById('seasonPanel'))"></button>
                </div>
                <div id="seasonList" style="display: flex; flex-direction: column; gap: 6px;">
                    <!-- Seasons will be loaded dynamically -->
                </div>
            </div>

            <!-- Episode Panel -->
            <div id="episodePanel" class="bg-effects-panel" style="position: absolute; display: none; width: 400px; max-height: 400px; overflow-y: auto; z-index: 2147483647;">
                <div class="bg-effects-title">
                    <span style="width: 24px;"></span>
                    <span class="title-text">SELECT EPISODE</span>
                    <button class="panel-close-btn" onclick="closePanelAnimated(document.getElementById('episodePanel'))"></button>
                </div>
                <div id="episodeList" style="display: flex; flex-direction: column; gap: 6px;">
                    <!-- Episodes will be loaded dynamically -->
                </div>
            </div>

            <!-- Watchlist Panel (Redesigned) -->
            <div id="watchlistPanel" class="player-watchlist-panel" style="position: absolute; z-index: 2147483647;">
                <div class="player-watchlist-header">
                    <div class="player-watchlist-title-row">
                        <h2 class="player-watchlist-title" id="watchlistPanelTitle">Add to Watchlist</h2>
                        <button class="player-watchlist-close" onclick="document.getElementById('watchlistPanel').classList.remove('active'); setTimeout(() => { document.getElementById('watchlistPanel').style.display='none'; }, 250); window.pendingWatchlistPanelItem=null;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 6L6 18M6 6l12 12"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div id="watchlistPanelList" class="player-watchlist-lists">
                    <!-- Watchlists will be loaded dynamically -->
                </div>
                <div id="watchlistPanelCreate" class="player-watchlist-create">
                    <input type="text" id="newWatchlistNamePanel" class="player-watchlist-input" placeholder="New watchlist name...">
                    <button onclick="createWatchlistFromPanel()" class="player-watchlist-create-btn">+ Create New List</button>
                </div>
            </div>

        </div>

        <div id="contentResults" class="content-results"></div>
        <div id="continueWatchingDisplay" class="horizontal-scroll-container" style="display: none;"></div>
        <div id="watchlistDisplay" class="horizontal-scroll-container" style="display: none;"></div>
        <div id="statisticsDisplay" style="display: none; padding: 20px;"></div>
        <div id="loadingIndicator" class="loading" style="display: none;">
            <div>Loading content...</div>
        </div>

        <div id="sportsDisplay" style="display: none; padding: 20px;">
            <!-- Sports Search -->
            <div style="margin-bottom: 24px;">
                <div style="position: relative; display: flex; gap: 8px; align-items: center;">
                    <input type="text" id="sportsSearchInput" class="search-input"
                           placeholder="Search matches, teams, sports..."
                           autocomplete="off"
                           oninput="searchSportsMatches()"
                           onkeypress="if(event.key === 'Enter') searchSportsMatches()"
                           style="flex: 1;">
                    <button onclick="clearSportsSearch()" class="btn btn-secondary" style="padding: 12px 24px; font-size: 20px; display: none; white-space: nowrap;" id="clearSportsSearchBtn">
                        Clear
                    </button>
                </div>
            </div>

            <!-- Sports Filters -->
            <div id="sportsFilters" style="margin-bottom: 24px; display: flex; justify-content: center;">
                <button onclick="toggleLiveFilter()" id="liveSportsBtn" style="padding: 0; margin: 0; border: none; background: transparent; cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 12px; transition: box-shadow 0.3s ease, filter 0.3s ease;">
                    <img src="Icons/live-now.png" alt="Live Now" style="width: 100px; height: 100px; display: block; border-radius: 12px;">
                </button>
            </div>

            <!-- Sports Matches Grid -->
            <div id="sportsMatches" style="margin-top: 24px;"></div>
        </div>
        <div id="channelsDisplay" style="display: none; padding: 20px;">
            <!-- Channels Search -->
            <div style="margin-bottom: 24px;">
                <div style="position: relative; display: flex; gap: 8px; align-items: center;">
                    <input type="text" id="channelsSearchInput" class="search-input"
                           placeholder="Search channels..."
                           autocomplete="off"
                           oninput="searchChannels()"
                           onkeypress="if(event.key === 'Enter') searchChannels()"
                           style="flex: 1;">
                    <button onclick="clearChannelsSearch()" class="btn btn-secondary" style="padding: 12px 24px; font-size: 20px; display: none; white-space: nowrap;" id="clearChannelsSearchBtn">
                        Clear
                    </button>
                </div>
            </div>

            <!-- Channels Grid -->
            <div id="liveChannels" style="margin-top: 24px;"></div>
        </div>
    </div>

    <!-- Watchparty Sidebar (Outside Container) -->
    <div id="watchpartySidebar" class="watchparty-sidebar">
        <div class="watchparty-header">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 8px;">
                <div class="watchparty-title">
                    Watchparty
                </div>
                <div style="display: flex; align-items: center; gap: 6px; flex: 1; justify-content: center;">
                    <span class="watchparty-room-code" id="watchpartyRoomCodeLabel">Code:</span>
                    <div class="room-code-display" id="watchpartyRoomCode" onclick="copyRoomCode()" title="Click to copy">------</div>
                    <span class="sync-status-badge" id="syncStatusBadge"></span>
                </div>
                <button class="watchparty-close" onclick="event.stopPropagation(); leaveWatchparty();"></button>
            </div>

            <!-- Leave Watchparty Confirmation Popup -->
            <div id="leaveWatchpartyModal" style="display: none; position: absolute; top: 40px; right: 0; background: #0f0f1e; border: 3px solid var(--secondary-color, #ff00ff); padding: 16px; box-shadow: 0 0 0 3px #1a1a2e, 0 0 20px rgba(255, 0, 255, 0.7), inset 0 0 15px rgba(255, 0, 255, 0.1); border-radius: 8px; z-index: 100000; min-width: 200px; max-width: 250px;">
                <div style="text-align: center; margin-bottom: 12px;">
                    <h3 style="margin: 0 0 8px 0; font-family: 'Press Start 2P', cursive; color: var(--secondary-color, #ff00ff); font-size: 12px; font-weight: 400; text-shadow: 1px 1px 0 var(--accent-color, #00d9ff);">Leave Party?</h3>
                    <p style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; color: var(--accent-color, #00d9ff); font-size: 13px; line-height: 1.4; margin: 0;">
                        Exit the watchparty?
                    </p>
                </div>

                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <button onclick="event.stopPropagation(); confirmLeaveWatchparty();" class="btn" style="width: 100%; padding: 10px; background: var(--secondary-color, #ff00ff); border-color: var(--secondary-color, #ff00ff); font-size: 13px;">
                        Yes, Leave
                    </button>
                    <button onclick="event.stopPropagation(); closeLeaveWatchpartyModal();" class="btn btn-secondary" style="width: 100%; padding: 10px; font-size: 13px;">
                        Cancel
                    </button>
                </div>
            </div>

            <button class="copy-room-code" onclick="copyRoomCode()" style="display: none;">Copy Room Code</button>
        </div>

        <div class="watchparty-users">
            <div class="watchparty-users-title">Watching (<span id="userCount">0</span>)</div>
            <div id="watchpartyUserList"></div>
            <button class="resync-btn" id="syncBtn" onclick="triggerSync()">Sync Everyone to Me</button>
        </div>

        <div class="watchparty-chat">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <div id="replyIndicator" class="reply-indicator" style="display: none;">
                    <span id="replyingToText"></span>
                    <button onclick="cancelReply()"></button>
                </div>
                <div class="chat-input-wrapper">
                    <input type="text" id="chatInput" class="chat-input" placeholder="Type a message..." onkeypress="handleChatKeypress(event)">
                    <button class="chat-send-btn" onclick="sendChatMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Ready Check Overlay -->
    <div class="sync-overlay" id="readyCheckOverlay">
        <h2>Coordinated Sync</h2>
        <p>Wait for the video to buffer, then click Ready</p>
        <span class="ready-count" id="readyCount">0/0 Ready</span>
        <button class="ready-btn" id="readyBtn" onclick="markReady()">I'm Ready</button>
        <button class="force-start-btn" id="forceStartBtn" style="display:none;" onclick="forceStartCountdown()">Start Anyway</button>
    </div>

    <!-- Countdown Overlay -->
    <div class="countdown-overlay" id="countdownOverlay">
        <div class="countdown-number" id="countdownNumber">5</div>
        <div class="countdown-label">Syncing playback...</div>
    </div>

    <script>
        // ============= SPOTLIGHT CARD BORDER EFFECT - POINTER TRACKING =============
        (function() {
            var root = document.documentElement;

            document.addEventListener('pointermove', function(e) {
                root.style.setProperty('--mouse-x', e.clientX.toFixed(2));
                root.style.setProperty('--mouse-y', e.clientY.toFixed(2));
                root.style.setProperty('--mouse-xp', (e.clientX / window.innerWidth).toFixed(2));
                root.style.setProperty('--mouse-yp', (e.clientY / window.innerHeight).toFixed(2));
            });

            var spotlightSelectors = [
                '.content-card',
                '.continue-item',
                '.player-watchlist-list-card',
                '.watchlist-slide-list-card',
                '.watchlist-item-card',
                '.friend-request-card',
                '.friend-card',
                '.sync-action-card'
            ];

            function addSpotlightClass() {
                spotlightSelectors.forEach(function(sel) {
                    document.querySelectorAll(sel).forEach(function(el) {
                        if (!el.classList.contains('spotlight-card')) {
                            el.classList.add('spotlight-card');
                        }
                    });
                });
            }

            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', addSpotlightClass);
            } else {
                addSpotlightClass();
            }

            var observer = new MutationObserver(function(mutations) {
                var shouldUpdate = false;
                for (var i = 0; i < mutations.length; i++) {
                    if (mutations[i].addedNodes.length) {
                        shouldUpdate = true;
                        break;
                    }
                }
                if (shouldUpdate) {
                    requestAnimationFrame(addSpotlightClass);
                }
            });

            function startObserving() {
                if (document.body) {
                    observer.observe(document.body, { childList: true, subtree: true });
                } else {
                    document.addEventListener('DOMContentLoaded', function() {
                        observer.observe(document.body, { childList: true, subtree: true });
                    });
                }
            }
            startObserving();
        })();
        // ============= END SPOTLIGHT POINTER TRACKING =============

        // Define global functions FIRST for onclick handlers
        console.log('[INIT] Script loading...');

        // These must be defined early for onclick handlers to work
        window.showTab = function(tabName) { console.log('showTab called but not initialized'); };
        window.showLoginModal = function() { console.log('showLoginModal called but not initialized'); };
        window.showRegisterModal = function() { console.log('showRegisterModal called but not initialized'); };
        window.logout = function() { console.log('logout called but not initialized'); };
        window.searchContent = function() { console.log('searchContent called but not initialized'); };
        window.showFriendsModal = function() { console.log('showFriendsModal called but not initialized'); };

        // ============= RADIAL MENU SYSTEM =============
        let activeRadialMenu = null;
        let activeContentSection = null; // 'movies', 'tv-shows', or 'continue-watching'
        let activeContentFilter = null; // 'popular', 'trending', 'upcoming', 'now-playing'

        // Update all button active states
        function updateButtonActiveStates() {
            const moviesBtn = document.getElementById('moviesRadialBtn');
            const tvBtn = document.getElementById('tvShowsRadialBtn');
            const continueWatchingBar = document.getElementById('continueWatchingBar');

            // Reset all buttons
            if (moviesBtn) moviesBtn.classList.remove('active');
            if (tvBtn) tvBtn.classList.remove('active');
            if (continueWatchingBar) continueWatchingBar.classList.remove('active');

            // Set active based on current section
            if (activeContentSection === 'movies' && moviesBtn) {
                moviesBtn.classList.add('active');
            } else if (activeContentSection === 'tv-shows' && tvBtn) {
                tvBtn.classList.add('active');
            } else if (activeContentSection === 'continue-watching' && continueWatchingBar) {
                continueWatchingBar.classList.add('active');
            }
        }

        // Update radial menu option selected states
        function updateRadialOptionStates() {
            // Clear all selected states
            document.querySelectorAll('.radial-option').forEach(opt => opt.classList.remove('selected'));

            // Set selected state for current filter
            if (activeContentSection === 'movies' && activeContentFilter) {
                const moviesMenu = document.getElementById('moviesRadialMenu');
                if (moviesMenu) {
                    const options = moviesMenu.querySelectorAll('.radial-option');
                    options.forEach(opt => {
                        const onclick = opt.getAttribute('onclick');
                        if (onclick && onclick.includes(`'${activeContentFilter}'`)) {
                            opt.classList.add('selected');
                        }
                    });
                }
            } else if (activeContentSection === 'tv-shows' && activeContentFilter) {
                const tvMenu = document.getElementById('tvShowsRadialMenu');
                if (tvMenu) {
                    const options = tvMenu.querySelectorAll('.radial-option');
                    options.forEach(opt => {
                        const onclick = opt.getAttribute('onclick');
                        if (onclick && onclick.includes(`'${activeContentFilter}'`)) {
                            opt.classList.add('selected');
                        }
                    });
                }
            }
        }

        // Hide all content sections
        function hideAllContentSections() {
            const contentResults = document.getElementById('contentResults');
            const continueWatchingDisplay = document.getElementById('continueWatchingDisplay');
            const watchlistDisplay = document.getElementById('watchlistDisplay');
            const statisticsDisplay = document.getElementById('statisticsDisplay');
            const sportsDisplay = document.getElementById('sportsDisplay');
            const channelsDisplay = document.getElementById('channelsDisplay');
            const contentTypeFilters = document.getElementById('contentTypeFilters');

            if (contentResults) contentResults.style.display = 'none';
            if (continueWatchingDisplay) continueWatchingDisplay.style.display = 'none';
            if (watchlistDisplay) watchlistDisplay.style.display = 'none';
            if (statisticsDisplay) statisticsDisplay.style.display = 'none';
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            if (channelsDisplay) channelsDisplay.style.display = 'none';
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            activeContentSection = null;
            activeContentFilter = null;
            currentTab = null; // Reset currentTab
            updateButtonActiveStates();
            updateRadialOptionStates();
        }

        window.toggleRadialMenu = function(menuType) {
            const moviesMenu = document.getElementById('moviesRadialMenu');
            const tvMenu = document.getElementById('tvShowsRadialMenu');
            const moviesBtn = document.getElementById('moviesRadialBtn');
            const tvBtn = document.getElementById('tvShowsRadialBtn');
            const backdrop = document.getElementById('radialBackdrop');

            // Update radial option states before showing menu
            updateRadialOptionStates();

            // Close floating search if open
            if (floatingSearchOpen) {
                toggleFloatingSearch();
            }

            if (menuType === 'movies') {
                if (moviesMenu.classList.contains('active')) {
                    // Close movies menu
                    closeAllRadialMenus();
                } else {
                    // Close any open menu first
                    closeAllRadialMenus();
                    // Open movies menu
                    moviesMenu.classList.add('active');
                    moviesBtn.classList.add('menu-open');
                    backdrop.classList.add('active');
                    activeRadialMenu = 'movies';
                    updateRadialOptionStates();
                }
            } else if (menuType === 'tv-shows') {
                if (tvMenu.classList.contains('active')) {
                    // Close TV menu
                    closeAllRadialMenus();
                } else {
                    // Close any open menu first
                    closeAllRadialMenus();
                    // Open TV menu
                    tvMenu.classList.add('active');
                    tvBtn.classList.add('menu-open');
                    backdrop.classList.add('active');
                    activeRadialMenu = 'tv-shows';
                    updateRadialOptionStates();
                }
            }
        };

        window.closeAllRadialMenus = function() {
            const moviesMenu = document.getElementById('moviesRadialMenu');
            const tvMenu = document.getElementById('tvShowsRadialMenu');
            const moviesBtn = document.getElementById('moviesRadialBtn');
            const tvBtn = document.getElementById('tvShowsRadialBtn');
            const backdrop = document.getElementById('radialBackdrop');

            if (moviesMenu) moviesMenu.classList.remove('active');
            if (tvMenu) tvMenu.classList.remove('active');
            if (moviesBtn) moviesBtn.classList.remove('menu-open');
            if (tvBtn) tvBtn.classList.remove('menu-open');
            if (backdrop) backdrop.classList.remove('active');
            activeRadialMenu = null;
        };

        window.selectMovieFilter = function(filter) {
            // Check if this filter is already active - if so, toggle off
            if (activeContentSection === 'movies' && activeContentFilter === filter) {
                closeAllRadialMenus();
                hideAllContentSections();
                return;
            }

            closeAllRadialMenus();

            // Set current state
            activeContentSection = 'movies';
            activeContentFilter = filter;
            window.currentMediaType = 'movie';
            window.currentContentFilter = filter;
            window.currentPage = 1;
            currentTab = null; // Clear currentTab when switching to movies

            // Hide other sections first
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            const sportsDisplay = document.getElementById('sportsDisplay');
            const channelsDisplay = document.getElementById('channelsDisplay');
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            if (channelsDisplay) channelsDisplay.style.display = 'none';

            // Show the content results area
            const contentResults = document.getElementById('contentResults');
            if (contentResults) contentResults.style.display = 'grid';

            // Show content type filters (only genre and language)
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (contentTypeFilters) {
                contentTypeFilters.style.display = 'flex';
                if (typeof loadGenres === 'function') {
                    loadGenres('movie');
                }
            }

            // Update button states
            updateButtonActiveStates();
            updateRadialOptionStates();

            // Load the appropriate content
            if (filter === 'popular' && typeof loadPopularMovies === 'function') {
                loadPopularMovies();
            } else if (filter === 'trending' && typeof loadTrendingMovies === 'function') {
                loadTrendingMovies();
            } else if (filter === 'upcoming' && typeof loadUpcomingMovies === 'function') {
                loadUpcomingMovies();
            }
        };

        window.selectTvFilter = function(filter) {
            // Check if this filter is already active - if so, toggle off
            if (activeContentSection === 'tv-shows' && activeContentFilter === filter) {
                closeAllRadialMenus();
                hideAllContentSections();
                return;
            }

            closeAllRadialMenus();

            // Set current state
            activeContentSection = 'tv-shows';
            activeContentFilter = filter;
            window.currentMediaType = 'tv';
            window.currentContentFilter = filter;
            window.currentPage = 1;
            currentTab = null; // Clear currentTab when switching to TV shows

            // Hide other sections first
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            const sportsDisplay = document.getElementById('sportsDisplay');
            const channelsDisplay = document.getElementById('channelsDisplay');
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            if (channelsDisplay) channelsDisplay.style.display = 'none';

            // Show the content results area
            const contentResults = document.getElementById('contentResults');
            if (contentResults) contentResults.style.display = 'grid';

            // Show content type filters (only genre and language)
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (contentTypeFilters) {
                contentTypeFilters.style.display = 'flex';
                if (typeof loadGenres === 'function') {
                    loadGenres('tv');
                }
            }

            // Update button states
            updateButtonActiveStates();
            updateRadialOptionStates();

            // Load the appropriate content
            if (filter === 'popular' && typeof loadPopularTVShows === 'function') {
                loadPopularTVShows();
            } else if (filter === 'trending' && typeof loadTrendingTVShows === 'function') {
                loadTrendingTVShows();
            } else if (filter === 'now-playing' && typeof loadNowPlayingTVShows === 'function') {
                loadNowPlayingTVShows();
            }
        };

        // Toggle Continue Watching section
        window.toggleContinueWatching = function() {
            // Check if Continue Watching is already active - if so, toggle off
            if (activeContentSection === 'continue-watching') {
                hideAllContentSections();
                currentTab = null; // Reset currentTab
                return;
            }

            // Close any open radial menus
            closeAllRadialMenus();

            // Set current state
            activeContentSection = 'continue-watching';
            activeContentFilter = null;
            currentTab = 'continue-watching'; // Set currentTab for displayContinueWatchingInResults

            // Hide other sections
            const contentResults = document.getElementById('contentResults');
            const watchlistDisplay = document.getElementById('watchlistDisplay');
            const statisticsDisplay = document.getElementById('statisticsDisplay');
            const sportsDisplay = document.getElementById('sportsDisplay');
            const channelsDisplay = document.getElementById('channelsDisplay');
            const contentTypeFilters = document.getElementById('contentTypeFilters');

            if (contentResults) contentResults.style.display = 'none';
            if (watchlistDisplay) watchlistDisplay.style.display = 'none';
            if (statisticsDisplay) statisticsDisplay.style.display = 'none';
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            if (channelsDisplay) channelsDisplay.style.display = 'none';
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            // Show Continue Watching display
            const continueWatchingDisplay = document.getElementById('continueWatchingDisplay');
            if (continueWatchingDisplay) {
                continueWatchingDisplay.style.display = 'grid';
            }

            // Update button states
            updateButtonActiveStates();
            updateRadialOptionStates();

            // Load continue watching content if function exists
            if (typeof displayContinueWatchingInResults === 'function') {
                displayContinueWatchingInResults();
            }
        };

        // Close radial menu on escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && activeRadialMenu) {
                closeAllRadialMenus();
            }
        });
        // ============= END RADIAL MENU SYSTEM =============

        const API_BASE_URL = `${window.location.origin}/api`;
        let currentContentUrl = '';
        let currentContentType = 'movie';
        let currentContentId = null;
        let currentContentData = null;
        let episodeCache = {}; // Cache for episode data: { tvId: { seasonNumber: seasonData } }
        let searchResults = [];
        let movieGenresList = [];
        let tvGenresList = [];
        let currentTab = null; // No tab active by default
        let currentGenreId = null;
        let currentPage = 1;
        let currentMediaType = 'movie'; // 'movie' or 'tv'
        let currentContentFilter = 'popular'; // 'popular', 'trending', 'now-playing', 'upcoming'
        let currentLanguage = null; // null = all languages, 'en', 'ar', 'ko', 'ja', 'zh'

        // Video source preference: 'vidsrc', 'vidking', or 'superembed'
        let videoSource = localStorage.getItem('videoSource') || 'vidsrc';

        // ============= WATCHPARTY VARIABLES =============
        let socket = null;
        let watchpartyActive = false;
        let watchpartyRoomCode = null;
        let isHost = false;
        let username = null;
        let watchpartyUsers = [];

        // Coordinated sync variables
        let partySyncMode = 'none'; // 'full', 'coordinated', 'none'
        let partySourceLocked = false;
        let previousVideoSource = null;
        let countdownTimer = null;
        let userIsReady = false;

        // User color system for chat - vibrant colors matching app design
        const userColors = [
            '#FF6B6B', // Coral Red
            '#4ECDC4', // Turquoise
            '#45B7D1', // Sky Blue
            '#FFA07A', // Light Salmon
            '#98D8C8', // Mint
            '#F7DC6F', // Sunny Yellow
            '#BB8FCE', // Lavender
            '#85C1E2', // Powder Blue
            '#F8B739', // Golden
            '#5DADE2', // Bright Blue
            '#58D68D', // Emerald
            '#EC7063', // Pink Red
            '#AF7AC5', // Purple
            '#52BE80', // Green
            '#EB984E', // Orange
        ];
        let userColorMap = {}; // Maps username to color

        // ============= END WATCHPARTY VARIABLES =============

        // Multiple watchlists support
        // Initialize from localStorage only as fallback for non-authenticated users
        let watchlists = { 'My Watchlist': [] }; // No localStorage - loaded from DB when authenticated
        let currentWatchlistName = localStorage.getItem('streamingSite_currentWatchlist') || 'My Watchlist';

        // Legacy support - migrate old single watchlist to new format
        const oldWatchlist = JSON.parse(localStorage.getItem('streamingSite_watchlist') || '[]');
        if (oldWatchlist.length > 0 && !watchlists['My Watchlist']) {
            watchlists['My Watchlist'] = oldWatchlist;
            localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
            localStorage.removeItem('streamingSite_watchlist');
        }

        // Initialize from localStorage only as fallback for non-authenticated users
        let watchHistory = []; // No localStorage - loaded from DB when authenticated
        let channelFavourites = []; // No localStorage - loaded from DB when authenticated

        // Flag to track if data is loaded from database
        let isDataLoadedFromDB = false;

        // TMDB Genre mappings
        const movieGenres = {
            28: "Action", 12: "Adventure", 16: "Animation", 35: "Comedy", 80: "Crime",
            99: "Documentary", 18: "Drama", 10751: "Family", 14: "Fantasy", 36: "History",
            27: "Horror", 10402: "Music", 9648: "Mystery", 10749: "Romance", 878: "Sci-Fi",
            10770: "TV Movie", 53: "Thriller", 10752: "War", 37: "Western"
        };

        const tvGenres = {
            10759: "Action & Adventure", 16: "Animation", 35: "Comedy", 80: "Crime",
            99: "Documentary", 18: "Drama", 10751: "Family", 10762: "Kids", 9648: "Mystery",
            10763: "News", 10764: "Reality", 10765: "Sci-Fi & Fantasy", 10766: "Soap",
            10767: "Talk", 10768: "War & Politics", 37: "Western"
        };

        function getGenreNames(genreIds, isTV) {
            const genreMap = isTV ? tvGenres : movieGenres;
            return genreIds.map(id => genreMap[id]).filter(Boolean).slice(0, 3);
        }

        let autocompleteTimeout;

        /* ---------- Ratings (You + Friends) helpers ---------- */

        function ensureOmdbDom(){
          // Return the existing ratings grid used by IMDb/RT/Metacritic (do not create new wrappers here)
          return document.querySelector('#omdbRatings .ratings-container')
              || document.querySelector('.omdb-ratings .ratings-container')
              || document.querySelector('.ratings-container')
              || null;
        }

        function hostRatingsBox(){
          return ensureOmdbDom();
        }

        function getAuthToken(){
          return (window.authToken)
              || localStorage.getItem('jwt')
              || localStorage.getItem('token')
              || localStorage.getItem('access_token');
        }

        async function baseRequest(path, opt = {}){
          const headers = Object.assign({'Content-Type':'application/json'}, opt.headers || {});
          const token = getAuthToken();
          if (token) headers['Authorization'] = 'Bearer ' + token;
          const url = path.startsWith('/api') ? path : `${API_BASE_URL}${path.startsWith('/') ? '' : '/'}${path}`;
          const res = await fetch(url, Object.assign({ headers, credentials: 'include' }, opt));
          if (!res.ok) {
            const text = await res.text().catch(()=> '');
            const err = new Error(text || ('HTTP ' + res.status));
            err.status = res.status;
            throw err;
          }
          return res.status === 204 ? null : res.json();
        }

        function ensurePill(container){
          if (!container) return null;
          let pill = document.getElementById('userRatingPill');
          if (pill && pill.parentElement !== container) {
            pill.remove();
            pill = null;
          }
          if (pill) return pill;

          pill = document.createElement('div');
          pill.className = 'rating-item user-pill';
          pill.id = 'userRatingPill';
          pill.innerHTML = `
            <div class="rating-source">You</div>
            <div class="rating-value" id="userRatingValue"></div>
            <div style="display:flex; align-items:center; gap:8px; margin-top:4px;">
              <input id="userRatingInput" type="number" min="1" max="10" step="0.1" placeholder="110" />
              <button class="post-btn" id="postUserRatingBtn">Post</button>
            </div>
          `;
          container.appendChild(pill);
          const btn = pill.querySelector('#postUserRatingBtn');
          btn.addEventListener('click', postUserRating);
          return pill;
        }

        async function getFriendUsernames(){
          try {
            const r = await baseRequest('/friends', { method: 'GET' });
            // Handle both array and object formats
            let friendsList = [];
            if (Array.isArray(r)) {
              friendsList = r;
            } else if (r && Array.isArray(r.friends)) {
              friendsList = r.friends;
            }
            return friendsList.map(f => f.username || f);
          } catch(_) {
            return [];
          }
        }

        async function postUserRating(){
          if (!currentContentId || !currentContentType) { showError('Select a title first'); return; }

          const input = document.getElementById('userRatingInput');
          const val = parseFloat(input && input.value);
          if (isNaN(val) || val < 1 || val > 10) { showError('Please enter a value from 1 to 10'); return; }

          try {
            await baseRequest(`/ratings/${currentContentType}/${currentContentId}`, {
              method: 'POST',
              body: JSON.stringify({ rating: val })
            });
            await refreshRatingsUI();
          } catch(e) {
            if (e && (e.status === 401 || /401/.test(String(e.message||'')))) {
              if (window.showLoginModal) showLoginModal(); else alert('Please log in');
            } else {
              console.error(e); showError('Failed to save rating');
            }
          }
        }

        async function refreshRatingsUI(){
          const container = hostRatingsBox();
          if (!container || !currentContentId || !currentContentType) return;

          // Ensure "You" tile exists
          ensurePill(container);

          let data = { ratings_by_user: {} };
          try {
            data = await baseRequest(`/ratings/${currentContentType}/${currentContentId}`, { method: 'GET' });
          } catch(e) {
            console.warn('ratings fetch failed', e);
          }

          const cu = (window.currentUser) || ( () => { try { return JSON.parse(localStorage.getItem('currentUser')||'null'); } catch(_) { return null; } })();
          const me = (cu && (cu.username || cu.name)) || null;

          // Update "You" tile UI
          const input = document.getElementById('userRatingInput');
          const btn = document.getElementById('postUserRatingBtn');
          const youValEl = document.getElementById('userRatingValue');
          const yourVal = me ? data.ratings_by_user?.[me] : null;

          if (input) input.value = (yourVal || '');
          if (btn) btn.textContent = yourVal ? 'Update' : 'Post';
          if (youValEl) youValEl.textContent = (yourVal ? `${yourVal}/10` : '');

          // Remove any previously rendered friend tiles to avoid duplication
          container.querySelectorAll('.friend-rating-item').forEach(n => n.remove());

          // Render friend ratings as tiles
          try {
            const friends = await getFriendUsernames();
            const friendEntries = Object.entries(data.ratings_by_user || {})
              .filter(([u,_]) => (!me || u !== me) && friends.includes(u));

            if (friendEntries.length) {
              for (const [u, v] of friendEntries) {
                const tile = document.createElement('div');
                tile.className = 'rating-item friend-rating-item';
                tile.innerHTML = `
                  <div class="rating-source">@${u}</div>
                  <div class="rating-value">${v}/10</div>
                `;
                container.appendChild(tile);
              }
            } else {
              // Optional placeholder to indicate friend area
              const placeholder = document.createElement('div');
              placeholder.className = 'rating-item friend-rating-item';
              placeholder.style.opacity = '0.7';
              placeholder.innerHTML = `
                <div class="rating-source">Friends</div>
                <div class="rating-value"></div>
              `;
              container.appendChild(placeholder);
            }
          } catch(e) {
            console.warn('friends fetch failed', e);
          }
        }

        function clearRatingsUI() {
          const container = hostRatingsBox();
          if (!container) return;

          // Clear friend rating tiles
          container.querySelectorAll('.friend-rating-item').forEach(n => n.remove());

          // Reset "You" tile to default state
          const input = document.getElementById('userRatingInput');
          const btn = document.getElementById('postUserRatingBtn');
          const youValEl = document.getElementById('userRatingValue');

          if (input) input.value = '';
          if (btn) btn.textContent = 'Post';
          if (youValEl) youValEl.textContent = '';
        }

        /* ---------- end Ratings (You + Friends) helpers ---------- */

        // Track which content has been refreshed (shared with later definition)
        let __earlyLastRefreshedContentId = null;

        function setupUserRatingsPill(){
            const box = ensureOmdbDom() || hostRatingsBox();
            console.debug('[ratings] setupUserRatingsPill: container?', !!box, { currentContentType, currentContentId });
            if (!box) return;
            ensurePill(box);

            // Only refresh if we have valid content info and haven't already refreshed for this content
            if (currentContentType && currentContentId) {
                const contentKey = `${currentContentType}_${currentContentId}`;
                if (__earlyLastRefreshedContentId !== contentKey) {
                    __earlyLastRefreshedContentId = contentKey;
                    console.debug('[ratings] Refreshing for:', contentKey);
                    try { refreshRatingsUI(); } catch(e){ console.error(e); }
                } else {
                    console.debug('[ratings] Already refreshed for:', contentKey);
                }
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize aurora shader background
            initShaderBackground();

            // Fix layout order: ensure popular-section (filters) appears before player-section
            const layoutContainer = document.querySelector('.container');
            const popularSection = layoutContainer && layoutContainer.querySelector('.popular-section');
            const playerSection = layoutContainer && layoutContainer.querySelector('.player-section');
            if (layoutContainer && popularSection && playerSection) {
                layoutContainer.insertBefore(popularSection, playerSection);
            }

            // Don't load any content by default - wait for user to click a tab
            // Hide all content sections initially
            document.getElementById('contentResults').style.display = 'none';
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            const sportsDisplay = document.getElementById('sportsDisplay');
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            const channelsDisplay = document.getElementById('channelsDisplay');
            if (channelsDisplay) channelsDisplay.style.display = 'none';

            // Remove any active tab styling
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Hide genre filter and content type filters initially
            const genreContainer = document.getElementById('genreFilterContainer');
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (genreContainer) genreContainer.style.display = 'none';
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            const searchInput = document.getElementById('searchInput');

            // Add autocomplete on typing
            searchInput.addEventListener('input', function(e) {
                const query = e.target.value.trim();

                clearTimeout(autocompleteTimeout);

                if (query.length < 2) {
                    hideAutocomplete();
                    return;
                }

                autocompleteTimeout = setTimeout(() => {
                    fetchAutocomplete(query);
                }, 300);
            });

            // Hide autocomplete when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.search-container')) {
                    hideAutocomplete();
                }
            });

            // Add enter key support for search
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    hideAutocomplete();
                    searchContent();
                }
            });

            // Add hover listener for OMDB ratings tooltips
            document.addEventListener('mouseover', function(e) {
                const card = e.target.closest('.content-card, .continue-item');
                if (card && card.dataset.id) {
                    const tooltip = card.querySelector('.omdb-ratings-tooltip');
                    if (tooltip && !tooltip.dataset.loaded) {
                        loadOMDBRatings(card.dataset.id, card.dataset.type, tooltip);
                    }
                }
            });

            // Setup mobile keyboard handlers for chat
            setupMobileChatHandlers();

            // Setup infinite scroll for popular/trending sections
            setupInfiniteScroll();

        });

        async function fetchAutocomplete(query) {
            try {
                const endpoint = `${API_BASE_URL}/search/multi`;
                const params = new URLSearchParams({ query });

                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    showAutocomplete(data.results.slice(0, 5));
                } else {
                    hideAutocomplete();
                }
            } catch (error) {
                console.error('Autocomplete error:', error);
                hideAutocomplete();
            }
        }

        function showAutocomplete(results) {
            const autocompleteDiv = document.getElementById('searchAutocomplete');

            autocompleteDiv.innerHTML = results.map(item => {
                const isTV = item.content_type === 'tv' || item.media_type === 'tv' || item.name;
                const itemTitle = isTV ? (item.name || item.title) : (item.title || item.name);
                const year = isTV ?
                    (item.first_air_date ? item.first_air_date.substring(0, 4) : 'Unknown') :
                    (item.release_date ? item.release_date.substring(0, 4) : 'Unknown');
                const posterUrl = item.poster_url || 'https://via.placeholder.com/40x60/333/fff?text=No';
                const type = isTV ? 'tv' : 'movie';

                return `
                    <div class="autocomplete-item" onclick="selectAutocompleteItem(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${type}')">
                        <img src="${posterUrl}" alt="${itemTitle}" class="autocomplete-poster"
                             onerror="this.src='https://via.placeholder.com/40x60/333/fff?text=No'">
                        <div class="autocomplete-info">
                            <div class="autocomplete-title">${itemTitle}</div>
                            <div class="autocomplete-meta">${type.toUpperCase()}  ${year}</div>
                        </div>
                    </div>
                `;
            }).join('');

            autocompleteDiv.style.display = 'block';
        }

        function hideAutocomplete() {
            document.getElementById('searchAutocomplete').style.display = 'none';
        }

        function selectAutocompleteItem(id, title, type) {
            document.getElementById('searchInput').value = title;
            hideAutocomplete();

            // Directly play the selected content
            playContent(id, title, type);
        }

        async function loadOMDBRatings(id, type, tooltip) {
            try {
                tooltip.dataset.loaded = 'loading';

                const endpoint = type === 'tv' ? `${API_BASE_URL}/tv/${id}` : `${API_BASE_URL}/movie/${id}`;
                const response = await fetch(endpoint);
                const data = await response.json();

                if (data.error || !data.omdb_ratings || data.omdb_ratings.length === 0) {
                    tooltip.innerHTML = '<div class="tooltip-loading">No ratings available</div>';
                    tooltip.dataset.loaded = 'true';
                    return;
                }

                // Extract IMDb and Rotten Tomatoes ratings
                const imdbRating = data.omdb_imdb_rating || 'N/A';
                const imdbVotes = data.omdb_imdb_votes || '';
                let rtRating = 'N/A';

                data.omdb_ratings.forEach(rating => {
                    if (rating.Source === 'Rotten Tomatoes') {
                        rtRating = rating.Value;
                    }
                });

                // Get runtime and content rating
                const runtime = data.omdb_runtime || data.runtime || '';
                const contentRating = data.omdb_rated || data.content_rating || data.certification || '';

                // Format vote count if available
                const voteCountText = imdbVotes ? `<div style="font-family: 'VT323', monospace; font-size: 15px; color: #888; margin-top: 2px;">Rated by ${imdbVotes} users</div>` : '';

                // Build runtime row if available
                const runtimeRow = runtime ? `
                    <div class="tooltip-rating-row" style="margin-top: 4px;">
                        <span class="tooltip-rating-source">Runtime</span>
                        <span class="tooltip-rating-value">${runtime}</span>
                    </div>
                ` : '';

                // Build content rating row if available
                const contentRatingRow = contentRating ? `
                    <div class="tooltip-rating-row" style="margin-top: 4px;">
                        <span class="tooltip-rating-source">Rating</span>
                        <span class="tooltip-rating-value">${contentRating}</span>
                    </div>
                ` : '';

                tooltip.innerHTML = `
                    <div class="tooltip-rating-row">
                        <span class="tooltip-rating-source">IMDb</span>
                        <span class="tooltip-rating-value">${imdbRating}</span>
                    </div>
                    ${voteCountText}
                    <div class="tooltip-rating-row" style="margin-top: ${voteCountText ? '4px' : '0'};">
                        <span class="tooltip-rating-source">Rotten Tomatoes</span>
                        <span class="tooltip-rating-value">${rtRating}</span>
                    </div>
                    ${runtimeRow}
                    ${contentRatingRow}
                `;
                tooltip.dataset.loaded = 'true';
            } catch (error) {
                console.error('Error loading OMDB ratings:', error);
                tooltip.innerHTML = '<div class="tooltip-loading">Failed to load</div>';
                tooltip.dataset.loaded = 'true';
            }
        }

        async function openImdb(id, title, type) {
            // Open window immediately to avoid popup blocker
            const imdbWindow = window.open('about:blank', '_blank');

            try {
                showStatus('Fetching IMDb link...');

                // Fetch full details from TMDB which includes external IDs
                const endpoint = type === 'tv' ? `${API_BASE_URL}/tv/${id}` : `${API_BASE_URL}/movie/${id}`;
                const response = await fetch(endpoint);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                // Try to get IMDb ID from external_ids or direct imdb_id field
                let imdbId = data.imdb_id || (data.external_ids && data.external_ids.imdb_id);

                if (imdbId) {
                    // Direct link to IMDb title page
                    imdbWindow.location.href = `https://www.imdb.com/title/${imdbId}/`;
                    showStatus('Opened IMDb page');
                } else {
                    // Fallback to search if IMDb ID not available
                    imdbWindow.location.href = `https://www.imdb.com/find/?q=${encodeURIComponent(title)}&s=tt`;
                    showStatus('Opened IMDb search');
                }

                setTimeout(() => hideStatus(), 2000);
            } catch (error) {
                console.error('IMDb link error:', error);
                // Fallback to search on error
                imdbWindow.location.href = `https://www.imdb.com/find/?q=${encodeURIComponent(title)}&s=tt`;
                showError('Could not fetch IMDb ID, opened search instead');
                setTimeout(() => hideError(), 3000);
            }
        }

        function showStatus(message, type = 'info') {
            const statusBar = document.getElementById('statusBar');
            statusBar.textContent = message;
            statusBar.style.display = 'block';

            // Handle different types
            if (type === 'warning') {
                statusBar.style.background = 'rgba(255, 149, 0, 0.2)';
                statusBar.style.borderColor = 'rgba(255, 149, 0, 0.6)';
                statusBar.style.color = '#fff';
            } else {
                statusBar.style.background = 'rgba(0, 122, 255, 0.2)';
                statusBar.style.borderColor = 'rgba(0, 122, 255, 0.6)';
                statusBar.style.color = '#fff';
            }
        }

        function hideStatus() {
            document.getElementById('statusBar').style.display = 'none';
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function showLoading() {
            document.getElementById('loadingIndicator').style.display = 'block';
        }

        function hideLoading() {
            document.getElementById('loadingIndicator').style.display = 'none';
        }

        window.searchContent = async function() {
            const query = document.getElementById('searchInput').value.trim();

            if (!query) {
                showError('Please enter a title');
                return;
            }

            hideError();
            showLoading();
            showStatus(`Searching for "${query}"...`);

            try {
                const params = new URLSearchParams({ query });
                const endpoint = `${API_BASE_URL}/search/multi`;

                const response = await fetch(`${endpoint}?${params}`);
                const data = await response.json();

                if (data.error || !data.results || data.results.length === 0) {
                    throw new Error(data.error || 'No results found');
                }

                searchResults = data.results;
                displayContent(searchResults, 'Search Results');
                showTab('search-results');

            } catch (error) {
                console.error('Search error:', error);
                showError(`Search failed: ${error.message}`);
                displayContent([], 'No Results');
            } finally {
                hideLoading();
            }
        }

        // Infinite scroll state
        let isLoadingMore = false;
        let currentCategory = null;
        let hasMorePages = true;

        async function loadPopularMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'popular-movies';
           

            try {
                let url = `${API_BASE_URL}/popular?page=${page}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Popular Movies');
                }

            } catch (error) {
                console.error('Popular movies error:', error);
                showError(`Failed to load popular movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Popular Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadPopularTVShows(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'popular-tv';

            try {
                let url = `${API_BASE_URL}/tv/popular?page=${page}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Popular TV Shows');
                }

            } catch (error) {
                console.error('Popular TV shows error:', error);
                showError(`Failed to load popular TV shows: ${error.message}`);
                if (!append) {
                    displayContent([], 'Popular TV Shows');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadTrendingMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'trending-movies';
           
    
    

            try {
                let url = `${API_BASE_URL}/trending?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Trending Movies');
                }

            } catch (error) {
                console.error('Trending movies error:', error);
                showError(`Failed to load trending movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Trending Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadTrendingTVShows(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'trending-tv';
           

            try {
                let url = `${API_BASE_URL}/tv/trending?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Trending TV Shows');
                }

            } catch (error) {
                console.error('Trending TV shows error:', error);
                showError(`Failed to load trending TV shows: ${error.message}`);
                if (!append) {
                    displayContent([], 'Trending TV Shows');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadNowPlayingMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'now-playing-movies';
      

            try {
                let url = `${API_BASE_URL}/movies/now-playing?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Now Playing Movies');
                }

            } catch (error) {
                console.error('Now playing movies error:', error);
                showError(`Failed to load now playing movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Now Playing Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadNowPlayingTVShows(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'now-playing-tv';
           

            try {
                let url = `${API_BASE_URL}/tv/now-playing?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Now Playing TV Shows');
                }

            } catch (error) {
                console.error('Now playing TV shows error:', error);
                showError(`Failed to load now playing TV shows: ${error.message}`);
                if (!append) {
                    displayContent([], 'Now Playing TV Shows');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        async function loadUpcomingMovies(page = 1, append = false) {
            if (!append) {
                hideError();
                showLoading();
                currentPage = 1;
                hasMorePages = true;
            }
            currentCategory = 'upcoming-movies';
        

            try {
                let url = `${API_BASE_URL}/movies/upcoming?page=${page || 1}`;
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }
                const response = await fetch(url);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                if (append) {
                    appendContent(data.results || []);
                } else {
                    displayContent(data.results || [], 'Upcoming Movies');
                }

            } catch (error) {
                console.error('Upcoming movies error:', error);
                showError(`Failed to load upcoming movies: ${error.message}`);
                if (!append) {
                    displayContent([], 'Upcoming Movies');
                }
            } finally {
                if (!append) {
                    hideLoading();
                }
                isLoadingMore = false;
            }
        }

        function displayContent(items, title) {
            const resultsDiv = document.getElementById('contentResults');

            if (!items || items.length === 0) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px;">
                        <h3>No content found</h3>
                        <p>Try different search terms or browse popular content</p>
                    </div>
                `;
                return;
            }

            resultsDiv.innerHTML = items.map(item => {
                const posterUrl = item.poster_url || 'https://via.placeholder.com/200x300/333/fff?text=No+Poster';
                const isTV = item.content_type === 'tv' || item.media_type === 'tv' || item.name;
                const itemTitle = isTV ? (item.name || item.title) : (item.title || item.name);
                const year = isTV ?
                    (item.first_air_date ? item.first_air_date.substring(0, 4) : 'Unknown') :
                    (item.release_date ? item.release_date.substring(0, 4) : 'Unknown');
                const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';

                const isInWatchlist = isItemInWatchlist(item.id, isTV ? 'tv' : 'movie');

                // Get genre names from genre_ids
                const genreNames = getGenreNames(item.genre_ids || [], isTV);
                const genreDisplay = genreNames.length > 0 ? genreNames.join('  ') : 'Genre not available';

                // Get watch progress for this item
                const watchProgress = getWatchProgress(item.id, isTV ? 'tv' : 'movie');
                const progressBarHtml = watchProgress > 0 ? `
                    <div class="card-progress-bar">
                        <div class="card-progress-fill" style="width: ${watchProgress}%"></div>
                    </div>
                ` : '';

                // Get rating and runtime if available
                // Debug: log to see what fields are available
                if (!window._itemFieldsLogged) {
                    console.log('Item fields:', Object.keys(item));
                    console.log('Sample item:', item);
                    window._itemFieldsLogged = true;
                }

                return `
                    <div class="content-card" data-id="${item.id}" data-type="${isTV ? 'tv' : 'movie'}"
                         onclick="playContent(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')">
                        <button type="button" class="watchlist-btn ${isInWatchlist ? 'added' : ''}"
                                onclick="event.stopPropagation(); event.preventDefault(); toggleWatchlist(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}', '${posterUrl}', '${year}', ${item.vote_average || 0}, event); return false;"
                                title="${isInWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
                            ${isInWatchlist ? '' : ''}
                        </button>
                        <div class="content-type-badge ${isTV ? 'tv-badge' : 'movie-badge'}">
                            ${isTV ? 'TV' : 'Movie'}
                        </div>
                        <button class="imdb-btn" onclick="event.stopPropagation(); openImdb(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')" title="View on IMDb">
                            IMDb
                        </button>
                        ${progressBarHtml}
                        <img src="${posterUrl}" alt="${itemTitle}" class="content-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="content-info">
                            <div class="content-title">${itemTitle}</div>
                            <div class="content-year">${year}</div>
                            <div class="content-genres">${genreDisplay}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function appendContent(items) {
            const resultsDiv = document.getElementById('contentResults');

            if (!items || items.length === 0) {
                hasMorePages = false;
                return;
            }

            const newItems = items.map(item => {
                const posterUrl = item.poster_url || 'https://via.placeholder.com/200x300/333/fff?text=No+Poster';
                const isTV = item.content_type === 'tv' || item.media_type === 'tv' || item.name;
                const itemTitle = isTV ? (item.name || item.title) : (item.title || item.name);
                const year = isTV ?
                    (item.first_air_date ? item.first_air_date.substring(0, 4) : 'Unknown') :
                    (item.release_date ? item.release_date.substring(0, 4) : 'Unknown');
                const rating = item.vote_average ? item.vote_average.toFixed(1) : 'N/A';

                const isInWatchlist = isItemInWatchlist(item.id, isTV ? 'tv' : 'movie');

                // Get genre names from genre_ids
                const genreNames = getGenreNames(item.genre_ids || [], isTV);
                const genreDisplay = genreNames.length > 0 ? genreNames.join('  ') : 'Genre not available';

                // Get watch progress for this item
                const watchProgress = getWatchProgress(item.id, isTV ? 'tv' : 'movie');
                const progressBarHtml = watchProgress > 0 ? `
                    <div class="card-progress-bar">
                        <div class="card-progress-fill" style="width: ${watchProgress}%"></div>
                    </div>
                ` : '';

                // Get rating and runtime if available
                // Debug: log to see what fields are available
                if (!window._itemFieldsLogged) {
                    console.log('Item fields:', Object.keys(item));
                    console.log('Sample item:', item);
                    window._itemFieldsLogged = true;
                }

                return `
                    <div class="content-card" data-id="${item.id}" data-type="${isTV ? 'tv' : 'movie'}"
                         onclick="playContent(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')">
                        <button type="button" class="watchlist-btn ${isInWatchlist ? 'added' : ''}"
                                onclick="event.stopPropagation(); event.preventDefault(); toggleWatchlist(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}', '${posterUrl}', '${year}', ${item.vote_average || 0}, event); return false;"
                                title="${isInWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
                            ${isInWatchlist ? '' : ''}
                        </button>
                        <div class="content-type-badge ${isTV ? 'tv-badge' : 'movie-badge'}">
                            ${isTV ? 'TV' : 'Movie'}
                        </div>
                        <button class="imdb-btn" onclick="event.stopPropagation(); openImdb(${item.id}, '${itemTitle.replace(/'/g, "\\'")}', '${isTV ? 'tv' : 'movie'}')" title="View on IMDb">
                            IMDb
                        </button>
                        ${progressBarHtml}
                        <img src="${posterUrl}" alt="${itemTitle}" class="content-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="content-info">
                            <div class="content-title">${itemTitle}</div>
                            <div class="content-year">${year}</div>
                            <div class="content-genres">${genreDisplay}</div>
                        </div>
                    </div>
                `;
            }).join('');

            resultsDiv.insertAdjacentHTML('beforeend', newItems);
        }

        // Infinite scroll detection
        function setupInfiniteScroll() {
            let scrollTimeout;

            const scrollHandler = () => {
                // Clear any pending scroll checks
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }

                // Debounce scroll events
                scrollTimeout = setTimeout(() => {
                    // Only load more if we're in a popular/trending category
                    const validCategories = ['popular-movies', 'popular-tv', 'trending-movies', 'trending-tv'];
                    if (!validCategories.includes(currentCategory)) {
                        return;
                    }

                    // Check if we're near the bottom of the page
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const scrollHeight = document.documentElement.scrollHeight;
                    const clientHeight = window.innerHeight;

                    // Only trigger if scrolled near bottom (300px threshold) and not already loading
                    if (scrollHeight - scrollTop - clientHeight < 300 && !isLoadingMore && hasMorePages) {
                        isLoadingMore = true;
                        currentPage++;

                        // Load more based on current category
                        if (currentCategory === 'popular-movies') {
                            loadPopularMovies(currentPage, true);
                        } else if (currentCategory === 'popular-tv') {
                            loadPopularTVShows(currentPage, true);
                        } else if (currentCategory === 'trending-movies') {
                            loadTrendingMovies(currentPage, true);
                        } else if (currentCategory === 'trending-tv') {
                            loadTrendingTVShows(currentPage, true);
                        }
                    }
                }, 100); // 100ms debounce
            };

            window.addEventListener('scroll', scrollHandler);
        }

        async function playContent(contentId, contentTitle, contentType) {

            hideError();

            // Clear old ratings immediately to prevent showing wrong data
            clearRatingsUI();
            __earlyLastRefreshedContentId = null;

            // Clear episode description from previous content
            const epDescSection = document.getElementById('episodeDescription');
            const epDescText = document.getElementById('episodeDescriptionText');
            if (epDescSection) epDescSection.style.display = 'none';
            if (epDescText) epDescText.textContent = '';

            // Scroll to poster/player section immediately
            const standalonePoster = document.getElementById('currentPoster');
            if (standalonePoster && standalonePoster.style.display !== 'none') {
                standalonePoster.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                const playerSection = document.querySelector('.player-section');
                if (playerSection) {
                    playerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }

            try {
                // If comments section is open and we're switching content, restart polling
                const commentsSection = document.getElementById('commentsSection');
                const commentsWereVisible = commentsSection && commentsSection.style.display === 'block';

                currentContentId = contentId;
                currentContentType = contentType;

                // Restart comments polling if comments were visible
                if (commentsWereVisible && authToken) {
                    if (commentsPollingInterval) {
                        clearInterval(commentsPollingInterval);
                    }
                    commentsPollingInterval = setInterval(() => {
                        displayComments(contentId);
                    }, 30000);
                    // Refresh comments immediately for new content
                    displayComments(contentId);
                }

                let endpoint;
                if (contentType === 'tv') {
                    endpoint = `${API_BASE_URL}/tv/${contentId}`;
                } else {
                    endpoint = `${API_BASE_URL}/movie/${contentId}`;
                }

                const response = await fetch(endpoint);
                const data = await response.json();

                // If content not found, try the opposite type
                if (data.error && (data.error.includes('not found') || data.error.includes('404'))) {
                    console.log(`Content not found as ${contentType}, trying opposite type...`);
                    const oppositeType = contentType === 'tv' ? 'movie' : 'tv';
                    const oppositeEndpoint = oppositeType === 'tv' ? `${API_BASE_URL}/tv/${contentId}` : `${API_BASE_URL}/movie/${contentId}`;

                    const oppositeResponse = await fetch(oppositeEndpoint);
                    const oppositeData = await oppositeResponse.json();

                    if (oppositeData.error) {
                        throw new Error(`Content with ID ${contentId} not found as movie or TV show.`);
                    }

                    // Update content type to the correct one
                    currentContentType = oppositeType;
                    currentContentData = oppositeData;
                    console.log(`Found content as ${oppositeType} instead.`);
                } else if (data.error) {
                    throw new Error(data.error);
                } else {
                    currentContentData = data;
                }

                // Update current content display
                const currentContent = document.getElementById('currentContent');
                const tvControls = document.getElementById('tvControls');

                const titleEl = document.getElementById('currentTitle');
                const yearEl = document.getElementById('currentYear');
                const ratingEl = document.getElementById('currentRating');
                const overviewEl = document.getElementById('currentOverview');

                if (titleEl) titleEl.textContent = currentContentType === 'tv' ? currentContentData.name : currentContentData.title;
                if (yearEl) yearEl.textContent = currentContentType === 'tv' ?
                    (currentContentData.first_air_date ? currentContentData.first_air_date.substring(0, 4) : 'Unknown') :
                    (currentContentData.release_date ? currentContentData.release_date.substring(0, 4) : 'Unknown');
                if (ratingEl) ratingEl.textContent = ` ${currentContentData.vote_average ? currentContentData.vote_average.toFixed(1) : 'N/A'}/10`;
                if (overviewEl) overviewEl.textContent = currentContentData.overview || 'No description available';

                const posterEl = document.getElementById('currentPoster');
                if (posterEl) {
                    if (currentContentData.poster_url) {
                        posterEl.src = currentContentData.poster_url;
                        posterEl.style.display = 'block';
                    } else {
                        posterEl.style.display = 'none';
                    }
                }

                // Load backdrop image
                const backdropEl = document.getElementById('backdropImage');
                console.log('Backdrop element:', backdropEl);
                console.log('Backdrop URL:', currentContentData.backdrop_url);
                if (backdropEl && currentContentData.backdrop_url) {
                    backdropEl.style.backgroundImage = `url(${currentContentData.backdrop_url})`;
                    backdropEl.classList.add('loaded');
                    console.log('Backdrop loaded:', backdropEl.style.backgroundImage);
                } else if (backdropEl) {
                    backdropEl.style.backgroundImage = '';
                    backdropEl.classList.remove('loaded');
                    console.log('Backdrop cleared or not available');
                }

                // Populate OMDB data if available
                const omdbRatingsEl = document.getElementById('omdbRatings');
                const omdbDetailsEl = document.getElementById('omdbDetails');

                if (omdbRatingsEl && currentContentData.omdb_ratings && currentContentData.omdb_ratings.length > 0) {
                    // Parse ratings
                    const imdbRating = currentContentData.omdb_imdb_rating || 'N/A';
                    let rtRating = 'N/A';
                    let metacriticRating = 'N/A';

                    currentContentData.omdb_ratings.forEach(rating => {
                        if (rating.Source === 'Rotten Tomatoes') {
                            rtRating = rating.Value;
                        } else if (rating.Source === 'Metacritic') {
                            metacriticRating = rating.Value;
                        }
                    });

                    const imdbEl = document.getElementById('imdbRating');
                    const rtEl = document.getElementById('rtRating');
                    const metacriticEl = document.getElementById('metacriticRating');

                    if (imdbEl) imdbEl.textContent = imdbRating;
                    if (rtEl) rtEl.textContent = rtRating;
                    if (metacriticEl) metacriticEl.textContent = metacriticRating;
                    omdbRatingsEl.style.display = 'flex';
                } else if (omdbRatingsEl) {
                    omdbRatingsEl.style.display = 'none';
                }

                // Populate OMDB details if available
                if (omdbDetailsEl && (currentContentData.tmdb_cast || currentContentData.omdb_actors || currentContentData.omdb_director || currentContentData.omdb_genre || currentContentData.omdb_rated || currentContentData.omdb_runtime || currentContentData.omdb_awards)) {
                    const actorsEl = document.getElementById('omdbActors');
                    const castSection = document.getElementById('castSection');
                    const castGrid = document.getElementById('castGrid');
                    const directorEl = document.getElementById('omdbDirector');
                    const genreEl = document.getElementById('omdbGenre');
                    const ratedEl = document.getElementById('omdbRated');
                    const runtimeEl = document.getElementById('omdbRuntime');
                    const awardsEl = document.getElementById('omdbAwards');

                    // Display TMDB cast with images if available
                    if (castSection && castGrid && currentContentData.tmdb_cast && currentContentData.tmdb_cast.length > 0) {
                        castGrid.innerHTML = '';
                        currentContentData.tmdb_cast.forEach(actor => {
                            const castMember = document.createElement('div');
                            castMember.className = 'cast-member';

                            if (actor.profile_url) {
                                const img = document.createElement('img');
                                img.src = actor.profile_url;
                                img.alt = actor.name;
                                img.className = 'cast-member-image';
                                castMember.appendChild(img);
                            } else {
                                const placeholder = document.createElement('div');
                                placeholder.className = 'cast-member-image placeholder';
                                placeholder.textContent = actor.name.charAt(0);
                                castMember.appendChild(placeholder);
                            }

                            const nameDiv = document.createElement('div');
                            nameDiv.className = 'cast-member-name';
                            nameDiv.textContent = actor.name;
                            nameDiv.title = actor.name;
                            castMember.appendChild(nameDiv);

                            if (actor.character) {
                                const characterDiv = document.createElement('div');
                                characterDiv.className = 'cast-member-character';
                                characterDiv.textContent = actor.character;
                                characterDiv.title = actor.character;
                                castMember.appendChild(characterDiv);
                            }

                            castGrid.appendChild(castMember);
                        });
                        castSection.style.display = 'block';
                        actorsEl.style.display = 'none';
                    } else if (actorsEl && currentContentData.omdb_actors) {
                        // Fallback to OMDB text if no TMDB cast
                        const span = actorsEl.querySelector('span');
                        if (span) span.textContent = currentContentData.omdb_actors;
                        actorsEl.style.display = 'block';
                        if (castSection) castSection.style.display = 'none';
                    } else {
                        if (actorsEl) actorsEl.style.display = 'none';
                        if (castSection) castSection.style.display = 'none';
                    }

                    if (directorEl) {
                        if (currentContentData.omdb_director && currentContentData.omdb_director !== 'N/A') {
                            const span = directorEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_director;
                            directorEl.style.display = 'block';
                        } else {
                            directorEl.style.display = 'none';
                        }
                    }

                    if (genreEl) {
                        if (currentContentData.omdb_genre) {
                            const span = genreEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_genre;
                            genreEl.style.display = 'block';
                        } else {
                            genreEl.style.display = 'none';
                        }
                    }

                    if (ratedEl) {
                        if (currentContentData.omdb_rated && currentContentData.omdb_rated !== 'N/A') {
                            const span = ratedEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_rated;
                            ratedEl.style.display = 'block';
                        } else {
                            ratedEl.style.display = 'none';
                        }
                    }

                    if (runtimeEl) {
                        if (currentContentData.omdb_runtime) {
                            const span = runtimeEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_runtime;
                            runtimeEl.style.display = 'block';
                        } else {
                            runtimeEl.style.display = 'none';
                        }
                    }

                    if (awardsEl) {
                        if (currentContentData.omdb_awards && currentContentData.omdb_awards !== 'N/A') {
                            const span = awardsEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_awards;
                            awardsEl.style.display = 'block';
                        } else {
                            awardsEl.style.display = 'none';
                        }
                    }

                    omdbDetailsEl.style.display = 'block';
                } else if (omdbDetailsEl) {
                    omdbDetailsEl.style.display = 'none';
                }

                currentContent.style.display = 'flex';

                // Initialize player background effects
                // initPlayerBackgroundEffects();

                // Show the player section
                document.getElementById('playerSection').style.display = 'block';

                // Check if there's existing watch progress
                const existingProgress = watchHistory.find(
                    item => item.id === contentId && item.type === currentContentType
                );

                if (currentContentType === 'tv') {
                    // Setup TV show controls
                    tvControls.style.display = 'block';
                    await setupSeasonEpisodeSelectors(currentContentData);

                    // If there's progress and it's a TV show, resume from last episode
                    if (existingProgress && existingProgress.progress > 5 && existingProgress.progress < 95) {
                        const resumeSeason = existingProgress.season || 1;
                        const resumeEpisode = existingProgress.episode || 1;


                        // Set current season and episode to resume position
                        currentSelectedSeason = resumeSeason;
                        currentSelectedEpisode = resumeEpisode;
                        document.getElementById('seasonButtonText').textContent = `Season ${resumeSeason}`;
                        await updateEpisodeSelector(resumeSeason);
                        document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(resumeEpisode, resumeSeason);

                        playTVEpisode(contentId, resumeSeason, resumeEpisode);
                    } else {
                        playTVEpisode(contentId, 1, 1);
                    }
                } else {
                    // Play movie
                    tvControls.style.display = 'none';

                    // Hide next episode button for movies
                    const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
                    if (nextEpisodeBtn) nextEpisodeBtn.style.display = 'none';

                    if (existingProgress && existingProgress.progress > 5 && existingProgress.progress < 95) {
                    }

                    playMovie(contentId);
                }

                // Add to watch history
                addToWatchHistory(contentId, contentTitle, contentType, data);

                // Update player watchlist button
                updatePlayerWatchlistButton(contentId, currentContentType);

                // Update video source button
                updateVideoSourceButton();

                // Refresh user ratings UI to show friends' ratings
                setTimeout(() => {
                    setupUserRatingsPill();
                }, 500);

            } catch (error) {
                console.error('Play content error:', error);
                showError(`Failed to load content: ${error.message}`);
            }
        }

        function updatePlayerWatchlistButton(id, type) {
            const btn = document.getElementById('playerWatchlistBtn');
            const icon = document.getElementById('playerWatchlistIcon');

            if (!btn || !icon) return;

            // Check if in any watchlist
            const inLists = Object.keys(watchlists).filter(listName =>
                watchlists[listName].some(item => item.id === id && item.type === type)
            );

            btn.style.display = 'flex';

            if (inLists.length > 0) {
                icon.src = 'Icons/heart-filled.png';
                btn.title = `In ${inLists.length} Watchlist(s)`;
            } else {
                icon.src = 'Icons/heart-nofill.png';
                btn.title = 'Add to Watchlist';
            }
        }

        window.togglePlayerWatchlist = function() {
            if (!currentContentId || !currentContentType) return;

            const panel = document.getElementById('watchlistPanel');
            if (!panel) {
                console.error('Watchlist panel not found');
                return;
            }

            const isVisible = panel.classList.contains('active');

            if (isVisible) {
                panel.classList.remove('active');
                setTimeout(() => { panel.style.display = 'none'; }, 250);
            } else {
                // Get poster URL and other data from currentContentData
                const posterUrl = currentContentData?.poster_url || '';
                const year = currentContentType === 'tv' ?
                    (currentContentData?.first_air_date ? currentContentData.first_air_date.substring(0, 4) : '') :
                    (currentContentData?.release_date ? currentContentData.release_date.substring(0, 4) : '');
                const rating = currentContentData?.vote_average || 0;
                const title = currentContentType === 'tv' ? currentContentData?.name : currentContentData?.title;

                // Store current item data
                window.pendingWatchlistPanelItem = {
                    id: currentContentId,
                    title: title,
                    type: currentContentType,
                    posterUrl: posterUrl,
                    year: year,
                    rating: rating,
                    addedAt: new Date().toISOString()
                };

                // Check if item is in any watchlist
                const inLists = Object.keys(watchlists).filter(listName =>
                    watchlists[listName].some(item => item.id === currentContentId && item.type === currentContentType)
                );

                // Update panel content
                updateWatchlistPanel(inLists);

                // Reset to absolute positioning (may have been changed to fixed by search)
                panel.style.position = 'absolute';

                // Position panel below the watchlist button
                const watchlistButton = document.getElementById('playerWatchlistBtn');
                if (!watchlistButton) {
                    console.error('Watchlist button not found');
                    return;
                }

                const rect = watchlistButton.getBoundingClientRect();

                // Calculate position - ensure it's within viewport
                let top = rect.bottom + window.scrollY + 8;
                let left = rect.left + window.scrollX;

                // Adjust if too close to right edge
                const panelWidth = 360;
                if (left + panelWidth > window.innerWidth) {
                    left = rect.right + window.scrollX - panelWidth;
                }

                panel.style.top = `${top}px`;
                panel.style.left = `${left}px`;
                panel.style.display = 'flex';
                requestAnimationFrame(() => {
                    panel.classList.add('active');
                });
            }
        }

        function updateWatchlistPanel(inLists) {
            const panel = document.getElementById('watchlistPanel');
            const title = document.getElementById('watchlistPanelTitle');
            const list = document.getElementById('watchlistPanelList');
            const createSection = document.getElementById('watchlistPanelCreate');

            if (inLists.length > 0) {
                // Item is in watchlists - show removal options
                title.textContent = 'Remove from Watchlist';
                createSection.style.display = 'none';

                list.innerHTML = inLists.map(listName => `
                    <div onclick="removeFromWatchlistPanel('${listName.replace(/'/g, "\\'")}'); event.stopPropagation();"
                            class="player-watchlist-list-card remove-card">
                        <div class="player-watchlist-list-icon"></div>
                        <span class="player-watchlist-list-name">${listName}</span>
                        <span class="player-watchlist-list-arrow"></span>
                    </div>
                `).join('');
            } else {
                // Item not in any watchlist - show add options
                title.textContent = 'Add to Watchlist';
                createSection.style.display = 'block';

                const listNames = Object.keys(watchlists);
                if (listNames.length === 0) {
                    watchlists['My Watchlist'] = [];
                    localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
                }

                list.innerHTML = Object.keys(watchlists).map(listName => `
                    <div onclick="addToWatchlistPanel('${listName.replace(/'/g, "\\'")}'); event.stopPropagation();"
                            class="player-watchlist-list-card">
                        <div class="player-watchlist-list-icon"></div>
                        <span class="player-watchlist-list-name">${listName}</span>
                        <span class="player-watchlist-list-arrow"></span>
                    </div>
                `).join('');
            }
        }

        async function addToWatchlistPanel(listName) {
            console.log('[addToWatchlistPanel] Called with listName:', listName);
            const item = window.pendingWatchlistPanelItem;
            console.log('[addToWatchlistPanel] Item:', item);
            console.log('[addToWatchlistPanel] authToken:', authToken ? 'exists' : 'null');

            if (!item) {
                console.log('[addToWatchlistPanel] No item, returning');
                return;
            }

            // Require authentication - no localStorage fallback
            if (!authToken) {
                showError('Please login to use watchlist');
                showLoginModal();
                const panel = document.getElementById('watchlistPanel');
                if (panel) panel.style.display = 'none';
                window.pendingWatchlistPanelItem = null;
                return;
            }

            // Save to database only
            console.log('[addToWatchlistPanel] User authenticated, calling API with list:', listName);
            try {
                await addToWatchlistAPI(item.id, item.type, item.title, item.posterUrl, listName);
                console.log('[addToWatchlistPanel] API call successful');
            } catch (error) {
                console.error('[addToWatchlistPanel] API call failed:', error);
                showError('Failed to add to watchlist');
            }

            // Update heart icon in search results if applicable
            refreshSearchResultHearts();

            // Close panel with animation
            const panel = document.getElementById('watchlistPanel');
            if (panel) {
                panel.classList.remove('active');
                setTimeout(() => { panel.style.display = 'none'; }, 250);
            }
            window.pendingWatchlistPanelItem = null;
        }

        async function removeFromWatchlistPanel(listName) {
            const item = window.pendingWatchlistPanelItem;
            if (!item) return;

            // Require authentication - no localStorage fallback
            if (!authToken) {
                showError('Please login to use watchlist');
                showLoginModal();
                const panel = document.getElementById('watchlistPanel');
                if (panel) {
                    panel.classList.remove('active');
                    setTimeout(() => { panel.style.display = 'none'; }, 250);
                }
                window.pendingWatchlistPanelItem = null;
                return;
            }

            // Remove from database only
            try {
                await removeFromWatchlistAPI(item.id);
            } catch (error) {
                showError('Failed to remove from watchlist');
            }

            // Update heart icon in search results if applicable
            refreshSearchResultHearts();

            // Close panel with animation
            const panel = document.getElementById('watchlistPanel');
            if (panel) {
                panel.classList.remove('active');
                setTimeout(() => { panel.style.display = 'none'; }, 250);
            }
            window.pendingWatchlistPanelItem = null;
        }

        function refreshSearchResultHearts() {
            const resultsDiv = document.getElementById('floatingSearchResults');
            if (!resultsDiv) return;
            const heartBtns = resultsDiv.querySelectorAll('.floating-search-watchlist-btn');
            heartBtns.forEach(btn => {
                const onclick = btn.getAttribute('onclick');
                if (!onclick) return;
                const match = onclick.match(/toggleSearchResultWatchlist\((\d+),\s*'([^']+)'/);
                if (!match) return;
                const id = parseInt(match[1]);
                const type = match[2];
                const inWatchlist = typeof isItemInWatchlist === 'function' && isItemInWatchlist(id, type);
                const img = btn.querySelector('img');
                if (img) {
                    img.src = inWatchlist ? 'Icons/heart-filled.png' : 'Icons/heart-nofill.png';
                }
                btn.title = inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist';
            });
        }

        function createWatchlistFromPanel() {
            const input = document.getElementById('newWatchlistNamePanel');
            const listName = input.value.trim();

            if (!listName) {
                showError('Please enter a watchlist name');
                return;
            }

            // Require authentication
            if (!authToken) {
                showError('Please login to create watchlists');
                showLoginModal();
                return;
            }

            if (watchlists[listName]) {
                showError('Watchlist already exists');
                return;
            }

            // Create list in memory (will be saved to DB when first item is added)
            watchlists[listName] = [];
            input.value = '';


            // Add current item to the new list
            if (window.pendingWatchlistPanelItem) {
                addToWatchlistPanel(listName);
            } else {
                // Just refresh the panel
                updateWatchlistPanel([]);
            }
        }

        let currentSeasons = [];
        let currentSelectedSeason = 1;
        let currentSelectedEpisode = 1;

        async function setupSeasonEpisodeSelectors(tvData) {
            // Store seasons data
            currentSeasons = tvData.seasons ? tvData.seasons.filter(s => s.season_number > 0) : [];

            // Set first season as default
            if (currentSeasons.length > 0) {
                currentSelectedSeason = currentSeasons[0].season_number;
                document.getElementById('seasonButtonText').textContent = `Season ${currentSelectedSeason}`;
                await updateEpisodeSelector(currentSelectedSeason);
            }
        }

        function closePanelAnimated(panel) {
            if (!panel) return;
            panel.classList.add('panel-closing');
            panel.classList.remove('panel-visible');
            setTimeout(() => {
                panel.style.display = 'none';
                panel.classList.remove('panel-closing');
            }, 250);
        }

        function openPanelAnimated(panel) {
            if (!panel) return;
            panel.style.display = 'flex';
            panel.classList.remove('panel-closing');
            requestAnimationFrame(() => {
                panel.classList.add('panel-visible');
            });
        }

        window.toggleSeasonPanel = function() {
            const panel = document.getElementById('seasonPanel');
            const episodePanel = document.getElementById('episodePanel');

            if (panel) {
                const isVisible = panel.style.display === 'flex' && panel.classList.contains('panel-visible');

                if (isVisible) {
                    closePanelAnimated(panel);
                } else {
                    // Close episode panel if open
                    if (episodePanel && episodePanel.style.display === 'flex') closePanelAnimated(episodePanel);

                    // Position panel below the season button
                    const seasonButton = document.getElementById('seasonButton');
                    const rect = seasonButton.getBoundingClientRect();
                    panel.style.top = `${rect.bottom + window.scrollY + 8}px`;
                    panel.style.left = `${rect.left + window.scrollX}px`;
                    openPanelAnimated(panel);

                    // Populate seasons
                    const seasonList = document.getElementById('seasonList');
                    seasonList.innerHTML = '';

                    currentSeasons.forEach(season => {
                        const button = document.createElement('button');
                        button.className = 'effects-btn';
                        button.textContent = `Season ${season.season_number}`;
                        button.onclick = () => selectSeason(season.season_number);
                        seasonList.appendChild(button);
                    });
                }
            }
        }

        async function selectSeason(seasonNumber) {
            currentSelectedSeason = seasonNumber;
            document.getElementById('seasonButtonText').textContent = `Season ${seasonNumber}`;

            // Close panel with animation
            const panel = document.getElementById('seasonPanel');
            if (panel) closePanelAnimated(panel);

            await updateEpisodeSelector(seasonNumber);
        }

        window.toggleEpisodePanel = function() {
            const panel = document.getElementById('episodePanel');
            const seasonPanel = document.getElementById('seasonPanel');

            if (panel) {
                const isVisible = panel.style.display === 'flex' && panel.classList.contains('panel-visible');

                if (isVisible) {
                    closePanelAnimated(panel);
                } else {
                    // Close season panel if open
                    if (seasonPanel && seasonPanel.style.display === 'flex') closePanelAnimated(seasonPanel);

                    // Position panel below the episode button
                    const episodeButton = document.getElementById('episodeButton');
                    const rect = episodeButton.getBoundingClientRect();
                    panel.style.top = `${rect.bottom + window.scrollY + 8}px`;
                    panel.style.left = `${rect.left + window.scrollX}px`;
                    openPanelAnimated(panel);
                }
            }
        }

        // Helper function to format episode button text
        function getEpisodeButtonText(episodeNumber, seasonNumber = currentSelectedSeason) {
            const cacheKey = `${currentContentId}_${seasonNumber}`;
            const seasonData = episodeCache[cacheKey];

            if (seasonData && seasonData.episodes) {
                const episode = seasonData.episodes.find(ep => ep.episode_number === episodeNumber);
                if (episode) {
                    const episodeName = episode.name || 'Untitled';
                    let ratingParts = [];

                    if (episode.omdb_imdb_rating && episode.omdb_imdb_rating !== 'N/A') {
                        ratingParts.push(`IMDb ${episode.omdb_imdb_rating}`);
                    }
                    if (episode.omdb_ratings && Array.isArray(episode.omdb_ratings)) {
                        const rtRating = episode.omdb_ratings.find(r => r.Source === 'Rotten Tomatoes');
                        if (rtRating && rtRating.Value) {
                            ratingParts.push(`RT ${rtRating.Value}`);
                        }
                    }

                    let buttonText = `E${episodeNumber}: ${episodeName}`;
                    if (ratingParts.length > 0) {
                        buttonText += ` (${ratingParts.join(', ')})`;
                    }
                    return buttonText;
                }
            }

            // Fallback
            return `Episode ${episodeNumber}`;
        }

        function selectEpisode(episodeNumber, episodeTitle, episodeRating = null, episodeOverview = null) {
            currentSelectedEpisode = episodeNumber;

            // Build episode button text with title and rating
            let buttonText = `E${episodeNumber}: ${episodeTitle || `Episode ${episodeNumber}`}`;
            if (episodeRating) {
                buttonText += ` (${episodeRating})`;
            }

            document.getElementById('episodeButtonText').textContent = buttonText;

            // Update episode description
            const descriptionSection = document.getElementById('episodeDescription');
            const descriptionText = document.getElementById('episodeDescriptionText');

            if (episodeOverview && episodeOverview.trim() !== '') {
                descriptionText.textContent = episodeOverview;
                descriptionSection.style.display = 'block';
            } else {
                descriptionSection.style.display = 'none';
            }

            // Close panel with animation
            const panel = document.getElementById('episodePanel');
            if (panel) closePanelAnimated(panel);

            if (currentContentId) {
                playTVEpisode(currentContentId, currentSelectedSeason, episodeNumber);
            }
        }

        async function updateEpisodeSelector(seasonNumber) {
            const episodeList = document.getElementById('episodeList');
            episodeList.innerHTML = '<div style="text-align: center; color: var(--primary-color, #00ff9f); padding: 20px;">Loading episodes...</div>';

            try {
                // Check cache first
                const cacheKey = `${currentContentId}_${seasonNumber}`;
                let seasonData;

                if (episodeCache[cacheKey]) {
                    // Use cached data (already has ratings)
                    seasonData = episodeCache[cacheKey];
                } else {
                    // Fetch episode details from TMDB WITHOUT ratings for fast display
                    const response = await fetch(`${API_BASE_URL}/tv/${currentContentId}/season/${seasonNumber}?quick=true`);
                    seasonData = await response.json();

                    // Don't cache quick data - we'll cache the full data with ratings later
                }

                episodeList.innerHTML = '';

                if (seasonData.episodes && seasonData.episodes.length > 0) {
                    // Display all episodes immediately WITHOUT ratings
                    const episodeButtons = {};

                    seasonData.episodes.forEach(episode => {
                        const button = document.createElement('button');
                        button.className = 'effects-btn';

                        const episodeNum = `E${episode.episode_number}`;
                        const episodeName = episode.name || 'Untitled';

                        // Initially display without ratings
                        button.textContent = `${episodeNum}: ${episodeName}`;
                        button.style.textAlign = 'left';
                        button.setAttribute('data-episode-num', episode.episode_number);
                        button.onclick = () => selectEpisode(episode.episode_number, episodeName, null, episode.overview);

                        episodeList.appendChild(button);
                        episodeButtons[episode.episode_number] = button;
                    });

                    // Set episode info - use currentSelectedEpisode if it exists in this season, otherwise first episode
                    const targetEp = seasonData.episodes.find(e => e.episode_number === currentSelectedEpisode) || seasonData.episodes[0];
                    if (targetEp) {
                        currentSelectedEpisode = targetEp.episode_number;

                        document.getElementById('episodeButtonText').textContent = `E${targetEp.episode_number}: ${targetEp.name || 'Untitled'}`;

                        // Update episode description
                        const descriptionSection = document.getElementById('episodeDescription');
                        const descriptionText = document.getElementById('episodeDescriptionText');

                        if (targetEp.overview && targetEp.overview.trim() !== '') {
                            descriptionText.textContent = targetEp.overview;
                            descriptionSection.style.display = 'block';
                        } else {
                            descriptionSection.style.display = 'none';
                        }
                    }

                    // Now lazy load ratings for each episode in the background
                    if (!episodeCache[cacheKey]) {
                        // Only fetch ratings if not already cached
                        loadEpisodeRatingsInBackground(seasonNumber, seasonData.episodes, episodeButtons);
                    }
                } else {
                    // Fallback to simple numbering if API fails
                    const selectedSeason = currentContentData?.seasons?.find(s => s.season_number == seasonNumber);
                    const episodeCount = selectedSeason?.episode_count || 10;

                    for (let i = 1; i <= episodeCount; i++) {
                        const button = document.createElement('button');
                        button.className = 'effects-btn';
                        button.textContent = `Episode ${i}`;
                        button.onclick = () => selectEpisode(i, `Episode ${i}`);
                        episodeList.appendChild(button);
                    }

                    if (currentSelectedEpisode === 1 || !currentSelectedEpisode) {
                        currentSelectedEpisode = 1;
                        document.getElementById('episodeButtonText').textContent = 'Episode 1';
                    }
                }
            } catch (error) {
                console.error('Error fetching episodes:', error);

                // Fallback to simple numbering
                const selectedSeason = currentContentData?.seasons?.find(s => s.season_number == seasonNumber);
                const episodeCount = selectedSeason?.episode_count || 10;

                episodeList.innerHTML = '';
                for (let i = 1; i <= episodeCount; i++) {
                    const button = document.createElement('button');
                    button.className = 'effects-btn';
                    button.textContent = `Episode ${i}`;
                    button.onclick = () => selectEpisode(i, `Episode ${i}`);
                    episodeList.appendChild(button);
                }

                if (currentSelectedEpisode === 1 || !currentSelectedEpisode) {
                    currentSelectedEpisode = 1;
                    document.getElementById('episodeButtonText').textContent = 'Episode 1';
                }
            }
        }

        async function loadEpisodeRatingsInBackground(seasonNumber, episodes, episodeButtons) {
            // Fetch ratings for each episode individually
            const ratingPromises = episodes.map(async (episode) => {
                try {
                    const response = await fetch(
                        `${API_BASE_URL}/tv/${currentContentId}/season/${seasonNumber}/episode/${episode.episode_number}/rating`
                    );
                    const ratingData = await response.json();

                    if (ratingData.imdb_rating && ratingData.imdb_rating !== 'N/A') {
                        // Update the episode button with rating
                        const button = episodeButtons[episode.episode_number];
                        if (button) {
                            const episodeNum = `E${episode.episode_number}`;
                            const episodeName = episode.name || 'Untitled';

                            let ratingParts = [];
                            ratingParts.push(`IMDb ${ratingData.imdb_rating}`);

                            if (ratingData.ratings && Array.isArray(ratingData.ratings)) {
                                const rtRating = ratingData.ratings.find(r => r.Source === 'Rotten Tomatoes');
                                if (rtRating && rtRating.Value) {
                                    ratingParts.push(`RT ${rtRating.Value}`);
                                }
                            }

                            const displayRating = ` (${ratingParts.join(', ')})`;
                            button.textContent = `${episodeNum}: ${episodeName}${displayRating}`;

                            // Update the onclick to include rating text
                            const ratingText = ratingParts.join(', ');
                            button.onclick = () => selectEpisode(episode.episode_number, episodeName, ratingText, episode.overview);
                        }

                        // Also update the selected episode button text if it's the current episode
                        if (episode.episode_number === currentSelectedEpisode) {
                            const episodeButtonText = document.getElementById('episodeButtonText');
                            if (episodeButtonText) {
                                const episodeNum = `E${episode.episode_number}`;
                                const episodeName = episode.name || 'Untitled';
                                let ratingParts = [];
                                ratingParts.push(`IMDb ${ratingData.imdb_rating}`);
                                if (ratingData.ratings && Array.isArray(ratingData.ratings)) {
                                    const rtRating = ratingData.ratings.find(r => r.Source === 'Rotten Tomatoes');
                                    if (rtRating && rtRating.Value) {
                                        ratingParts.push(`RT ${rtRating.Value}`);
                                    }
                                }
                                episodeButtonText.textContent = `${episodeNum}: ${episodeName} (${ratingParts.join(', ')})`;
                            }
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching rating for episode ${episode.episode_number}:`, error);
                }
            });

            // Wait for all ratings to load, then cache the full season data
            await Promise.all(ratingPromises);

            // Now fetch the full season data with ratings to cache it
            try {
                const response = await fetch(`${API_BASE_URL}/tv/${currentContentId}/season/${seasonNumber}`);
                const fullSeasonData = await response.json();
                const cacheKey = `${currentContentId}_${seasonNumber}`;
                episodeCache[cacheKey] = fullSeasonData;
            } catch (error) {
                console.error('Error caching full season data:', error);
            }
        }

        async function playMovie(movieId, startTime = null) {
            console.log(`[Play Movie] Starting playMovie(${movieId}, startTime: ${startTime})`);
            console.log(`[Play Movie] Current video source: ${videoSource}`);
            console.log(`[Play Movie] Watchparty active: ${watchpartyActive}, Is host: ${isHost}`);

            try {
                const response = await fetch(`${API_BASE_URL}/stream/${movieId}`);
                const data = await response.json();

                console.log('[Play Movie] API Response:', data); // Debug: see full API response

                if (data.error) {
                    throw new Error(data.error);
                }

                // Determine URL and type based on selected video source
                let streamUrl, streamType;
                const tmdbId = currentContentData?.id || movieId;

                if (videoSource === 'superembed') {
                    streamUrl = `${window.location.origin}/se_player.php?video_id=${tmdbId}&tmdb=1`;
                    streamType = 'embed';
                    console.log('SuperEmbed URL:', streamUrl);
                } else if (videoSource === 'vidking') {
                    streamUrl = `https://www.vidking.net/embed/movie/${tmdbId}`;
                    streamType = 'embed';
                    console.log('VidKing URL:', streamUrl);
                } else if (videoSource === 'moviesapi') {
                    streamUrl = `https://moviesapi.club/movie/${tmdbId}`;
                    streamType = 'embed';
                    console.log('MoviesAPI URL:', streamUrl);
                } else {
                    // VidSrc - Use stream extraction from API
                    streamUrl = data.stream_url || data.vidsrc_url;
                    streamType = data.stream_type || 'embed';
                    console.log('VidSrc URL:', streamUrl);
                    console.log('Stream type:', streamType);

                    // Additional check to ensure URL is valid
                    if (!streamUrl) {
                        console.error('No stream URL found in API response');
                        throw new Error('No stream URL available');
                    }
                }

                currentContentUrl = streamUrl;

                // Show the player section
                const playerSection = document.getElementById('playerSection');
                if (playerSection) {
                    playerSection.style.display = 'block';
                }

                // Load with appropriate player (video element for direct, iframe for embed)
                const subtitles = data.subtitles || [];
                loadPlayerContent(streamUrl, startTime, streamType, subtitles);

                // Broadcast content change to watchparty if host
                if (watchpartyActive && isHost && socket) {
                    socket.emit('sync_content', {
                        content: {
                            id: movieId,
                            title: data.title,
                            type: 'movie',
                            stream_url: streamUrl,
                            stream_type: streamType,
                            subtitles: subtitles
                        }
                    });
                }

            } catch (error) {
                console.error('Play movie error:', error);
                showError(`Failed to load movie: ${error.message}`);
            }
        }

        async function playTVEpisode(tvId, season, episode, startTime = null) {
            try {
                const response = await fetch(`${API_BASE_URL}/tv/stream/${tvId}?season=${season}&episode=${episode}`);
                const data = await response.json();

                console.log('API Response:', data); // Debug: see full API response

                if (data.error) {
                    throw new Error(data.error);
                }

                // Determine URL and type based on selected video source
                let streamUrl, streamType;
                const tmdbId = currentContentData?.id || tvId;

                if (videoSource === 'superembed') {
                    streamUrl = `${window.location.origin}/se_player.php?video_id=${tmdbId}&tmdb=1&s=${season}&e=${episode}`;
                    streamType = 'embed';
                    console.log('SuperEmbed URL:', streamUrl);
                } else if (videoSource === 'vidking') {
                    streamUrl = `https://www.vidking.net/embed/tv/${tmdbId}/${season}/${episode}`;
                    streamType = 'embed';
                    console.log('VidKing URL:', streamUrl);
                } else if (videoSource === 'moviesapi') {
                    streamUrl = `https://moviesapi.club/tv/${tmdbId}-${season}-${episode}`;
                    streamType = 'embed';
                    console.log('MoviesAPI URL:', streamUrl);
                } else {
                    // VidSrc - Use stream extraction from API
                    streamUrl = data.stream_url || data.vidsrc_url;
                    streamType = data.stream_type || 'embed';
                    console.log('VidSrc URL:', streamUrl);
                    console.log('Stream type:', streamType);

                    // Additional check to ensure URL is valid
                    if (!streamUrl) {
                        console.error('No stream URL found in API response');
                        throw new Error('No stream URL available');
                    }
                }

                currentContentUrl = streamUrl;

                // Show the player section
                const playerSection = document.getElementById('playerSection');
                if (playerSection) {
                    playerSection.style.display = 'block';
                }

                // Load with appropriate player (video element for direct, iframe for embed)
                const subtitles = data.subtitles || [];
                loadPlayerContent(streamUrl, startTime, streamType, subtitles);

                // Show next episode button and check if there's a next episode
                updateNextEpisodeButton();

                // Update watch history with the current episode
                if (currentContentData && currentContentId) {
                    const title = currentContentData.name || currentContentData.title;
                    addToWatchHistory(currentContentId, title, 'tv', currentContentData, season, episode);
                }

                // Broadcast content change to watchparty if host
                if (watchpartyActive && isHost && socket) {
                    socket.emit('sync_content', {
                        content: {
                            id: tvId,
                            title: data.title,
                            type: 'tv',
                            season: season,
                            episode: episode,
                            stream_url: streamUrl,
                            stream_type: streamType,
                            subtitles: subtitles
                        }
                    });
                }

            } catch (error) {
                console.error('Play TV episode error:', error);
                showError(`Failed to load episode: ${error.message}`);
            }
        }

        // New dropdown-based source selector functions
        window.toggleSourceMenu = function() {
            const dropdown = document.getElementById('sourceMenuDropdown');
            dropdown.classList.toggle('show');

            // Update checkmarks
            updateSourceCheckmarks();

            // Dismiss hint when user clicks source button
            dismissSourceHint();
        }

        function closeSourceMenu() {
            const dropdown = document.getElementById('sourceMenuDropdown');
            dropdown.classList.remove('show');
        }

        function updateSourceCheckmarks() {
            ['vidsrc', 'vidking', 'superembed', 'moviesapi'].forEach(source => {
                const check = document.getElementById(`${source}-check`);
                if (check) {
                    check.style.display = source === videoSource ? 'inline' : 'none';
                }
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const sourceContainer = document.getElementById('sourceMenuContainer');
            const dropdown = document.getElementById('sourceMenuDropdown');
            if (sourceContainer && dropdown && !sourceContainer.contains(event.target)) {
                dropdown.classList.remove('show');
            }
        });

        // Legacy function for compatibility (now uses dropdown)
        window.showSourceSelector = function() {
            toggleSourceMenu();
        }

        // Legacy function for compatibility
        function closeSourceSelector() {
            closeSourceMenu();
        }

        function selectVideoSource(source) {
            // Block source changes during watchparty
            if (partySourceLocked) {
                showStatus('Source is locked to VidKing during watchparty for sync support');
                closeSourceSelector();
                return;
            }

            videoSource = source;
            localStorage.setItem('videoSource', videoSource);
            updateVideoSourceButton();

            // Close modal
            closeSourceSelector();

            // Get current playback position before switching sources
            let currentTime = 0;
            const playerVideo = document.getElementById('playerVideo');
            if (playerVideo && playerVideo.style.display !== 'none' && !isNaN(playerVideo.currentTime)) {
                currentTime = Math.floor(playerVideo.currentTime);
                console.log(`[Source Switch] Preserving playback position: ${currentTime}s`);
            }

            // Reload current content with new source, preserving playback position
            if (currentContentId) {
                if (currentContentType === 'movie') {
                    playMovie(currentContentId, currentTime);
                } else if (currentContentType === 'tv' && currentSelectedSeason && currentSelectedEpisode) {
                    playTVEpisode(currentContentId, currentSelectedSeason, currentSelectedEpisode, currentTime);
                }
            }

            const sourceNames = {
                'vidsrc': 'VidSrc',
                'vidking': 'VidKing',
                'superembed': 'SuperEmbed',
                'moviesapi': 'MoviesAPI'
            };

            // Show different message if in watchparty
            if (watchpartyActive) {
                // showStatus(`Switched to ${sourceNames[source]} (only affects your view)`);
            } else {
                // showStatus(`Switched to ${sourceNames[source]}`);
            }
        }

        function updateVideoSourceButton() {
            const container = document.getElementById('sourceMenuContainer');
            const btnText = document.getElementById('videoSourceBtnText');

            if (!container || !btnText) return;

            // Show container when content is loaded
            container.style.display = 'inline-block';

            // Update text to show current source
            const sourceNames = {
                'vidsrc': 'VidSrc',
                'vidking': 'VidKing',
                'superembed': 'SuperEmbed',
                'moviesapi': 'MoviesAPI'
            };
            if (partySourceLocked) {
                btnText.textContent = 'Source: VidKing (Party)';
            } else {
                btnText.textContent = `Source: ${sourceNames[videoSource] || 'VidSrc'}`;
            }

            // Update checkmarks
            updateSourceCheckmarks();

            // Hide sports source button when playing movies/TV
            const sportsSourceBtn = document.getElementById('sportsSourceBtn');
            if (sportsSourceBtn) sportsSourceBtn.style.display = 'none';

            // Show hint if user hasn't dismissed it
            showSourceHint();
        }

        // Source tooltip hint - simple implementation
        // Track if hint has been shown in this session only (not persisted)
        let sourceHintShownThisSession = false;

        function showSourceHint() {
            // Disabled - notification removed
            return;
        }

        window.dismissSourceHint = function() {
            const hint = document.getElementById('sourceTooltipHint');
            if (hint) {
                hint.classList.remove('active');
            }
        }

        function updateNextEpisodeButton() {
            const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');

            if (currentContentType === 'tv' && currentContentData) {
                // Get cached episode data for current season
                const cacheKey = `${currentContentId}_${currentSelectedSeason}`;
                const seasonData = episodeCache[cacheKey];
                const maxEpisode = seasonData?.episodes?.length || 0;

                // Check if there's a next episode in current season or next season
                const hasNextEpisode = currentSelectedEpisode < maxEpisode || currentSelectedSeason < currentSeasons.length;

                nextEpisodeBtn.style.display = hasNextEpisode ? 'inline-block' : 'none';
            } else {
                nextEpisodeBtn.style.display = 'none';
            }
        }

        window.playNextEpisode = async function() {
            if (currentContentType !== 'tv' || !currentContentData) {
                showError('Not playing a TV show');
                return;
            }

            // Get cached episode data for current season
            const cacheKey = `${currentContentId}_${currentSelectedSeason}`;
            const seasonData = episodeCache[cacheKey];
            const maxEpisode = seasonData?.episodes?.length || 0;

            // Try to go to next episode
            if (currentSelectedEpisode < maxEpisode) {
                // Next episode in same season
                currentSelectedEpisode++;
                document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(currentSelectedEpisode);
            } else if (currentSelectedSeason < currentSeasons.length) {
                // First episode of next season
                currentSelectedSeason++;
                document.getElementById('seasonButtonText').textContent = `Season ${currentSelectedSeason}`;

                // Update episode selector for new season
                await updateEpisodeSelector(currentSelectedSeason);

                currentSelectedEpisode = 1;
                document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(1, currentSelectedSeason);
            } else {
                // showStatus('No more episodes available');
                return;
            }

            // Update episode description for the next episode
            const newCacheKey = `${currentContentId}_${currentSelectedSeason}`;
            const newSeasonData = episodeCache[newCacheKey];
            if (newSeasonData && newSeasonData.episodes) {
                const nextEpisode = newSeasonData.episodes.find(ep => ep.episode_number === currentSelectedEpisode);
                if (nextEpisode) {
                    const descriptionSection = document.getElementById('episodeDescription');
                    const descriptionText = document.getElementById('episodeDescriptionText');

                    if (nextEpisode.overview && nextEpisode.overview.trim() !== '') {
                        descriptionText.textContent = nextEpisode.overview;
                        descriptionSection.style.display = 'block';
                    } else {
                        descriptionSection.style.display = 'none';
                    }
                }
            }

            // Play the next episode
            playTVEpisode(currentContentId, currentSelectedSeason, currentSelectedEpisode);
        }

        function loadPlayerContent(url, startTime = null, streamType = 'embed', subtitles = []) {
            const playerIframe = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');
            const placeholder = document.getElementById('playerPlaceholder');

            console.log('Loading player with URL:', url);
            console.log('Stream type:', streamType);

            // Defensive check: ensure URL is valid
            if (!url) {
                console.error('loadPlayerContent called with undefined/null URL');
                showError('Failed to load stream - no URL provided');
                return;
            }

            // Check if it's a direct stream (.m3u8) or embed
            if (streamType === 'direct' || url.includes('.m3u8')) {
                console.log('Using VIDEO element for direct stream');

                // Hide iframe and placeholder
                if (playerIframe) playerIframe.style.display = 'none';
                if (placeholder) placeholder.style.display = 'none';

                // Show video element, comments button, and stop button
                if (playerVideo) {
                    playerVideo.style.display = 'block';
                    const commentsBtn = document.getElementById('commentsBtn');
                    if (commentsBtn && authToken) commentsBtn.style.display = 'inline-block';
                    const stopBtn = document.getElementById('stopBtn');
                    if (stopBtn) stopBtn.style.display = 'inline-block';

                    // Check if HLS.js is supported
                    if (Hls.isSupported()) {
                        // Destroy existing HLS instance if any
                        if (window.hls) {
                            window.hls.destroy();
                        }

                        // Create new HLS instance
                        window.hls = new Hls({
                            enableWorker: true,
                            lowLatencyMode: false,
                            backBufferLength: 90,
                            maxBufferLength: 30,
                            maxMaxBufferLength: 600
                        });

                        // Load the source
                        window.hls.loadSource(url);
                        window.hls.attachMedia(playerVideo);

                        // Handle events
                        window.hls.on(Hls.Events.MANIFEST_PARSED, function() {
                            console.log('HLS manifest parsed, ready to play');

                            // Add subtitle tracks from scraper
                            // Remove any existing tracks first
                            const existingTracks = playerVideo.querySelectorAll('track');
                            existingTracks.forEach(t => t.remove());

                            if (subtitles && subtitles.length > 0) {
                                console.log(`[Subtitles] Adding ${subtitles.length} subtitle tracks`);
                                subtitles.forEach((subUrl, idx) => {
                                    const track = document.createElement('track');
                                    track.kind = 'subtitles';
                                    // Proxy through our backend to avoid CORS issues
                                    track.src = `${API_BASE_URL}/subtitles/proxy?url=${encodeURIComponent(subUrl)}`;
                                    // Infer language from URL or default to English
                                    const langMatch = subUrl.match(/[._-](\w{2})\.(vtt|srt)/) || subUrl.match(/\/(\w{2})\.(vtt|srt)/);
                                    track.srclang = langMatch ? langMatch[1] : 'en';
                                    track.label = langMatch ? langMatch[1].toUpperCase() : (idx === 0 ? 'English' : `Track ${idx + 1}`);
                                    if (idx === 0) track.default = true;
                                    playerVideo.appendChild(track);
                                });
                            }

                            // Seek to start time if provided
                            if (startTime !== null && startTime > 0) {
                                playerVideo.currentTime = startTime;
                            }

                            playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                        });

                        // Setup watchparty sync listeners for movies/TV
                        videoSyncListenersAttached = false; // Reset flag
                        setupVideoSyncListeners(playerVideo);

                        window.hls.on(Hls.Events.ERROR, function(event, data) {
                            console.error('HLS error:', data);
                            if (data.fatal) {
                                switch(data.type) {
                                    case Hls.ErrorTypes.NETWORK_ERROR:
                                        showError('Network error - trying to recover...');
                                        window.hls.startLoad();
                                        break;
                                    case Hls.ErrorTypes.MEDIA_ERROR:
                                        showError('Media error - trying to recover...');
                                        window.hls.recoverMediaError();
                                        break;
                                    default:
                                        showError('Fatal error - cannot play this stream. Try switching sources.');
                                        window.hls.destroy();
                                        break;
                                }
                            }
                        });
                    }
                    // Check if the browser supports HLS natively (Safari)
                    else if (playerVideo.canPlayType('application/vnd.apple.mpegurl')) {
                        // Remove existing tracks and add subtitles
                        const existingTracks = playerVideo.querySelectorAll('track');
                        existingTracks.forEach(t => t.remove());

                        playerVideo.src = url;

                        if (subtitles && subtitles.length > 0) {
                            subtitles.forEach((subUrl, idx) => {
                                const track = document.createElement('track');
                                track.kind = 'subtitles';
                                track.src = `${API_BASE_URL}/subtitles/proxy?url=${encodeURIComponent(subUrl)}`;
                                const langMatch = subUrl.match(/[._-](\w{2})\.(vtt|srt)/) || subUrl.match(/\/(\w{2})\.(vtt|srt)/);
                                track.srclang = langMatch ? langMatch[1] : 'en';
                                track.label = langMatch ? langMatch[1].toUpperCase() : (idx === 0 ? 'English' : `Track ${idx + 1}`);
                                if (idx === 0) track.default = true;
                                playerVideo.appendChild(track);
                            });
                        }

                        if (startTime !== null && startTime > 0) {
                            playerVideo.addEventListener('loadedmetadata', function() {
                                playerVideo.currentTime = startTime;
                                playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                            }, { once: true });
                        } else {
                            playerVideo.addEventListener('loadedmetadata', function() {
                                playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                            }, { once: true });
                        }

                        // Setup watchparty sync listeners
                        videoSyncListenersAttached = false;
                        setupVideoSyncListeners(playerVideo);
                    } else {
                        showError('HLS playback not supported in this browser');
                    }
                }

                // showStatus('Loading direct stream with full sync support...');

            } else {
                console.log('Using IFRAME for embed');

                // Hide video element
                if (playerVideo) {
                    playerVideo.style.display = 'none';
                    playerVideo.pause();
                    playerVideo.src = '';
                }

                // Destroy HLS instance
                if (window.hls) {
                    window.hls.destroy();
                    window.hls = null;
                }

                // Detect Safari (but not Chrome)
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

                if (isSafari) {
                    // Show Safari subtitle info
                }

                playerIframe.src = url;
                playerIframe.style.display = 'block';
                placeholder.style.display = 'none';

                // Show comments button and stop button
                const commentsBtn = document.getElementById('commentsBtn');
                if (commentsBtn && authToken) commentsBtn.style.display = 'inline-block';
                const stopBtn = document.getElementById('stopBtn');
                if (stopBtn) stopBtn.style.display = 'inline-block';

                console.log('Player iframe src set to:', playerIframe.src);

                // VidKing postMessage events provide full sync capability for iframes
            }

            // Prevent iframe from auto-fullscreening on mobile
            preventAutoFullscreen();

            // Start tracking watch progress
            startProgressTracking();

            // Detect sync mode when in a watchparty
            if (watchpartyActive) {
                const playerVideo = document.getElementById('playerVideo');
                const newMode = 'full'; // VidKing postMessage events enable full sync for iframes too

                if (newMode !== partySyncMode) {
                    partySyncMode = newMode;
                    updateSyncStatusBadge();

                    // Host reports sync mode to server
                    if (isHost && socket) {
                        socket.emit('set_sync_mode', { mode: newMode });
                    }
                }
            }
        }

        // Prevent VidKing player from auto-fullscreening on mobile
        function preventAutoFullscreen() {
            // Listen for fullscreen change events
            const fullscreenChangeHandler = () => {
                const player = document.getElementById('contentPlayer');
                const container = document.querySelector('.player-container');

                // If iframe went fullscreen but container didn't, exit iframe fullscreen
                if (document.fullscreenElement === player && !container.contains(document.fullscreenElement)) {
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.webkitExitFullscreen) {
                        document.webkitExitFullscreen();
                    }
                }

                // Manage watchparty panel and sidebar based on fullscreen state
                if (watchpartyActive) {
                    const isFullscreen = document.fullscreenElement ||
                                        document.webkitFullscreenElement ||
                                        document.mozFullScreenElement ||
                                        document.msFullscreenElement;

                    const panel = document.getElementById('watchpartyPanel');
                    const sidebar = document.getElementById('watchpartySidebar');

                    if (isFullscreen) {
                        // When entering fullscreen: move sidebar into player-container
                        // Check if the container itself is fullscreen OR if it contains the fullscreen element
                        const containerIsFullscreen = isFullscreen === container ||
                                                     (container && container.contains(isFullscreen));

                        if (sidebar && containerIsFullscreen) {
                            sidebar.classList.add('fullscreen-mode');
                            // Only append if not already in container
                            if (!container.contains(sidebar)) {
                                container.appendChild(sidebar);
                            }
                        }
                    } else {
                        // When exiting fullscreen: move sidebar back out and remove class
                        if (sidebar) {
                            sidebar.classList.remove('fullscreen-mode');
                            // Move sidebar back to its original position (outside container, after script tag)
                            const containerDiv = document.querySelector('.container');
                            if (containerDiv && containerDiv.parentNode && container.contains(sidebar)) {
                                // Insert after the container div
                                containerDiv.parentNode.insertBefore(sidebar, containerDiv.nextSibling);
                            }
                        }

                        if (panel) {
                            // When exiting fullscreen and in a watchparty, hide the panel
                            // (chat is shown in sidebar instead)
                            panel.classList.remove('active');
                        }
                    }
                }
            };

            document.addEventListener('fullscreenchange', fullscreenChangeHandler);
            document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
            document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
            document.addEventListener('MSFullscreenChange', fullscreenChangeHandler);
        }

        // Progress tracking system
        let progressTrackingInterval = null;

        function startProgressTracking() {
            // Clear any existing tracking
            if (progressTrackingInterval) {
                clearInterval(progressTrackingInterval);
            }

            // Save progress every 10 seconds
            progressTrackingInterval = setInterval(() => {
                saveCurrentProgress();
            }, 10000);

            // Also save on page unload
            window.addEventListener('beforeunload', saveCurrentProgress);
        }

        function saveCurrentProgress() {
            if (!currentContentId || !currentContentType) return;

            // Find the item in watch history
            const existingIndex = watchHistory.findIndex(
                item => item.id === currentContentId && item.type === currentContentType
            );

            if (existingIndex === -1) return;

            // Since we can't access iframe video element, we'll use a simpler approach:
            // Mark as "in progress" after 10 seconds of viewing
            const now = new Date();
            const item = watchHistory[existingIndex];
            const viewingTime = (now - new Date(item.lastWatched)) / 1000; // seconds

            // Estimate progress based on viewing time (rough approximation)
            // Average movie is ~120 minutes, average episode is ~45 minutes
            const estimatedDuration = currentContentType === 'tv' ? 2700 : 7200; // seconds
            const estimatedProgress = Math.min(95, (viewingTime / estimatedDuration) * 100);

            watchHistory[existingIndex].progress = Math.max(item.progress, estimatedProgress);
            watchHistory[existingIndex].lastWatched = now.toISOString();

            localStorage.setItem('streamingSite_watchHistory', JSON.stringify(watchHistory));
        }

        function stopProgressTracking() {
            if (progressTrackingInterval) {
                clearInterval(progressTrackingInterval);
                progressTrackingInterval = null;
            }
            saveCurrentProgress();
        }

        window.stopPlayback = function() {
            const player = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');
            const placeholder = document.getElementById('playerPlaceholder');
            const currentContent = document.getElementById('currentContent');

            // Stop progress tracking and save final state
            stopProgressTracking();

            player.src = 'about:blank';
            player.style.display = 'none';

            // Stop video player and destroy HLS instance
            if (playerVideo) {
                playerVideo.pause();
                playerVideo.src = '';
                playerVideo.style.display = 'none';
            }
            if (window.hls) {
                window.hls.destroy();
                window.hls = null;
            }

            placeholder.style.display = 'flex';
            currentContent.style.display = 'none';

            // Clear backdrop image
            const backdropEl = document.getElementById('backdropImage');
            if (backdropEl) {
                backdropEl.style.backgroundImage = '';
                backdropEl.classList.remove('loaded');
            }

            // Clear player background effects
            clearPlayerBackgroundEffects();

            // Hide sports source button
            const sportsSourceBtn = document.getElementById('sportsSourceBtn');
            if (sportsSourceBtn) sportsSourceBtn.style.display = 'none';

            // Clear sports match data
            currentSportsMatch = null;
            currentSportsSourceIndex = 0;

            currentContentUrl = '';
            currentContentId = null;
            currentContentData = null;

            // Reset ratings refresh trackers for next content
            if (typeof __lastRefreshedContentId !== 'undefined') {
                __lastRefreshedContentId = null;
            }
            if (typeof __earlyLastRefreshedContentId !== 'undefined') {
                __earlyLastRefreshedContentId = null;
            }

            // Reset source hint for next content load
            sourceHintShownThisSession = false;

            // Hide stop button
            const stopBtn = document.getElementById('stopBtn');
            if (stopBtn) stopBtn.style.display = 'none';

            // Hide player section
            const playerSection = document.getElementById('playerSection');
            if (playerSection) playerSection.style.display = 'none';

            // Hide standalone poster
            const posterEl = document.getElementById('currentPoster');
            if (posterEl) posterEl.style.display = 'none';

            // Broadcast stop to watchparty if host
            if (watchpartyActive && isHost && socket) {
                socket.emit('sync_stop');
            }
        }

        window.toggleFullscreen = function() {
            const container = document.querySelector('.player-container');

            if (!container) {
                console.error('Player container not found');
                return;
            }

            // Always use container for fullscreen (more reliable across devices)
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.webkitCurrentFullScreenElement) {
                console.log('Attempting to enter fullscreen...');
                // Try to enter fullscreen
                if (container.requestFullscreen) {
                    container.requestFullscreen()
                        .then(() => {
                            console.log('Fullscreen entered successfully');
                        })
                        .catch(err => {
                            console.error('Fullscreen request failed:', err);
                        });
                } else if (container.webkitRequestFullscreen) {
                    try {
                        container.webkitRequestFullscreen();
                        console.log('Webkit fullscreen requested');
                    } catch (err) {
                        console.error('Webkit fullscreen failed:', err);
                    }
                } else if (container.mozRequestFullScreen) {
                    try {
                        container.mozRequestFullScreen();
                        console.log('Mozilla fullscreen requested');
                    } catch (err) {
                        console.error('Mozilla fullscreen failed:', err);
                    }
                } else if (container.msRequestFullscreen) {
                    try {
                        container.msRequestFullscreen();
                        console.log('MS fullscreen requested');
                    } catch (err) {
                        console.error('MS fullscreen failed:', err);
                    }
                } else {
                }
            } else {
                console.log('Attempting to exit fullscreen...');
                // Try to exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen()
                        .then(() => {
                            console.log('Exited fullscreen successfully');
                        })
                        .catch(err => {
                            console.error('Exit fullscreen failed:', err);
                        });
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.webkitCancelFullScreen) {
                    document.webkitCancelFullScreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        window.copyCurrentUrl = function() {
            if (currentContentUrl) {
                navigator.clipboard.writeText(currentContentUrl).then(() => {
                }).catch(() => {
                    showError('Failed to copy URL');
                });
            } else {
                showError('No content is currently loaded');
            }
        }


        function clearResults() {
            document.getElementById('contentResults').innerHTML = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('yearInput').value = '';
            hideStatus();
            hideError();
        }

        window.showTab = function(tabName) {
            console.log('[showTab] Called with:', tabName);
            currentTab = tabName;
            currentGenreId = null; // Reset genre filter
            currentPage = 1; // Reset page

            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Hide all sections
            document.getElementById('contentResults').style.display = 'none';
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            document.getElementById('sportsDisplay').style.display = 'none';
            document.getElementById('channelsDisplay').style.display = 'none';

            const genreContainer = document.getElementById('genreFilterContainer');
            const genreDropdown = document.getElementById('genreDropdown');
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (genreContainer) genreContainer.style.display = 'none';
            if (genreDropdown) genreDropdown.classList.remove('active');
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            if (tabName === 'continue-watching') {
                document.getElementById('continueWatchingTab').classList.add('active');
                document.getElementById('continueWatchingDisplay').style.display = 'grid';
                displayContinueWatchingInResults();
            } else if (tabName === 'statistics') {
                document.getElementById('statisticsTab').classList.add('active');
                document.getElementById('statisticsDisplay').style.display = 'block';
                displayStatistics();
            } else if (tabName === 'search-results') {
                document.querySelector('.tab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
            } else if (tabName === 'movies') {
                document.getElementById('moviesTab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
                currentMediaType = 'movie';
                currentContentFilter = 'popular'; // Default to popular

                // Show content type filters (only genre and language)
                const contentTypeFilters = document.getElementById('contentTypeFilters');
                if (contentTypeFilters) {
                    contentTypeFilters.style.display = 'flex';
                    loadGenres('movie');
                }
                loadPopularMovies();
            } else if (tabName === 'tv-shows') {
                document.getElementById('tvShowsTab').classList.add('active');
                document.getElementById('contentResults').style.display = 'grid';
                currentMediaType = 'tv';
                currentContentFilter = 'popular'; // Default to popular

                // Show content type filters (only genre and language)
                const contentTypeFilters = document.getElementById('contentTypeFilters');
                if (contentTypeFilters) {
                    contentTypeFilters.style.display = 'flex';
                    loadGenres('tv');
                }
                loadPopularTVShows();
            }
        }

        // Set content filter (Popular/Trending/Now Playing/Upcoming)
        // Set content filter (called from radial menu)
        function setContentFilter(filter) {
            currentContentFilter = filter;
            currentGenreId = null; // Reset genre filter
            currentPage = 1; // Reset page

            // Load content based on media type and filter
            if (currentMediaType === 'movie') {
                if (filter === 'popular') {
                    loadPopularMovies();
                } else if (filter === 'trending') {
                    loadTrendingMovies();
                } else if (filter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (filter === 'popular') {
                    loadPopularTVShows();
                } else if (filter === 'trending') {
                    loadTrendingTVShows();
                } else if (filter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        // Genre filtering functions
        async function loadGenres(type) {
            try {
                const endpoint = type === 'movie' ? '/genres/movies' : '/genres/tv';
                const response = await fetch(`${API_BASE_URL}${endpoint}`);
                const data = await response.json();

                if (type === 'movie') {
                    movieGenresList = data.genres || [];
                } else {
                    tvGenresList = data.genres || [];
                }

                displayGenres(type);
            } catch (error) {
                console.error('Error loading genres:', error);
            }
        }

        function displayGenres(type) {
            const genreList = document.getElementById('genreList');
            const genres = type === 'movie' ? movieGenresList : tvGenresList;

            genreList.innerHTML = `
                <button class="effects-btn" onclick="selectGenre(null, '${type}')" style="width: 100%; padding: 12px;">
                    All Genres
                </button>
            `;

            genres.forEach(genre => {
                const button = document.createElement('button');
                button.className = 'effects-btn';
                button.style.width = '100%';
                button.style.padding = '12px';
                button.textContent = genre.name;
                button.onclick = () => selectGenre(genre.id, type);
                genreList.appendChild(button);
            });
        }

        function toggleGenreModal() {
            const modal = document.getElementById('genreModal');
            if (modal) {
                modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
            }
        }

        function closeGenreModal() {
            const modal = document.getElementById('genreModal');
            if (modal) modal.style.display = 'none';
        }

        function toggleLanguageModal() {
            const modal = document.getElementById('languageModal');
            if (modal) {
                modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
            }
        }

        function closeLanguageModal() {
            const modal = document.getElementById('languageModal');
            if (modal) modal.style.display = 'none';
        }

        async function filterByLanguage(languageCode) {
            currentLanguage = languageCode;
            currentPage = 1; // Reset page
            closeLanguageModal();

            // Map language codes to names
            const languageNames = {
                'en': 'English',
                'ar': 'Arabic',
                'ko': 'Korean',
                'ja': 'Japanese',
                'zh': 'Chinese'
            };

            // Update display
            const languageName = languageCode ? languageNames[languageCode] : '';

            // If a genre is already selected, reload with both filters
            if (currentGenreId !== null) {
                const genreName = (currentMediaType === 'movie' ? movieGenresList : tvGenresList).find(g => g.id === currentGenreId)?.name || 'Selected Genre';
                updateActiveFiltersDisplay(genreName, languageName);

                // Load genre-filtered content with language
                await loadContentWithFilters(currentMediaType, currentGenreId);
                return;
            }

            updateActiveFiltersDisplay(null, languageName);

            // Reload current content with language filter
            if (currentMediaType === 'movie') {
                if (currentContentFilter === 'popular') {
                    loadPopularMovies();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingMovies();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (currentContentFilter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (currentContentFilter === 'popular') {
                    loadPopularTVShows();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingTVShows();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        async function loadContentWithFilters(type, genreId) {
            // This function loads content with both genre and language filters applied
            try {
                const endpoint = type === 'movie' ? '/discover/movies' : '/discover/tv';
                let url = `${API_BASE_URL}${endpoint}?genre=${genreId}&page=${currentPage}`;

                // Add language filter if selected
                if (currentLanguage) {
                    url += `&language=${currentLanguage}`;
                }

                console.log('Loading content with URL:', url);  // Debug log

                const response = await fetch(url);
                const data = await response.json();

                const genreName = (type === 'movie' ? movieGenresList : tvGenresList).find(g => g.id === genreId)?.name || 'Selected Genre';

                // Map language codes to names for display
                const languageNames = {
                    'en': 'English',
                    'ar': 'Arabic',
                    'ko': 'Korean',
                    'ja': 'Japanese',
                    'zh': 'Chinese'
                };
                const languageName = currentLanguage ? languageNames[currentLanguage] : null;

                updateActiveFiltersDisplay(genreName, languageName);
                displayContent(data.results || [], `${genreName} ${type === 'movie' ? 'Movies' : 'TV Shows'}`);
            } catch (error) {
                console.error('Error loading filtered content:', error);
                displayContent([], 'Error loading content');
            }
        }

        async function selectGenre(genreId, type) {
            currentGenreId = genreId;
            currentPage = 1;
            closeGenreModal();

            if (genreId === null) {
                updateActiveFiltersDisplay();
                // Load all content (popular or trending based on current tab)
                if (currentTab === 'popular-movies') {
                    loadPopularMovies();
                } else if (currentTab === 'popular-tv') {
                    loadPopularTVShows();
                } else if (currentTab === 'trending-movies') {
                    loadTrendingMovies();
                } else if (currentTab === 'trending-tv') {
                    loadTrendingTVShows();
                }
            } else {
                // Load genre-filtered content with current language filter
                await loadContentWithFilters(type, genreId);
            }
        }

        function updateActiveFiltersDisplay(genreName = null, languageName = null) {
            const activeFiltersDiv = document.getElementById('activeFiltersDisplay');
            const activeGenreSpan = document.getElementById('activeGenreDisplay');
            const activeLanguageSpan = document.getElementById('activeLanguageDisplay');
            const genreNameSpan = document.getElementById('genreName');
            const languageNameSpan = document.getElementById('languageName');

            // Update genre display
            if (genreName !== null) {
                if (genreName) {
                    genreNameSpan.textContent = genreName;
                    activeGenreSpan.style.display = 'inline';
                } else {
                    activeGenreSpan.style.display = 'none';
                }
            }

            // Update language display
            if (languageName !== null) {
                if (languageName) {
                    languageNameSpan.textContent = languageName;
                    activeLanguageSpan.style.display = 'inline';
                } else {
                    activeLanguageSpan.style.display = 'none';
                }
            }

            // Show/hide the entire filters display
            const hasActiveFilters = activeGenreSpan.style.display !== 'none' || activeLanguageSpan.style.display !== 'none';
            activeFiltersDiv.style.display = hasActiveFilters ? 'block' : 'none';
        }

        function clearGenreFilter() {
            currentGenreId = null;
            currentPage = 1;
            updateActiveFiltersDisplay('');

            // Reload current content
            if (currentMediaType === 'movie') {
                if (currentContentFilter === 'popular') {
                    loadPopularMovies();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingMovies();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (currentContentFilter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (currentContentFilter === 'popular') {
                    loadPopularTVShows();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingTVShows();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        function clearLanguageFilter() {
            currentLanguage = null;
            currentPage = 1;
            updateActiveFiltersDisplay(null, '');

            // Reload current content
            if (currentMediaType === 'movie') {
                if (currentContentFilter === 'popular') {
                    loadPopularMovies();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingMovies();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingMovies();
                } else if (currentContentFilter === 'upcoming') {
                    loadUpcomingMovies();
                }
            } else if (currentMediaType === 'tv') {
                if (currentContentFilter === 'popular') {
                    loadPopularTVShows();
                } else if (currentContentFilter === 'trending') {
                    loadTrendingTVShows();
                } else if (currentContentFilter === 'now-playing') {
                    loadNowPlayingTVShows();
                }
            }
        }

        // Recommendations function - loads based on currently playing content, or aggregate if nothing playing
        async function loadRecommendations() {
            // If something is currently playing, show recommendations for that specific item
            if (currentContentId && currentContentType) {
                try {
                    const endpoint = currentContentType === 'movie'
                        ? `/recommendations/movies/${currentContentId}`
                        : `/recommendations/tv/${currentContentId}`;

                    const response = await fetch(`${API_BASE_URL}${endpoint}`);
                    const data = await response.json();

                    const title = currentContentData?.title || currentContentData?.name || 'This Content';
                    displayContent(data.results || [], `Similar to "${title}"`);
                } catch (error) {
                    console.error('Error loading recommendations:', error);
                    displayContent([], 'Error loading recommendations');
                }
                return;
            }

            // Otherwise, show aggregate recommendations from watch history + watchlist
            const allWatchlists = Object.values(watchlists).flat();
            const recentHistory = watchHistory.slice(0, 10); // Last 10 watched
            const allItems = [...recentHistory, ...allWatchlists];

            if (allItems.length === 0) {
                displayContent([], 'Watch something first to get recommendations!');
                return;
            }

            try {
                // Collect recommendations from multiple sources
                const recommendationPromises = allItems.slice(0, 5).map(item => {
                    const endpoint = item.type === 'movie'
                        ? `/recommendations/movies/${item.id}`
                        : `/recommendations/tv/${item.id}`;
                    return fetch(`${API_BASE_URL}${endpoint}`)
                        .then(res => res.json())
                        .catch(() => ({ results: [] }));
                });

                const recommendationSets = await Promise.all(recommendationPromises);

                // Combine and deduplicate recommendations
                const allRecommendations = [];
                const seenIds = new Set();

                recommendationSets.forEach(set => {
                    (set.results || []).forEach(item => {
                        const itemId = item.id;
                        if (!seenIds.has(itemId)) {
                            seenIds.add(itemId);
                            allRecommendations.push(item);
                        }
                    });
                });

                // Sort by vote average (popularity)
                allRecommendations.sort((a, b) => (b.vote_average || 0) - (a.vote_average || 0));

                displayContent(allRecommendations.slice(0, 20), 'Recommended For You');
            } catch (error) {
                console.error('Error loading recommendations:', error);
                displayContent([], 'Error loading recommendations');
            }
        }

        // Auto-load recommendations when playing content (just triggers a reload if on recommendations tab)
        async function autoLoadRecommendations() {
            // If user is on recommendations tab, reload it with new data
            if (currentTab === 'recommendations') {
                await loadRecommendations();
            }
        }

        // Watchlist functionality
        // Store current item being added to watchlist
        let pendingWatchlistItem = null;
        let watchlistScrollPosition = 0;

        function toggleWatchlist(id, title, type, posterUrl, year, rating, event) {
            const panel = document.getElementById('watchlistPanel');
            if (!panel) return;

            // If panel is already open, close it
            if (panel.classList.contains('active')) {
                panel.classList.remove('active');
                setTimeout(() => { panel.style.display = 'none'; }, 250);
                return;
            }

            // Store current item data
            window.pendingWatchlistPanelItem = {
                id: id,
                title: title,
                type: type,
                posterUrl: posterUrl,
                year: year,
                rating: rating,
                addedAt: new Date().toISOString()
            };

            // Check if item is in any watchlist
            const inLists = Object.keys(watchlists).filter(listName =>
                watchlists[listName].some(item => item.id === id && item.type === type)
            );

            // Update panel content
            updateWatchlistPanel(inLists);

            // Position panel near the clicked button
            const button = event.target.closest('.watchlist-btn') || event.target;
            const rect = button.getBoundingClientRect();

            // Position below button, but adjust if too close to bottom
            const spaceBelow = window.innerHeight - rect.bottom;
            const panelHeight = 450;
            const panelWidth = 360;

            if (spaceBelow < panelHeight && rect.top > panelHeight) {
                panel.style.top = `${rect.top + window.scrollY - panelHeight - 8}px`;
            } else {
                panel.style.top = `${rect.bottom + window.scrollY + 8}px`;
            }

            let left = rect.left + window.scrollX;
            if (left + panelWidth > window.innerWidth) {
                left = window.innerWidth - panelWidth - 16;
            }

            panel.style.left = `${left}px`;
            panel.style.display = 'flex';
            requestAnimationFrame(() => {
                panel.classList.add('active');
            });
        }

        function showWatchlistModal(event) {
            const modal = document.getElementById('watchlistModal');
            const content = document.getElementById('watchlistPanelContent');
            const title = document.getElementById('watchlistModalTitle');
            const createSection = document.getElementById('watchlistCreateSection');

            if (!modal || !content) {
                console.error('Watchlist modal elements not found');
                return;
            }

            // Save current scroll position
            watchlistScrollPosition = window.pageYOffset || document.documentElement.scrollTop;

            // Update title and show create section
            title.textContent = ' ADD TO WATCHLIST';
            createSection.style.display = 'block';

            const listNames = Object.keys(watchlists);

            if (listNames.length === 0) {
                watchlists['My Watchlist'] = [];
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
            }

            content.innerHTML = Object.keys(watchlists).map(listName => `
                <button onclick="addToSpecificWatchlist('${listName.replace(/'/g, "\\'")}')" class="effects-btn" style="width: 100%; padding: 12px;">
                    ${listName}
                </button>
            `).join('');

            // Show modal
            modal.style.display = 'flex';

            // Scroll to modal
            modal.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Add escape key handler
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeWatchlistModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        function showWatchlistRemovalModal(id, title, type, inLists, event) {
            const modal = document.getElementById('watchlistModal');
            const content = document.getElementById('watchlistPanelContent');
            const modalTitle = document.getElementById('watchlistModalTitle');
            const createSection = document.getElementById('watchlistCreateSection');

            // Save current scroll position
            watchlistScrollPosition = window.pageYOffset || document.documentElement.scrollTop;

            // Update title and hide create section
            modalTitle.textContent = ' REMOVE FROM WATCHLIST';
            createSection.style.display = 'none';

            content.innerHTML = inLists.map(listName => `
                <button onclick="removeFromSpecificWatchlist('${listName.replace(/'/g, "\\'")}', ${id}, '${type}')" class="effects-btn" style="width: 100%; padding: 12px; background: rgba(255, 59, 48, 0.15); border-color: #FF453A; color: #FF453A;">
                    ${listName}
                </button>
            `).join('');

            // Show modal
            modal.style.display = 'flex';

            // Scroll to modal
            modal.scrollIntoView({ behavior: 'smooth', block: 'start' });

            // Add escape key handler
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeWatchlistModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
        }

        async function addToSpecificWatchlist(listName) {
            if (!pendingWatchlistItem) return;

            // If user is logged in, use API
            if (authToken) {
                try {
                    await addToWatchlistAPI(
                        pendingWatchlistItem.id,
                        pendingWatchlistItem.type,
                        pendingWatchlistItem.title,
                        pendingWatchlistItem.posterUrl,
                        listName
                    );
                    closeWatchlistModal();
                    updateWatchlistButtons();

                    // Update player watchlist button if currently playing this content
                    if (currentContentId === pendingWatchlistItem.id && currentContentType === pendingWatchlistItem.type) {
                        updatePlayerWatchlistButton(currentContentId, currentContentType);
                    }
                } catch (error) {
                    showError('Failed to add to watchlist');
                }
            } else {
                // Fallback to localStorage for non-authenticated users
                watchlists[listName].push(pendingWatchlistItem);
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

                closeWatchlistModal();
                updateWatchlistButtons();

                // Update player watchlist button if currently playing this content
                if (currentContentId === pendingWatchlistItem.id && currentContentType === pendingWatchlistItem.type) {
                    updatePlayerWatchlistButton(currentContentId, currentContentType);
                }

                // If currently viewing this watchlist, refresh it
                if (currentWatchlistName === listName) {
                    displayWatchlistInResults();
                }
            }
        }

        async function removeFromSpecificWatchlist(listName, id, type) {
            // If user is logged in, use API
            if (authToken) {
                try {
                    await removeFromWatchlistAPI(id);
                    closeWatchlistModal();
                    updateWatchlistButtons();

                    // Update player watchlist button if currently playing this content
                    if (currentContentId === id && currentContentType === type) {
                        updatePlayerWatchlistButton(currentContentId, currentContentType);
                    }
                } catch (error) {
                    showError('Failed to remove from watchlist');
                }
            } else {
                // Fallback to localStorage for non-authenticated users
                const index = watchlists[listName].findIndex(item => item.id === id && item.type === type);
                if (index > -1) {
                    const item = watchlists[listName][index];
                    watchlists[listName].splice(index, 1);
                    localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

                    // showStatus(`Removed "${item.title}" from ${listName}`);
                    closeWatchlistModal();
                    updateWatchlistButtons();

                    // Update player watchlist button if currently playing this content
                    if (currentContentId === id && currentContentType === type) {
                        updatePlayerWatchlistButton(currentContentId, currentContentType);
                    }

                    // If currently viewing this watchlist, refresh it
                    if (currentWatchlistName === listName) {
                        displayWatchlistInResults();
                    }
                }
            }
        }

        function createNewWatchlist() {
            const input = document.getElementById('newWatchlistName');
            const name = input.value.trim();

            if (!name) {
                showError('Please enter a watchlist name');
                return;
            }

            if (watchlists[name]) {
                showError('A watchlist with this name already exists');
                return;
            }

            watchlists[name] = [];
            localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

            // showStatus(`Created new watchlist: ${name}`);
            input.value = '';

            // If we have a pending item, add it to the new list
            if (pendingWatchlistItem) {
                addToSpecificWatchlist(name);
            } else {
                showWatchlistModal();
            }
        }

        function closeWatchlistModal() {
            const modal = document.getElementById('watchlistModal');
            if (modal) modal.style.display = 'none';
            pendingWatchlistItem = null;

            // Restore scroll position
            window.scrollTo({ top: watchlistScrollPosition, behavior: 'smooth' });
        }

        function updateWatchlistButtons() {
            const watchlistBtns = document.querySelectorAll(`.watchlist-btn`);
            watchlistBtns.forEach(btn => {
                const btnParent = btn.closest('.content-card');
                if (btnParent) {
                    const onclickAttr = btnParent.getAttribute('onclick');
                    const match = onclickAttr?.match(/playContent\((\d+),/);
                    if (match) {
                        const id = parseInt(match[1]);
                        const isInList = isItemInAnyWatchlist(id);
                        btn.textContent = isInList ? '' : '';
                        btn.className = isInList ? 'watchlist-btn added' : 'watchlist-btn';
                        btn.title = isInList ? 'In Watchlist' : 'Add to Watchlist';
                    }
                }
            });
        }

        function isItemInWatchlist(id, type) {
            return isItemInAnyWatchlist(id, type);
        }

        function isItemInAnyWatchlist(id, type) {
            return Object.values(watchlists).some(list =>
                list.some(item => item.id === id && (!type || item.type === type))
            );
        }

        function getWatchProgress(id, type) {
            const item = watchHistory.find(item => item.id === id && item.type === type);
            return item ? Math.round(item.progress) : 0;
        }

        function updateWatchlist() {
            // This function is no longer used, kept for backwards compatibility
        }

        let currentWatchlistFilter = 'all'; // 'all', 'movie', 'tv'
        let isShowingSpecificList = false; // Track if a specific watchlist is selected

        function displayWatchlistInResults() {
            const watchlistDisplay = document.getElementById('watchlistDisplay');
            const listNames = Object.keys(watchlists);

            if (listNames.length === 0 || !watchlists[currentWatchlistName]) {
                currentWatchlistName = listNames[0] || 'My Watchlist';
            }

            const currentList = watchlists[currentWatchlistName] || [];

            // Watchlist selector
            const watchlistSelector = `
                <div style="grid-column: 1 / -1; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 16px;">
                        ${listNames.map(listName => `
                            <button onclick="switchWatchlist('${listName.replace(/'/g, "\\'")}')"
                                    class="btn ${(isShowingSpecificList && currentWatchlistName === listName) ? '' : 'btn-secondary'}"
                                    style="padding: 12px 24px;">
                                ${listName} (${watchlists[listName].length})
                            </button>
                        `).join('')}
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                        <button onclick="showManageWatchlistsModal()" class="btn btn-secondary" style="padding: 8px 16px; font-size: 14px;">
                            Manage Lists
                        </button>
                    </div>
                </div>
            `;

            // Get items based on whether a specific list is selected
            let allItems = [];
            if (isShowingSpecificList) {
                // Show only items from the selected watchlist
                allItems = currentList;
            } else {
                // Get all items from all lists (removing duplicates by id+type)
                const seenItems = new Set();
                listNames.forEach(listName => {
                    watchlists[listName].forEach(item => {
                        const key = `${item.id}_${item.type}`;
                        if (!seenItems.has(key)) {
                            seenItems.add(key);
                            allItems.push(item);
                        }
                    });
                });
            }

            // Filter based on current filter
            let filteredWatchlist = allItems;
            if (currentWatchlistFilter === 'movie') {
                filteredWatchlist = allItems.filter(item => item.type === 'movie');
            } else if (currentWatchlistFilter === 'tv') {
                filteredWatchlist = allItems.filter(item => item.type === 'tv');
            }

            if (filteredWatchlist.length === 0) {
                watchlistDisplay.innerHTML = watchlistSelector + `
                    <div style="text-align: center; color: #666; padding: 40px; grid-column: 1 / -1;">
                        <h3>No ${currentWatchlistFilter === 'movie' ? 'movies' : currentWatchlistFilter === 'tv' ? 'TV shows' : 'items'} found</h3>
                        <p>Add ${currentWatchlistFilter === 'movie' ? 'movies' : currentWatchlistFilter === 'tv' ? 'TV shows' : 'content'} to your watchlists</p>
                    </div>
                `;
                return;
            }

            const filterButtons = `
                <div style="grid-column: 1 / -1; margin-bottom: 20px; display: flex; gap: 10px; justify-content: center;">
                    <button onclick="filterWatchlist('all')" class="btn ${(!isShowingSpecificList && currentWatchlistFilter === 'all') ? '' : 'btn-secondary'}" style="padding: 12px 24px;">All</button>
                    <button onclick="filterWatchlist('movie')" class="btn ${(!isShowingSpecificList && currentWatchlistFilter === 'movie') ? '' : 'btn-secondary'}" style="padding: 12px 24px;">Movies</button>
                    <button onclick="filterWatchlist('tv')" class="btn ${(!isShowingSpecificList && currentWatchlistFilter === 'tv') ? '' : 'btn-secondary'}" style="padding: 12px 24px;">TV Shows</button>
                </div>
            `;

            const items = filteredWatchlist.map(item => {
                return `
                    <div class="continue-item content-card" data-id="${item.id}" data-type="${item.type}" onclick="playContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}')">
                        <button class="watchlist-remove-btn" onclick="event.stopPropagation(); removeFromSpecificWatchlist('${currentWatchlistName.replace(/'/g, "\\'")}', ${item.id}, '${item.type}')" title="Remove from Watchlist"></button>
                        <div class="continue-episode-badge">${item.type === 'tv' ? 'TV' : 'MOVIE'}</div>
                        <img src="${item.posterUrl}" alt="${item.title}" class="continue-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="continue-info">
                            <div class="continue-title">${item.title}</div>
                            <div class="continue-progress">${item.year}</div>
                            <div class="continue-last-watched"> ${item.rating}/10</div>
                        </div>
                    </div>
                `;
            }).join('');

            watchlistDisplay.innerHTML = watchlistSelector + filterButtons + items;
        }

        function switchWatchlist(listName) {
            currentWatchlistName = listName;
            isShowingSpecificList = true; // Show only this specific list
            currentWatchlistFilter = 'all'; // Reset filter
            localStorage.setItem('streamingSite_currentWatchlist', listName);
            displayWatchlistInResults();
        }

        function showManageWatchlistsModal() {
            const modal = document.getElementById('watchlistModal');
            const content = document.getElementById('watchlistModalContent');

            if (!modal || !content) {
                console.error('Watchlist modal elements not found');
                return;
            }

            const listNames = Object.keys(watchlists);

            content.innerHTML = `
                <div style="margin-bottom: 16px; color: #a1a1a6; font-size: 14px;">
                    Manage your watchlists:
                </div>
                <div style="display: grid; gap: 12px;">
                    ${listNames.map(listName => `
                        <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: rgba(58, 58, 60, 0.12); border-radius: 12px;">
                            <span style="flex: 1; color: #f5f5f7; font-weight: 500;">${listName}</span>
                            <span style="color: #a1a1a6; font-size: 14px;">${watchlists[listName].length} items</span>
                            ${listName !== 'My Watchlist' ? `
                                <button onclick="deleteWatchlist('${listName.replace(/'/g, "\\'")}')"
                                        class="btn btn-secondary"
                                        style="padding: 6px 12px; font-size: 13px; background: rgba(255, 59, 48, 0.15); border-color: rgba(255, 59, 48, 0.3); color: white;">
                                    Delete
                                </button>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
            `;

            modal.style.display = 'flex';
        }

        function deleteWatchlist(listName) {
            if (confirm(`Are you sure you want to delete "${listName}"? This will remove all ${watchlists[listName].length} items in it.`)) {
                delete watchlists[listName];
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

                // Switch to first available watchlist
                const remaining = Object.keys(watchlists);
                if (remaining.length > 0) {
                    switchWatchlist(remaining[0]);
                }

                // showStatus(`Deleted watchlist: ${listName}`);
                closeWatchlistModal();
                displayWatchlistInResults();
            }
        }

        function filterWatchlist(filter) {
            currentWatchlistFilter = filter;
            isShowingSpecificList = false; // Show all lists when using filter
            displayWatchlistInResults();
        }

        // Statistics Dashboard
        function resetAllStats() {
            if (confirm('Are you sure you want to reset all viewing statistics? This will clear your watch history but keep your watchlists. This action cannot be undone.')) {
                watchHistory = [];
                localStorage.setItem('streamingSite_watchHistory', JSON.stringify(watchHistory));
                // showStatus('All viewing statistics have been reset');
                displayStatistics();
            }
        }

        function displayStatistics() {
            const statsDisplay = document.getElementById('statisticsDisplay');

            // Calculate statistics
            const totalMovies = watchHistory.filter(item => item.type === 'movie').length;
            const totalTV = watchHistory.filter(item => item.type === 'tv').length;
            const totalWatchlist = Object.values(watchlists).reduce((sum, list) => sum + list.length, 0);

            // Calculate viewing patterns
            const movieProgress = watchHistory.filter(item => item.type === 'movie' && item.progress > 0);
            const tvProgress = watchHistory.filter(item => item.type === 'tv' && item.progress > 0);

            // Recent activity (last 7 days)
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
            const recentItems = watchHistory.filter(item =>
                new Date(item.lastWatched) > oneWeekAgo
            );

            // Top rated from watch history
            const topRated = [...watchHistory]
                .sort((a, b) => (parseFloat(b.rating) || 0) - (parseFloat(a.rating) || 0))
                .slice(0, 5);

            // Most watched (highest progress)
            const mostWatched = [...watchHistory]
                .sort((a, b) => (b.progress || 0) - (a.progress || 0))
                .slice(0, 5);

            statsDisplay.innerHTML = `
                <div style="max-width: 1200px; margin: 0 auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                        <h2 style="font-size: 2.5rem; font-weight: 600; margin: 0; background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                            Your Viewing Statistics
                        </h2>
                        <button onclick="resetAllStats()" class="btn btn-secondary" style="padding: 12px 24px; background: rgba(255, 59, 48, 0.2); border: 1px solid rgba(255, 59, 48, 0.4);">
                            Reset All Stats
                        </button>
                    </div>

                    <!-- Overview Cards -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 40px;">
                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">Total Movies Watched</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #007AFF, #5856D6); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${totalMovies}
                            </div>
                        </div>

                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">Total TV Shows Watched</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #5856D6, #AF52DE); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${totalTV}
                            </div>
                        </div>

                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">In Your Watchlist</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #AF52DE, #FF2D55); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${totalWatchlist}
                            </div>
                        </div>

                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <div style="font-size: 14px; color: #a1a1a6; margin-bottom: 8px;">Recent Activity (7 days)</div>
                            <div style="font-size: 36px; font-weight: 700; background: linear-gradient(135deg, #FF2D55, #FF9500); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                ${recentItems.length}
                            </div>
                        </div>
                    </div>

                    <!-- Charts Section -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 24px; margin-bottom: 40px;">
                        <!-- Movie vs TV Distribution -->
                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;">Content Distribution</h3>
                            <div style="display: flex; align-items: center; justify-content: center; gap: 40px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 48px; font-weight: 700; color: #007AFF;">${totalMovies > 0 ? Math.round((totalMovies / (totalMovies + totalTV)) * 100) : 0}%</div>
                                    <div style="color: #a1a1a6; margin-top: 8px;">Movies</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 48px; font-weight: 700; color: #5856D6;">${totalTV > 0 ? Math.round((totalTV / (totalMovies + totalTV)) * 100) : 0}%</div>
                                    <div style="color: #a1a1a6; margin-top: 8px;">TV Shows</div>
                                </div>
                            </div>
                        </div>

                        <!-- Completion Rate -->
                        <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                            <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;">Average Progress</h3>
                            <div style="text-align: center;">
                                <div style="font-size: 56px; font-weight: 700; background: linear-gradient(135deg, #34C759, #30D158); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                                    ${watchHistory.length > 0 ? Math.round(watchHistory.reduce((sum, item) => sum + (item.progress || 0), 0) / watchHistory.length) : 0}%
                                </div>
                                <div style="color: #a1a1a6; margin-top: 8px;">Overall Completion Rate</div>
                            </div>
                        </div>
                    </div>

                    <!-- Top Rated -->
                    <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 24px;">
                        <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;"> Top Rated Content You've Watched</h3>
                        <div style="display: grid; gap: 12px;">
                            ${topRated.length > 0 ? topRated.map((item, index) => `
                                <div style="display: flex; align-items: center; gap: 15px; padding: 12px; background: rgba(58, 58, 60, 0.12); border-radius: 12px; cursor: pointer;" onclick="playContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}')">
                                    <div style="font-size: 20px; font-weight: 700; color: #FFD60A; min-width: 30px;">#${index + 1}</div>
                                    <img src="${item.posterUrl}" style="width: 50px; height: 75px; object-fit: cover; border-radius: 8px;" onerror="this.src='https://via.placeholder.com/50x75/333/fff?text=?'">
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; color: #f5f5f7;">${item.title}</div>
                                        <div style="font-size: 14px; color: #a1a1a6;">${item.type.toUpperCase()}  ${item.year}</div>
                                    </div>
                                    <div style="font-size: 18px; font-weight: 700; color: #FFD60A;"> ${item.rating}</div>
                                </div>
                            `).join('') : '<div style="text-align: center; color: #666; padding: 20px;">No rated content yet</div>'}
                        </div>
                    </div>

                    <!-- Most Watched -->
                    <div style="background: rgba(29, 29, 31, 0.72); backdrop-filter: blur(20px); border-radius: 16px; padding: 24px; border: 1px solid rgba(255, 255, 255, 0.1);">
                        <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 20px; color: #f5f5f7;"> Most Progress Made</h3>
                        <div style="display: grid; gap: 12px;">
                            ${mostWatched.length > 0 ? mostWatched.map((item, index) => `
                                <div style="display: flex; align-items: center; gap: 15px; padding: 12px; background: rgba(58, 58, 60, 0.12); border-radius: 12px; cursor: pointer;" onclick="playContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}')">
                                    <div style="font-size: 20px; font-weight: 700; color: #007AFF; min-width: 30px;">#${index + 1}</div>
                                    <img src="${item.posterUrl}" style="width: 50px; height: 75px; object-fit: cover; border-radius: 8px;" onerror="this.src='https://via.placeholder.com/50x75/333/fff?text=?'">
                                    <div style="flex: 1;">
                                        <div style="font-weight: 600; color: #f5f5f7;">${item.title}</div>
                                        <div style="font-size: 14px; color: #a1a1a6;">${item.type.toUpperCase()}  ${item.year}</div>
                                    </div>
                                    <div style="min-width: 80px;">
                                        <div style="height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden;">
                                            <div style="height: 100%; width: ${Math.round(item.progress)}%; background: linear-gradient(90deg, #007AFF, #5856D6);"></div>
                                        </div>
                                        <div style="font-size: 12px; color: #a1a1a6; margin-top: 4px; text-align: center;">${Math.round(item.progress)}%</div>
                                    </div>
                                </div>
                            `).join('') : '<div style="text-align: center; color: #666; padding: 20px;">No viewing progress yet</div>'}
                        </div>
                    </div>
                </div>
            `;
        }

        function removeFromWatchlist(id, type) {
            const index = watchlist.findIndex(item => item.id === id && item.type === type);
            if (index > -1) {
                const item = watchlist[index];
                watchlist.splice(index, 1);
                localStorage.setItem('streamingSite_watchlist', JSON.stringify(watchlist));
                displayWatchlistInResults();
            }
        }

        // Watch history functionality
        async function addToWatchHistory(id, title, type, data, season = null, episode = null) {
            console.log('[addToWatchHistory] Called:', { id, title, type, authToken: authToken ? 'exists' : 'null' });

            // For TV shows, get the current season/episode from selectors if not provided
            let currentSeason = season;
            let currentEpisode = episode;

            if (type === 'tv' && (!currentSeason || !currentEpisode)) {
                const seasonSelect = document.getElementById('seasonSelect');
                const episodeSelect = document.getElementById('episodeSelect');
                if (seasonSelect && episodeSelect) {
                    currentSeason = parseInt(seasonSelect.value) || 1;
                    currentEpisode = parseInt(episodeSelect.value) || 1;
                } else {
                    currentSeason = 1;
                    currentEpisode = 1;
                }
            }

            const posterUrl = data.poster_url || 'https://via.placeholder.com/60x90/333/fff?text=No+Poster';

            // Require authentication - no localStorage fallback
            if (!authToken) {
                console.log('[addToWatchHistory] No auth, continue watching disabled');
                return;
            }

            // Save to database only
            console.log('[addToWatchHistory] Calling API to save to DB');
            try {
                await updateContinueWatchingAPI(id, type, title, posterUrl, 0, currentSeason, currentEpisode);
                console.log('[addToWatchHistory] Saved to DB successfully');
                // Reload from database to keep data in sync
                await loadContinueWatching();
            } catch (error) {
                console.error('[addToWatchHistory] Failed to save to DB:', error);
            }
        }

        function updateContinueWatching() {
            // This function is no longer used, kept for backwards compatibility
        }

        function displayContinueWatchingInResults() {
            const continueWatchingDisplay = document.getElementById('continueWatchingDisplay');

            // Only display if continue-watching tab is active
            if (currentTab !== 'continue-watching') {
                return; // Data is loaded but not displayed until tab is clicked
            }

            // Filter out items with >90% progress and sort by most recently watched
            const filteredHistory = watchHistory
                .filter(item => item.progress < 90)
                .sort((a, b) => new Date(b.lastWatched) - new Date(a.lastWatched));

            if (filteredHistory.length === 0) {
                continueWatchingDisplay.innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px; grid-column: 1 / -1;">
                        <h3>No items in Continue Watching</h3>
                        <p>Login & Start watching movies and TV shows to see them here</p>
                    </div>
                `;
                return;
            }

            continueWatchingDisplay.innerHTML = filteredHistory.map(item => {
                return `
                    <div class="continue-item content-card" data-id="${item.id}" data-type="${item.type}" onclick="resumeContent(${item.id}, '${item.title.replace(/'/g, "\\'")}', '${item.type}', ${item.season || 1}, ${item.episode || 1}, ${item.progress || 0})">
                        <button class="watchlist-remove-btn" onclick="event.stopPropagation(); removeFromHistory(${item.id}, '${item.type}')" title="Remove from Continue Watching"></button>
                        ${item.type === 'tv' ? `<div class="continue-episode-badge">S${item.season}E${item.episode}</div>` : ''}
                        <img src="${item.posterUrl}" alt="${item.title}" class="continue-poster"
                             onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Poster'">
                        <div class="omdb-ratings-tooltip" style="display: none;">
                            <div class="tooltip-loading">Loading ratings...</div>
                        </div>
                        <div class="continue-info">
                            <div class="continue-title">${item.title}</div>
                            <div class="continue-progress">${item.type.toUpperCase()}  ${item.year}</div>
                            <div class="continue-last-watched">Watched ${new Date(item.lastWatched).toLocaleDateString()}</div>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${item.progress}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function removeFromHistory(id, type) {
            // Require authentication
            if (!authToken) {
                showError('Please login to manage watch history');
                return;
            }

            try {
                // Remove from database
                await apiRequest(`/continue-watching/${id}`, {
                    method: 'DELETE'
                });

                // Reload from database
                await loadContinueWatching();
            } catch (error) {
                console.error('Failed to remove from continue watching:', error);
                showError('Failed to remove from continue watching');
            }
        }

        async function resumeContent(id, title, type, season, episode, progress) {
            hideError();

            // Clear episode description from previous content
            const epDescSection = document.getElementById('episodeDescription');
            const epDescText = document.getElementById('episodeDescriptionText');
            if (epDescSection) epDescSection.style.display = 'none';
            if (epDescText) epDescText.textContent = '';

            // Scroll to poster/player section immediately
            const standalonePoster = document.getElementById('currentPoster');
            if (standalonePoster && standalonePoster.style.display !== 'none') {
                standalonePoster.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                const playerSection = document.querySelector('.player-section');
                if (playerSection) {
                    playerSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }

            try {
                currentContentId = id;
                currentContentType = type;

                let endpoint;
                if (type === 'tv') {
                    endpoint = `${API_BASE_URL}/tv/${id}`;
                } else {
                    endpoint = `${API_BASE_URL}/movie/${id}`;
                }

                const response = await fetch(endpoint);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                currentContentData = data;

                // Update current content display
                const currentContent = document.getElementById('currentContent');
                const tvControls = document.getElementById('tvControls');

                const titleEl = document.getElementById('currentTitle');
                const yearEl = document.getElementById('currentYear');
                const ratingEl = document.getElementById('currentRating');
                const overviewEl = document.getElementById('currentOverview');

                if (titleEl) titleEl.textContent = type === 'tv' ? data.name : data.title;
                if (yearEl) yearEl.textContent = type === 'tv' ?
                    (data.first_air_date ? data.first_air_date.substring(0, 4) : 'Unknown') :
                    (data.release_date ? data.release_date.substring(0, 4) : 'Unknown');
                if (ratingEl) ratingEl.textContent = ` ${data.vote_average ? data.vote_average.toFixed(1) : 'N/A'}/10`;
                if (overviewEl) overviewEl.textContent = data.overview || 'No description available';

                const posterEl = document.getElementById('currentPoster');
                if (posterEl) {
                    if (data.poster_url) {
                        posterEl.src = data.poster_url;
                        posterEl.style.display = 'block';
                    } else {
                        posterEl.style.display = 'none';
                    }
                }

                // Load backdrop image
                const backdropEl = document.getElementById('backdropImage');
                console.log('Resume - Backdrop element:', backdropEl);
                console.log('Resume - Backdrop URL:', data.backdrop_url);
                if (backdropEl && data.backdrop_url) {
                    backdropEl.style.backgroundImage = `url(${data.backdrop_url})`;
                    backdropEl.classList.add('loaded');
                    console.log('Resume - Backdrop loaded:', backdropEl.style.backgroundImage);
                } else if (backdropEl) {
                    backdropEl.style.backgroundImage = '';
                    backdropEl.classList.remove('loaded');
                    console.log('Resume - Backdrop cleared or not available');
                }

                // Populate OMDB data if available
                const omdbRatingsEl = document.getElementById('omdbRatings');
                const omdbDetailsEl = document.getElementById('omdbDetails');

                if (omdbRatingsEl && data.omdb_ratings && data.omdb_ratings.length > 0) {
                    const imdbRating = data.omdb_imdb_rating || 'N/A';
                    let rtRating = 'N/A';
                    let metacriticRating = 'N/A';

                    data.omdb_ratings.forEach(rating => {
                        if (rating.Source === 'Rotten Tomatoes') {
                            rtRating = rating.Value;
                        } else if (rating.Source === 'Metacritic') {
                            metacriticRating = rating.Value;
                        }
                    });

                    const imdbEl = document.getElementById('imdbRating');
                    const rtEl = document.getElementById('rtRating');
                    const metacriticEl = document.getElementById('metacriticRating');

                    if (imdbEl) imdbEl.textContent = imdbRating;
                    if (rtEl) rtEl.textContent = rtRating;
                    if (metacriticEl) metacriticEl.textContent = metacriticRating;
                    omdbRatingsEl.style.display = 'flex';
                } else if (omdbRatingsEl) {
                    omdbRatingsEl.style.display = 'none';
                }

                // Populate OMDB details if available
                if (omdbDetailsEl && (currentContentData.tmdb_cast || currentContentData.omdb_actors || currentContentData.omdb_director || currentContentData.omdb_genre || currentContentData.omdb_rated || currentContentData.omdb_runtime || currentContentData.omdb_awards)) {
                    const actorsEl = document.getElementById('omdbActors');
                    const castSection = document.getElementById('castSection');
                    const castGrid = document.getElementById('castGrid');
                    const directorEl = document.getElementById('omdbDirector');
                    const genreEl = document.getElementById('omdbGenre');
                    const ratedEl = document.getElementById('omdbRated');
                    const runtimeEl = document.getElementById('omdbRuntime');
                    const awardsEl = document.getElementById('omdbAwards');

                    // Display TMDB cast with images if available
                    if (castSection && castGrid && currentContentData.tmdb_cast && currentContentData.tmdb_cast.length > 0) {
                        castGrid.innerHTML = '';
                        currentContentData.tmdb_cast.forEach(actor => {
                            const castMember = document.createElement('div');
                            castMember.className = 'cast-member';

                            if (actor.profile_url) {
                                const img = document.createElement('img');
                                img.src = actor.profile_url;
                                img.alt = actor.name;
                                img.className = 'cast-member-image';
                                castMember.appendChild(img);
                            } else {
                                const placeholder = document.createElement('div');
                                placeholder.className = 'cast-member-image placeholder';
                                placeholder.textContent = actor.name.charAt(0);
                                castMember.appendChild(placeholder);
                            }

                            const nameDiv = document.createElement('div');
                            nameDiv.className = 'cast-member-name';
                            nameDiv.textContent = actor.name;
                            nameDiv.title = actor.name;
                            castMember.appendChild(nameDiv);

                            if (actor.character) {
                                const characterDiv = document.createElement('div');
                                characterDiv.className = 'cast-member-character';
                                characterDiv.textContent = actor.character;
                                characterDiv.title = actor.character;
                                castMember.appendChild(characterDiv);
                            }

                            castGrid.appendChild(castMember);
                        });
                        castSection.style.display = 'block';
                        actorsEl.style.display = 'none';
                    } else if (actorsEl && currentContentData.omdb_actors) {
                        // Fallback to OMDB text if no TMDB cast
                        const span = actorsEl.querySelector('span');
                        if (span) span.textContent = currentContentData.omdb_actors;
                        actorsEl.style.display = 'block';
                        if (castSection) castSection.style.display = 'none';
                    } else {
                        if (actorsEl) actorsEl.style.display = 'none';
                        if (castSection) castSection.style.display = 'none';
                    }

                    if (directorEl) {
                        if (currentContentData.omdb_director && currentContentData.omdb_director !== 'N/A') {
                            const span = directorEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_director;
                            directorEl.style.display = 'block';
                        } else {
                            directorEl.style.display = 'none';
                        }
                    }

                    if (genreEl) {
                        if (currentContentData.omdb_genre) {
                            const span = genreEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_genre;
                            genreEl.style.display = 'block';
                        } else {
                            genreEl.style.display = 'none';
                        }
                    }

                    if (ratedEl) {
                        if (currentContentData.omdb_rated && currentContentData.omdb_rated !== 'N/A') {
                            const span = ratedEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_rated;
                            ratedEl.style.display = 'block';
                        } else {
                            ratedEl.style.display = 'none';
                        }
                    }

                    if (runtimeEl) {
                        if (currentContentData.omdb_runtime) {
                            const span = runtimeEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_runtime;
                            runtimeEl.style.display = 'block';
                        } else {
                            runtimeEl.style.display = 'none';
                        }
                    }

                    if (awardsEl) {
                        if (currentContentData.omdb_awards && currentContentData.omdb_awards !== 'N/A') {
                            const span = awardsEl.querySelector('span');
                            if (span) span.textContent = currentContentData.omdb_awards;
                            awardsEl.style.display = 'block';
                        } else {
                            awardsEl.style.display = 'none';
                        }
                    }

                    omdbDetailsEl.style.display = 'block';
                } else if (omdbDetailsEl) {
                    omdbDetailsEl.style.display = 'none';
                }

                currentContent.style.display = 'flex';

                // Initialize player background effects
                // initPlayerBackgroundEffects();

                // Show the player section
                document.getElementById('playerSection').style.display = 'block';

                if (type === 'tv') {
                    // Setup TV show controls and set to last watched episode
                    tvControls.style.display = 'block';
                    await setupSeasonEpisodeSelectors(data);

                    // Set the current season and episode to the last watched
                    currentSelectedSeason = season;
                    currentSelectedEpisode = episode;
                    document.getElementById('seasonButtonText').textContent = `Season ${season}`;
                    await updateEpisodeSelector(season);
                    document.getElementById('episodeButtonText').textContent = getEpisodeButtonText(episode, season);

                    // Update episode description for the resumed episode
                    const cacheKey = `${id}_${season}`;
                    const cachedSeason = episodeCache[cacheKey];
                    if (cachedSeason && cachedSeason.episodes) {
                        const ep = cachedSeason.episodes.find(e => e.episode_number === episode);
                        if (ep && ep.overview && ep.overview.trim() !== '') {
                            const descSection = document.getElementById('episodeDescription');
                            const descText = document.getElementById('episodeDescriptionText');
                            if (descText) descText.textContent = ep.overview;
                            if (descSection) descSection.style.display = 'block';
                        }
                    }

                    playTVEpisode(id, season, episode, progress);
                } else {
                    // Play movie
                    tvControls.style.display = 'none';

                    // Hide next episode button for movies
                    const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
                    if (nextEpisodeBtn) nextEpisodeBtn.style.display = 'none';

                    playMovie(id, progress);
                }

                // Update watch history with current time
                updateWatchHistoryItem(id, title, type, data, season, episode, progress);

                // Update player watchlist button
                updatePlayerWatchlistButton(id, type);

                // Update video source button
                updateVideoSourceButton();

            } catch (error) {
                console.error('Resume content error:', error);
                showError(`Failed to resume content: ${error.message}`);
            }
        }

        async function updateWatchHistoryItem(id, title, type, data, season, episode, progress) {
            const historyItem = {
                id: id,
                title: title,
                type: type,
                posterUrl: data.poster_url || 'https://via.placeholder.com/60x90/333/fff?text=No+Poster',
                year: type === 'tv' ?
                    (data.first_air_date ? data.first_air_date.substring(0, 4) : 'Unknown') :
                    (data.release_date ? data.release_date.substring(0, 4) : 'Unknown'),
                rating: data.vote_average ? data.vote_average.toFixed(1) : 'N/A',
                lastWatched: new Date().toISOString(),
                progress: progress || 0,
                season: season || 1,
                episode: episode || 1
            };

            // If user is logged in, use API
            if (authToken) {
                try {
                    await updateContinueWatchingAPI(
                        id,
                        type,
                        title,
                        historyItem.posterUrl,
                        progress,
                        season,
                        episode
                    );
                    // Reload from database to keep data in sync
                    await loadContinueWatching();
                } catch (error) {
                    console.error('Failed to update continue watching:', error);
                }
            } else {
                // Fallback to localStorage for non-authenticated users
                const existingIndex = watchHistory.findIndex(item => item.id === id && item.type === type);
                if (existingIndex > -1) {
                    watchHistory[existingIndex] = historyItem;
                } else {
                    watchHistory.unshift(historyItem);
                    watchHistory = watchHistory.slice(0, 20);
                }
                localStorage.setItem('streamingSite_watchHistory', JSON.stringify(watchHistory));
                updateContinueWatching();
            }
        }

        // Auto-hide status messages after 5 seconds
        setInterval(() => {
            const statusBar = document.getElementById('statusBar');
            if (statusBar.style.display === 'block') {
                setTimeout(() => hideStatus(), 5000);
            }
        }, 1000);

        // Subtitle functionality
        let currentSubtitles = [];
        let activeSubtitleUrl = null;

        async function loadSubtitles() {
            if (!currentContentId || !currentContentData) {
                showError('Please load a movie or TV show first');
                return;
            }

            // Show subtitle modal
            document.getElementById('subtitleModal').style.display = 'block';

            // Get language selection
            const language = document.getElementById('subtitleLanguage').value;

            // Build request parameters
            const params = new URLSearchParams({
                tmdb_id: currentContentId,
                type: currentContentType,
                language: language
            });

            if (currentContentType === 'tv') {
                const season = document.getElementById('seasonSelect')?.value || 1;
                const episode = document.getElementById('episodeSelect')?.value || 1;
                params.append('season', season);
                params.append('episode', episode);
            }

            try {

                const response = await fetch(`${API_BASE_URL}/subtitles/search?${params}`);
                const data = await response.json();

                currentSubtitles = data.subtitles || [];

                if (currentSubtitles.length === 0) {
                    document.getElementById('subtitleList').innerHTML = `
                        <div style="text-align: center; color: #666; padding: 40px;">
                            <h3>No subtitles found</h3>
                            <p>Try a different language or paste a custom subtitle URL below</p>
                        </div>
                    `;
                } else {
                    displaySubtitleList(currentSubtitles);
                    // showStatus(`Found ${currentSubtitles.length} subtitles`);
                }

            } catch (error) {
                console.error('Subtitle search error:', error);
                showError('Failed to search for subtitles');
                document.getElementById('subtitleList').innerHTML = `
                    <div style="text-align: center; color: #666; padding: 40px;">
                        <h3>Error loading subtitles</h3>
                        <p>Please try again or paste a custom subtitle URL below</p>
                    </div>
                `;
            }
        }

        function displaySubtitleList(subtitles) {
            const listDiv = document.getElementById('subtitleList');

            listDiv.innerHTML = subtitles.map((sub, index) => {
                const downloads = parseInt(sub.SubDownloadsCnt || 0);
                const rating = parseFloat(sub.SubRating || 0);
                const fileName = sub.SubFileName || 'Unknown';
                const downloadUrl = sub.SubDownloadLink || sub.ZipDownloadLink;
                const isSearchPage = sub.IsSearchPage === true;
                const source = sub.Source || 'Unknown';

                const buttonText = isSearchPage ? 'Open Search' : 'Load';
                const buttonAction = isSearchPage ? `openSubtitleSearch('${downloadUrl}', '${source}')` : `selectSubtitle('${downloadUrl}')`;

                return `
                    <div style="background: rgba(58, 58, 60, 0.12); backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 16px; margin-bottom: 12px; transition: all 0.3s;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; color: #fff; margin-bottom: 4px;">
                                    ${fileName}
                                    ${isSearchPage ? '<span style="color: #007AFF; font-size: 11px; margin-left: 8px;"> Search Page</span>' : ''}
                                </div>
                                <div style="color: #888; font-size: 13px; margin-bottom: 4px;">
                                    Source: ${source} | Downloads: ${downloads.toLocaleString()} | Rating: ${''.repeat(Math.round(rating))}
                                </div>
                                ${isSearchPage ? '<div style="color: #666; font-size: 12px; font-style: italic;">Opens search page - download manually</div>' : ''}
                            </div>
                            <button class="btn" style="padding: 8px 16px; margin-left: 12px;" onclick="event.stopPropagation(); ${buttonAction}">
                                ${buttonText}
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function openSubtitleSearch(url, source) {
            // Open the search page in a new tab
            window.open(url, '_blank');
            showStatus(`Opened ${source} search page. Download subtitle and paste URL below.`);
        }

        async function selectSubtitle(downloadUrl) {
            try {
                showStatus('Processing subtitle...');

                // Use our proxy endpoint to handle CORS and format conversion
                const proxyUrl = `${API_BASE_URL}/subtitles/proxy?url=${encodeURIComponent(downloadUrl)}`;

                // Test if subtitle is accessible
                try {
                    const testResponse = await fetch(proxyUrl);
                    if (!testResponse.ok) {
                        throw new Error('Subtitle not accessible');
                    }
                } catch (err) {
                    showError('Could not load subtitle from that URL. Try a different one or use a direct .srt/.vtt link.');
                    return;
                }

                activeSubtitleUrl = proxyUrl;

                // Store subtitle preference
                localStorage.setItem('lastSubtitleUrl', downloadUrl);

                // Show success message with download option
                const modalContent = document.querySelector('#subtitleModal > div');
                modalContent.innerHTML = `
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 64px; margin-bottom: 20px;"></div>
                        <h2 style="color: #fff; margin-bottom: 16px;">Subtitle Ready!</h2>
                        <p style="color: #a1a1a6; margin-bottom: 32px;">Due to browser security, subtitles can't display in embedded players.<br/>Here are your options:</p>

                        <div style="background: rgba(58, 58, 60, 0.12); border-radius: 12px; padding: 24px; margin-bottom: 20px; text-align: left;">
                            <h3 style="color: #007AFF; margin-bottom: 16px;">Option 1: Download Subtitle File</h3>
                            <p style="color: #ccc; margin-bottom: 16px; font-size: 14px;">Download and add manually to your video player</p>
                            <a href="${proxyUrl}" download="subtitle.vtt" class="btn" style="display: inline-block; margin-bottom: 8px;">
                                 Download Subtitle File
                            </a>
                            <p style="color: #666; font-size: 12px; margin-top: 8px;">Use with VLC, MPV, or any video player</p>
                        </div>

                        <div style="background: rgba(58, 58, 60, 0.12); border-radius: 12px; padding: 24px; margin-bottom: 20px; text-align: left;">
                            <h3 style="color: #007AFF; margin-bottom: 16px;">Option 2: Copy Subtitle URL</h3>
                            <input type="text" value="${proxyUrl}" readonly
                                   style="width: 100%; padding: 12px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: #fff; font-family: monospace; font-size: 12px; margin-bottom: 12px;"
                                   onclick="this.select()">
                            <button onclick="navigator.clipboard.writeText('${proxyUrl}'); showStatus('Copied to clipboard!');" class="btn btn-secondary">
                                Copy URL
                            </button>
                            <p style="color: #666; font-size: 12px; margin-top: 8px;">Paste in VLC, MPV, or HTML5 video player</p>
                        </div>

                        <div style="background: rgba(58, 58, 60, 0.12); border-radius: 12px; padding: 24px; margin-bottom: 32px; text-align: left;">
                            <h3 style="color: #007AFF; margin-bottom: 16px;">Option 3: Use with External Player</h3>
                            <p style="color: #ccc; margin-bottom: 16px; font-size: 14px;">
                                1. Click "Copy URL" to copy the video URL<br/>
                                2. Open the URL in your external player along with the subtitle URL above
                            </p>
                        </div>

                        <button onclick="closeSubtitleModal(); location.reload();" class="btn" style="margin-right: 10px;">
                             Back to Subtitles
                        </button>
                        <button onclick="closeSubtitleModal();" class="btn btn-secondary">
                            Close
                        </button>
                    </div>
                `;

                showStatus(' Subtitle processed and ready!');
                console.log('Subtitle VTT URL:', proxyUrl);

            } catch (error) {
                console.error('Subtitle load error:', error);
                showError('Failed to load subtitle. Make sure it\'s a direct download link (.srt or .vtt file).');
            }
        }

        async function loadCustomSubtitle() {
            const url = document.getElementById('customSubtitleUrl').value.trim();

            if (!url) {
                showError('Please enter a subtitle URL');
                return;
            }

            try {
                // Validate URL
                new URL(url);

                // Use proxy to load it
                await selectSubtitle(url);

            } catch (error) {
                showError('Invalid URL');
            }
        }

        function closeSubtitleModal() {
            document.getElementById('subtitleModal').style.display = 'none';
        }

        // Close modal when clicking outside
        document.getElementById('subtitleModal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeSubtitleModal();
            }
        });

        // Open video with subtitle player
        function openWithSubtitles() {
            if (!currentContentUrl) {
                showError('Please load a movie or TV show first');
                return;
            }

            const subtitlePlayerUrl = `/video_player_with_subtitles.html?video=${encodeURIComponent(currentContentUrl)}`;
            window.open(subtitlePlayerUrl, '_blank', 'width=1280,height=720');
            showStatus(' Opened subtitle player! Click " Get Subtitles" to find subtitles, then paste the URL in the new window.');
        }

        // ============= WATCHPARTY FUNCTIONS =============

        let serverUrl = window.location.origin;

        async function initSocket() {
            if (socket && socket.connected) return socket;

            // Use the current page's origin for Socket.IO connection
            // This works for both localhost and ngrok
            serverUrl = window.location.origin;
            console.log('Connecting Socket.IO to:', serverUrl);

            socket = io(serverUrl, {
                path: '/socket.io/',
                transports: ['polling', 'websocket'],
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionAttempts: 5,
                timeout: 10000
            });

            // Wait for connection
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.error('Socket connection timeout after 10s');
                    reject(new Error('Socket connection timeout'));
                }, 10000);

                socket.on('connect', () => {
                    clearTimeout(timeout);
                    console.log('Socket connected successfully, ID:', socket.id);
                    setupSocketListeners();
                    resolve(socket);
                });

                socket.on('connect_error', (error) => {
                    clearTimeout(timeout);
                    console.error('Socket connection error:', error);
                    reject(error);
                });
            });
        }

        function setupSocketListeners() {

            socket.on('connected', (data) => {
                console.log('Socket connected:', data.sid);
            });

            socket.on('party_created', (data) => {
                watchpartyActive = true;
                watchpartyRoomCode = data.room_code;
                isHost = true;
                watchpartyUsers = data.users;
                showWatchpartySidebar();
                updateWatchpartyUI(data);
                closeWatchpartyMenu();
                // showStatus(`Watchparty created! Room code: ${data.room_code}`);

                // Re-setup video sync listeners for already-playing content
                const playerVideo = document.getElementById('playerVideo');
                if (playerVideo && playerVideo.style.display !== 'none') {
                    console.log('[Party Created] Re-attaching sync listeners to active video');
                    videoSyncListenersAttached = false; // Reset flag to allow re-attachment
                    setupVideoSyncListeners(playerVideo);
                } else {
                    console.log('[Party Created] No active video to attach sync listeners');
                }
            });

            socket.on('party_joined', (data) => {
                console.log('[Party Joined] Received data:', data);

                watchpartyActive = true;
                watchpartyRoomCode = data.room_code;
                isHost = data.is_host;
                watchpartyUsers = data.users;
                showWatchpartySidebar();
                updateWatchpartyUI(data);
                closeWatchpartyMenu();
                // showStatus(`Joined watchparty: ${data.room_code}`);

                // Re-setup video sync listeners if joining as host
                if (isHost) {
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        console.log('[Party Joined as Host] Re-attaching sync listeners to active video');
                        videoSyncListenersAttached = false; // Reset flag to allow re-attachment
                        setupVideoSyncListeners(playerVideo);
                    } else {
                        console.log('[Party Joined as Host] No active video to attach sync listeners');
                    }
                }

                // Pick up current sync mode from room
                if (data.sync_mode && data.sync_mode !== 'none') {
                    partySyncMode = data.sync_mode;
                    updateSyncStatusBadge();
                }

                // Sync content if joining as guest
                console.log('[Party Joined] Is host:', isHost, 'Content:', data.content);
                if (!isHost && data.content && data.content.id) {
                    console.log('[Party Joined] Guest syncing content from host');
                    syncContentFromHost(data.content);
                } else if (!isHost) {
                    console.log('[Party Joined] No content to sync (host hasnt loaded anything yet)');
                }
            });

            socket.on('join_error', (data) => {
                showError(data.message || 'Failed to join watchparty');
            });

            socket.on('user_joined', (data) => {
                watchpartyUsers = data.users;
                updateUsersList(data.users);
                addSystemMessage(`${data.username} joined the party`);
            });

            socket.on('user_left', (data) => {
                watchpartyUsers = data.users;
                updateUsersList(data.users);
                addSystemMessage(`${data.username} left the party`);
            });

            socket.on('new_host', (data) => {
                isHost = (username === data.username);
                addSystemMessage(`${data.username} is now the host`);
                // showStatus(`${data.username} is now controlling playback`);

                // Re-setup video sync listeners if I'm the new host
                if (isHost) {
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        console.log('[New Host] Re-attaching sync listeners to active video');
                        videoSyncListenersAttached = false; // Reset flag to allow re-attachment
                        setupVideoSyncListeners(playerVideo);
                    } else {
                        console.log('[New Host] No active video to attach sync listeners');
                    }
                    showStatus('You are now the host! You control playback for all guests.');
                }
            });

            socket.on('play_sync', (data) => {
                if (!isHost) {
                    console.log('[Guest] Received play_sync from host:', data);
                    showSyncIndicator(`Host resumed playback at ${formatTime(data.currentTime)}`);

                    // Set syncing flag to prevent loop
                    isSyncing = true;

                    // Check if using video element (live channels OR movies/TV with direct streams) or iframe (movies/TV embeds)
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        // For direct streams: control video element (works for live channels AND movies/TV)
                        console.log('[Guest] Syncing video element play at', data.currentTime);
                        playerVideo.currentTime = data.currentTime;
                        playerVideo.play().catch(e => console.log('Play prevented:', e));
                    } else if (currentContentUrl && data.currentTime !== undefined) {
                        // For embed iframes: reload with timestamp (movies/TV only)
                        console.log('[Guest] Reloading iframe with timestamp', data.currentTime);
                        reloadPlayerWithTimestamp(data.currentTime);
                    }

                    // Reset flag after a delay
                    setTimeout(() => { isSyncing = false; }, 1000);
                }
            });

            socket.on('pause_sync', (data) => {
                if (!isHost) {
                    console.log('[Guest] Received pause_sync from host:', data);
                    showSyncIndicator(`Host paused at ${formatTime(data.currentTime)}`);

                    // Set syncing flag to prevent loop
                    isSyncing = true;

                    // Check if using video element (live channels OR movies/TV with direct streams) or iframe (movies/TV embeds)
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        // For direct streams: control video element (works for live channels AND movies/TV)
                        console.log('[Guest] Syncing video element pause at', data.currentTime);
                        playerVideo.currentTime = data.currentTime;
                        playerVideo.pause();
                    } else if (currentContentUrl && data.currentTime !== undefined) {
                        // For embed iframes: reload with timestamp (movies/TV only)
                        console.log('[Guest] Reloading iframe with timestamp', data.currentTime);
                        reloadPlayerWithTimestamp(data.currentTime);
                    }

                    // Reset flag after a delay
                    setTimeout(() => { isSyncing = false; }, 1000);
                }
            });

            socket.on('seek_sync', (data) => {
                if (!isHost) {
                    console.log('[Guest] Received seek_sync from host:', data);
                    showSyncIndicator(`Host seeked to ${formatTime(data.currentTime)}`);

                    // Set syncing flag to prevent loop
                    isSyncing = true;

                    // Check if using video element (live channels OR movies/TV with direct streams) or iframe (movies/TV embeds)
                    const playerVideo = document.getElementById('playerVideo');
                    if (playerVideo && playerVideo.style.display !== 'none') {
                        // For direct streams: control video element (works for live channels AND movies/TV)
                        console.log('[Guest] Syncing video element seek to', data.currentTime);
                        playerVideo.currentTime = data.currentTime;
                    } else if (currentContentUrl && data.currentTime !== undefined) {
                        // For embed iframes: reload with timestamp (movies/TV only)
                        console.log('[Guest] Reloading iframe with timestamp', data.currentTime);
                        reloadPlayerWithTimestamp(data.currentTime);
                    }

                    // Reset flag after a delay
                    setTimeout(() => { isSyncing = false; }, 1000);
                }
            });

            socket.on('content_sync', (data) => {
                if (!isHost && data.content) {
                    showSyncIndicator(`Host changed content`);
                    syncContentFromHost(data.content);
                }
            });

            socket.on('stop_sync', (data) => {
                if (!isHost) {
                    showSyncIndicator(`Host stopped playback`);
                    stopPlayback();
                }
            });

            socket.on('chat_message', (data) => {
                addChatMessage(data);
            });

            // ============= PLAYBACK SYNC LISTENERS =============

            socket.on('playback_play', (data) => {
                console.log('[Sync] Received playback_play from', data.username, 'at', data.currentTime);
                vidkingHostTime = data.currentTime;

                isSyncing = true;
                reloadIframeForSync(data.currentTime, true);
                showStatus(` ${data.username} played`);
                setTimeout(() => { isSyncing = false; }, 1000);
            });

            socket.on('playback_pause', (data) => {
                console.log('[Sync] Received playback_pause from', data.username, 'at', data.currentTime);
                vidkingHostTime = data.currentTime;

                isSyncing = true;
                reloadIframeForSync(data.currentTime, false);
                showStatus(` ${data.username} paused`);
                setTimeout(() => { isSyncing = false; }, 1000);
            });

            socket.on('playback_seek', (data) => {
                console.log('[Sync] Received playback_seek from', data.username, 'to', data.currentTime);
                vidkingHostTime = data.currentTime;

                isSyncing = true;
                reloadIframeForSync(data.currentTime, true);
                showStatus(` ${data.username} seeked`);
                setTimeout(() => { isSyncing = false; }, 1000);
            });

            socket.on('sync_status', (data) => {
                const playerVideo = document.getElementById('playerVideo');

                if (playerVideo && playerVideo.style.display !== 'none' && !playerVideo.paused) {
                    const currentTime = playerVideo.currentTime;
                    const expectedTime = data.currentTime;
                    const drift = Math.abs(currentTime - expectedTime);

                    console.log('[Drift] Current:', currentTime.toFixed(1), 'Expected:', expectedTime.toFixed(1), 'Drift:', drift.toFixed(1) + 's');

                    // If drift is more than 2 seconds, auto-correct
                    if (drift > 2) {
                        console.log('[Drift]  Drift detected! Auto-correcting...');
                        isSyncing = true;
                        playerVideo.currentTime = expectedTime;
                        setTimeout(() => { isSyncing = false; }, 500);
                    }
                }
            });

            socket.on('manual_sync', (data) => {
                console.log('[Sync] Manual sync from', data.username, 'at', data.currentTime);
                vidkingHostTime = data.currentTime;
                isSyncing = true;
                reloadIframeForSync(data.currentTime, true);
                showStatus(`Synced to ${data.username}'s position`);
                setTimeout(() => { isSyncing = false; }, 1000);
            });

            socket.on('party_left', () => {
                resetWatchparty();
            });

            // ============= COORDINATED SYNC LISTENERS =============

            socket.on('sync_mode_changed', (data) => {
                console.log('[Sync] Mode changed to:', data.mode);
                partySyncMode = data.mode;
                updateSyncStatusBadge();
            });

            socket.on('ready_check_started', (data) => {
                console.log('[Sync] Ready check started, total:', data.total);
                userIsReady = false;
                const overlay = document.getElementById('readyCheckOverlay');
                const readyBtn = document.getElementById('readyBtn');
                const forceBtn = document.getElementById('forceStartBtn');
                const countEl = document.getElementById('readyCount');

                countEl.textContent = `0/${data.total} Ready`;
                readyBtn.disabled = false;
                readyBtn.textContent = "I'm Ready";
                forceBtn.style.display = isHost ? 'block' : 'none';
                overlay.classList.add('active');
            });

            socket.on('user_ready_update', (data) => {
                console.log('[Sync] User ready:', data.username, `(${data.ready_count}/${data.total})`);
                const countEl = document.getElementById('readyCount');
                countEl.textContent = `${data.ready_count}/${data.total} Ready`;

                // Auto-start countdown when all ready
                if (data.ready_count >= data.total && isHost) {
                    setTimeout(() => {
                        if (socket) socket.emit('start_countdown', { currentTime: vidkingHostTime });
                    }, 500);
                }
            });

            socket.on('countdown_start', (data) => {
                console.log('[Sync] Countdown starting');
                vidkingHostTime = data.currentTime || vidkingHostTime;
                document.getElementById('readyCheckOverlay').classList.remove('active');
                startCountdownSequence();
            });

            socket.on('resync_triggered', (data) => {
                console.log('[Sync] Re-sync triggered');
                vidkingHostTime = data.currentTime || vidkingHostTime;
                startCountdownSequence();
            });

        }

        function showWatchpartyMenu() {
            // Set default username if not already set
            if (!username) {
                username = 'User' + Math.floor(Math.random() * 1000);
            }

            // Populate username input field
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.value = username;
            }

            initSocket();
            document.getElementById('watchpartyMenuModal').style.display = 'flex';
        }

        window.closeWatchpartyMenu = function() {
            document.getElementById('watchpartyMenuModal').style.display = 'none';
            // Also close the watchparty panel
            const panel = document.getElementById('watchpartyPanel');
            if (panel) {
                panel.classList.remove('active');
            }
        }

        window.createWatchparty = async function() {
            // Get username from input field
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput && usernameInput.value.trim()) {
                username = usernameInput.value.trim();
            }

            if (!username) {
                showError('Please enter a display name');
                return;
            }

            try {
                if (!socket || !socket.connected) {
                    await initSocket();
                }
            } catch (error) {
                showError('Unable to connect to server. Please try again.');
                return;
            }

            // Lock source to VidSrc for best sync support
            lockSourceForParty();

            let contentData = null;

            // Include content data if available
            if (currentContentId) {
                // Determine stream type based on current player state
                const playerVideo = document.getElementById('playerVideo');
                const isDirectStream = playerVideo && playerVideo.style.display !== 'none';
                const currentStreamType = isDirectStream ? 'direct' : 'embed';

                contentData = {
                    id: currentContentId,
                    title: currentContentData?.title || currentContentData?.name || 'Unknown',
                    type: currentContentType,
                    posterUrl: currentContentData?.poster_url || '',
                    url: currentContentUrl,
                    stream_url: currentContentUrl,
                    stream_type: currentStreamType
                };

                // Add season/episode for TV shows
                if (currentContentType === 'tv') {
                    const seasonSelect = document.getElementById('seasonSelect');
                    const episodeSelect = document.getElementById('episodeSelect');
                    if (seasonSelect && episodeSelect) {
                        contentData.season = parseInt(seasonSelect.value);
                        contentData.episode = parseInt(episodeSelect.value);
                    }
                }
            }

            socket.emit('create_party', {
                username: username,
                content: contentData
            });
        }

        window.joinWatchparty = async function() {
            // Get username from input field
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput && usernameInput.value.trim()) {
                username = usernameInput.value.trim();
            }

            if (!username) {
                showError('Please enter a display name');
                return;
            }

            const roomCode = document.getElementById('joinRoomCodeInput').value.trim().toUpperCase();

            if (!roomCode || roomCode.length !== 6) {
                showError('Please enter a valid 6-character room code');
                return;
            }

            try {
                if (!socket || !socket.connected) {
                    await initSocket();
                }
            } catch (error) {
                showError('Unable to connect to server. Please try again.');
                return;
            }

            // Lock source to VidSrc for best sync support
            lockSourceForParty();

            socket.emit('join_party', {
                room_code: roomCode,
                username: username
            });
        }

        function leaveWatchparty() {
            console.log('leaveWatchparty() called');
            // Show popup positioned near X button
            const modal = document.getElementById('leaveWatchpartyModal');
            console.log('Modal element:', modal);
            if (modal) {
                modal.style.display = 'block';
                console.log('Popup should now be visible');

                // Add click outside handler
                setTimeout(() => {
                    const clickOutsideHandler = (e) => {
                        if (!modal.contains(e.target) && !e.target.classList.contains('watchparty-close')) {
                            closeLeaveWatchpartyModal();
                            document.removeEventListener('click', clickOutsideHandler);
                        }
                    };
                    document.addEventListener('click', clickOutsideHandler);
                }, 100);

                // Add escape key handler
                const escapeHandler = (e) => {
                    if (e.key === 'Escape') {
                        closeLeaveWatchpartyModal();
                        document.removeEventListener('keydown', escapeHandler);
                    }
                };
                document.addEventListener('keydown', escapeHandler);
            } else {
                console.error('leaveWatchpartyModal not found!');
            }
        }

        function closeLeaveWatchpartyModal() {
            const modal = document.getElementById('leaveWatchpartyModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function confirmLeaveWatchparty() {
            closeLeaveWatchpartyModal();
            if (socket) {
                socket.emit('leave_party');
            }
            resetWatchparty();
        }

        // ============= COORDINATED SYNC HELPERS =============

        function lockSourceForParty() {
            if (videoSource !== 'vidking') {
                previousVideoSource = videoSource;
                videoSource = 'vidking';
                localStorage.setItem('videoSource', 'vidking');
            } else {
                previousVideoSource = null;
            }
            partySourceLocked = true;
            updateVideoSourceButton();

            // Reload current content with VidKing if something is playing
            if (currentContentId && previousVideoSource) {
                if (currentContentType === 'movie') {
                    playMovie(currentContentId, 0);
                } else if (currentContentType === 'tv' && currentSelectedSeason && currentSelectedEpisode) {
                    playTVEpisode(currentContentId, currentSelectedSeason, currentSelectedEpisode, 0);
                }
            }
        }

        function unlockSourceAfterParty() {
            partySourceLocked = false;
            if (previousVideoSource) {
                videoSource = previousVideoSource;
                localStorage.setItem('videoSource', previousVideoSource);
                previousVideoSource = null;
            }
            updateVideoSourceButton();
        }

        function updateSyncStatusBadge() {
            const badge = document.getElementById('syncStatusBadge');
            if (!badge) return;

            badge.className = 'sync-status-badge';

            if (partySyncMode === 'full') {
                badge.textContent = 'FULL SYNC';
                badge.classList.add('full');
            } else if (partySyncMode === 'coordinated') {
                badge.textContent = 'COORD SYNC';
                badge.classList.add('coordinated');
            } else {
                badge.style.display = 'none';
                return;
            }

            // Show sync button for all users in full sync mode
            const syncBtn = document.getElementById('syncBtn');
            if (syncBtn) {
                syncBtn.style.display = (partySyncMode === 'full') ? 'block' : 'none';
            }
        }

        function markReady() {
            if (!socket || userIsReady) return;
            userIsReady = true;
            socket.emit('user_ready');
            const readyBtn = document.getElementById('readyBtn');
            readyBtn.disabled = true;
            readyBtn.textContent = 'Waiting...';
        }

        function forceStartCountdown() {
            if (!socket || !isHost) return;
            socket.emit('start_countdown', { currentTime: vidkingHostTime });
        }

        function triggerSync() {
            if (!socket || !watchpartyActive) return;
            socket.emit('manual_sync', { currentTime: vidkingHostTime });
            showStatus('Syncing everyone to your position...');
        }

        function startCountdownSequence() {
            const overlay = document.getElementById('countdownOverlay');
            const numberEl = document.getElementById('countdownNumber');
            let count = 5;

            overlay.classList.add('active');
            numberEl.textContent = count;

            if (countdownTimer) clearInterval(countdownTimer);

            countdownTimer = setInterval(() => {
                count--;
                if (count > 0) {
                    numberEl.textContent = count;
                } else if (count === 0) {
                    numberEl.textContent = 'GO!';
                    reloadIframeForSync(vidkingHostTime);
                } else {
                    clearInterval(countdownTimer);
                    countdownTimer = null;
                    overlay.classList.remove('active');
                }
            }, 1000);
        }

        let iframeReloadTimer = null; // Debounce iframe reloads

        function reloadIframeForSync(startTime, autoPlay = true) {
            const playerIframe = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');

            if (playerVideo && playerVideo.style.display !== 'none') {
                // Direct stream: seek to startTime and play/pause
                if (startTime) playerVideo.currentTime = startTime;
                if (autoPlay) {
                    playerVideo.play().catch(e => console.log('[Sync] Autoplay prevented:', e));
                } else {
                    playerVideo.pause();
                }
                console.log('[Sync] Direct stream', autoPlay ? 'playing' : 'paused', 'at', startTime || 0);
            } else if (playerIframe && playerIframe.style.display !== 'none' && playerIframe.src) {
                // Debounce rapid reloads (e.g. play then immediate pause)
                if (iframeReloadTimer) clearTimeout(iframeReloadTimer);
                iframeReloadTimer = setTimeout(() => {
                    iframeReloadTimer = null;
                    try {
                        let url = new URL(playerIframe.src);
                        // Use VidKing's progress param for start time
                        if (startTime) url.searchParams.set('progress', Math.floor(startTime));
                        if (autoPlay) {
                            url.searchParams.set('autoPlay', 'true');
                        } else {
                            url.searchParams.delete('autoPlay');
                        }
                        console.log('[Sync] Reloading iframe at', startTime || 0, autoPlay ? '(autoplay)' : '(paused)');
                        playerIframe.src = 'about:blank';
                        setTimeout(() => { playerIframe.src = url.toString(); }, 200);
                    } catch (e) {
                        console.log('[Sync] Could not reload iframe:', e);
                    }
                }, 300);
            }
        }

        function resetWatchparty() {
            watchpartyActive = false;
            watchpartyRoomCode = null;
            isHost = false;
            watchpartyUsers = [];
            userColorMap = {}; // Reset user colors for new session
            videoSyncListenersAttached = false; // Allow re-attachment for next party
            document.getElementById('watchpartySidebar').classList.remove('active');
            document.getElementById('chatMessages').innerHTML = '';

            // Stop drift correction
            stopDriftCorrection();

            // Reset coordinated sync state
            partySyncMode = 'none';
            userIsReady = false;
            if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
            document.getElementById('readyCheckOverlay').classList.remove('active');
            document.getElementById('countdownOverlay').classList.remove('active');
            updateSyncStatusBadge();

            // Hide sync button
            const syncBtn = document.getElementById('syncBtn');
            if (syncBtn) syncBtn.style.display = 'none';

            // Unlock and restore previous video source
            unlockSourceAfterParty();

            showStatus('Left watchparty');
        }

        function showWatchpartySidebar() {
            document.getElementById('watchpartySidebar').classList.add('active');

            // Hide the watchparty panel when in a room (it will be shown in sidebar instead)
            // Only hide it if we're NOT in fullscreen (in fullscreen, sidebar is inside player)
            const isFullscreen = document.fullscreenElement ||
                                document.webkitFullscreenElement ||
                                document.mozFullScreenElement ||
                                document.msFullscreenElement;

            if (!isFullscreen) {
                const panel = document.getElementById('watchpartyPanel');
                if (panel) {
                    panel.classList.remove('active');
                }
            }
        }

        function updateWatchpartyUI(data) {
            document.getElementById('watchpartyRoomCode').textContent = data.room_code;
            updateUsersList(data.users);

            // Re-setup video sync listeners when host status changes
            const playerVideo = document.getElementById('playerVideo');
            if (playerVideo && playerVideo.style.display !== 'none') {
                videoSyncListenersAttached = false; // Reset flag
                setupVideoSyncListeners(playerVideo);
            }
        }

        function updateUsersList(users) {
            const userList = document.getElementById('watchpartyUserList');
            document.getElementById('userCount').textContent = users.length;

            userList.innerHTML = users.map((user, index) => {
                // Handle both old format (string) and new format (object with username/socket_id)
                const username = typeof user === 'string' ? user : user.username;
                const firstChar = username.charAt(0).toUpperCase();

                return `
                    <div class="user-item">
                        <div class="user-avatar">${firstChar}</div>
                        <div class="user-name">
                            ${username}
                            ${index === 0 ? ' <span style="color: #ffd700; font-size: 14px; margin-left: 4px;" title="Host controls playback"></span>' : ''}
                        </div>
                        ${index === 0 ? '<span class="host-badge" style="background: linear-gradient(135deg, #ffd700, #ff8c00); border: 1px solid #ffa500;">HOST</span>' : ''}
                    </div>
                `;
            }).join('');
        }

        function copyRoomCode() {
            const roomCode = document.getElementById('watchpartyRoomCode').textContent;
            const roomCodeElement = document.getElementById('watchpartyRoomCode');

            navigator.clipboard.writeText(roomCode);

            // Store original text
            const originalText = roomCodeElement.textContent;

            // Show "Copied!" message
            roomCodeElement.textContent = 'Copied!';
            roomCodeElement.style.color = '#ff00ff';

            // Revert back after 1.5 seconds
            setTimeout(() => {
                roomCodeElement.textContent = originalText;
                roomCodeElement.style.color = '#00ff9f';
            }, 1500);

            showStatus('Room code copied to clipboard!');
        }

        let replyingToMessage = null;

        function setReplyTo(username, messageText) {
            replyingToMessage = { username, messageText };
            const replyIndicator = document.getElementById('replyIndicator');
            const replyingToText = document.getElementById('replyingToText');

            replyingToText.textContent = `Replying to ${username}: ${messageText.substring(0, 50)}${messageText.length > 50 ? '...' : ''}`;
            replyIndicator.style.display = 'flex';

            // Focus the input
            document.getElementById('chatInput').focus();
        }

        function cancelReply() {
            replyingToMessage = null;
            document.getElementById('replyIndicator').style.display = 'none';
        }

        function sendChatMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (message && socket) {
                const data = { message };

                // Include reply info if replying
                if (replyingToMessage) {
                    data.replyTo = replyingToMessage;
                }

                socket.emit('chat_message', data);
                input.value = '';
                cancelReply();
            }
        }

        function handleChatKeypress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        // ============= WATCHPARTY CONTENT SYNC =============
        async function syncContentFromHost(content) {
            console.log('[Content Sync] Received content from host:', content);

            if (!content || !content.id) {
                console.log('[Content Sync] No valid content to sync');
                return;
            }

            const { id, title, type, season, episode, stream_url, stream_type, subtitles } = content;
            // Also check for 'url' field (used when party is created vs content synced)
            const actualStreamUrl = stream_url || content.url;
            const actualStreamType = stream_type || (actualStreamUrl && actualStreamUrl.includes('.m3u8') ? 'direct' : null);

            console.log(`[Content Sync] Syncing ${type}: ${title}`, { id, season, episode, stream_type: actualStreamType, url: actualStreamUrl });
            showStatus(`Syncing content: ${title}`);

            try {
                // If host provided stream data directly, use it (ensures same player type)
                if (actualStreamUrl && actualStreamType) {
                    console.log(`[Content Sync] Using host's stream directly: ${actualStreamType}`);

                    // Show player section
                    const playerSection = document.getElementById('playerSection');
                    if (playerSection) {
                        playerSection.style.display = 'block';
                    }

                    // Load content directly with host's stream URL
                    currentContentUrl = actualStreamUrl;
                    loadPlayerContent(actualStreamUrl, null, actualStreamType, subtitles || []);

                    // Update UI for TV shows
                    if (type === 'tv' && season && episode) {
                        currentSelectedSeason = season;
                        currentSelectedEpisode = episode;
                        const seasonBtn = document.getElementById('seasonButtonText');
                        const episodeBtn = document.getElementById('episodeButtonText');
                        if (seasonBtn) seasonBtn.textContent = `Season ${season}`;
                        if (episodeBtn) episodeBtn.textContent = `Episode ${episode}`;
                    }

                    console.log(`[Content Sync] Direct stream loaded successfully`);
                    return;
                }

                // Fallback: Load content normally (makes own API call)
                console.log('[Content Sync] No stream data from host, fetching from API...');

                if (type === 'tv') {
                    if (season && episode) {
                        console.log(`[Content Sync] Loading TV show: ${title} S${season}E${episode}`);

                        // First load the content to populate selectors
                        playContent(id, title, type);

                        // After content loads, play the specific episode
                        setTimeout(async () => {
                            console.log(`[Content Sync] Playing episode S${season}E${episode}`);
                            currentSelectedSeason = season;
                            currentSelectedEpisode = episode;

                            const seasonBtn = document.getElementById('seasonButtonText');
                            const episodeBtn = document.getElementById('episodeButtonText');

                            if (seasonBtn) seasonBtn.textContent = `Season ${season}`;

                            await updateEpisodeSelector(season);

                            if (episodeBtn) episodeBtn.textContent = `Episode ${episode}`;

                            playTVEpisode(id, season, episode);
                        }, 1500);
                    } else {
                        // Just load the TV show details page (no specific episode yet)
                        console.log(`[Content Sync] Loading TV show details: ${title}`);
                        playContent(id, title, type);
                    }
                } else if (type === 'movie') {
                    console.log(`[Content Sync] Loading movie: ${title} (ID: ${id})`);
                    console.log(`[Content Sync] Calling playMovie(${id})...`);
                    await playMovie(id);
                    console.log(`[Content Sync] playMovie() completed`);
                } else {
                    console.warn('[Content Sync] Unknown content type or missing data:', type);
                }
            } catch (error) {
                console.error('[Content Sync] Error syncing content:', error);
                showError('Failed to sync content from host');
            }
        }

        // ============= MOBILE KEYBOARD HANDLING =============
        let originalViewportHeight = window.innerHeight;
        let chatWasMinimized = false;

        // Detect keyboard opening/closing on mobile
        window.addEventListener('resize', () => {
            const currentHeight = window.innerHeight;
            const sidebar = document.getElementById('watchpartySidebar');

            // If viewport height decreased significantly (keyboard opened)
            if (originalViewportHeight - currentHeight > 150 && sidebar && sidebar.classList.contains('active')) {
                // Minimize chat when keyboard opens
                if (!sidebar.classList.contains('minimized')) {
                    chatWasMinimized = false;
                    sidebar.classList.add('minimized');
                }
            }
            // If viewport height increased (keyboard closed)
            else if (currentHeight > originalViewportHeight - 100 && sidebar && !chatWasMinimized) {
                // Restore chat when keyboard closes (only if we auto-minimized it)
                if (sidebar.classList.contains('minimized') && sidebar.classList.contains('active')) {
                    sidebar.classList.remove('minimized');
                }
            }

            // Update the baseline height
            if (Math.abs(currentHeight - originalViewportHeight) < 50) {
                originalViewportHeight = currentHeight;
            }
        });

        // Setup chat input keyboard handlers when DOM is ready
        function setupMobileChatHandlers() {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('focus', () => {
                    const sidebar = document.getElementById('watchpartySidebar');
                    if (sidebar && sidebar.classList.contains('active') && window.innerWidth <= 768) {
                        setTimeout(() => {
                            if (!sidebar.classList.contains('minimized')) {
                                chatWasMinimized = false;
                                sidebar.classList.add('minimized');
                            }
                        }, 300); // Small delay to let keyboard animation start
                    }
                });

                chatInput.addEventListener('blur', () => {
                    const sidebar = document.getElementById('watchpartySidebar');
                    setTimeout(() => {
                        if (sidebar && sidebar.classList.contains('minimized') && !chatWasMinimized && window.innerWidth <= 768) {
                            sidebar.classList.remove('minimized');
                        }
                    }, 300); // Delay to ensure keyboard is fully closed
                });
            }
        }

        function getUserColor(username) {
            // If user already has a color, return it
            if (userColorMap[username]) {
                return userColorMap[username];
            }

            // Assign a new color based on hash of username
            let hash = 0;
            for (let i = 0; i < username.length; i++) {
                hash = username.charCodeAt(i) + ((hash << 5) - hash);
                hash = hash & hash; // Convert to 32bit integer
            }
            const colorIndex = Math.abs(hash) % userColors.length;
            userColorMap[username] = userColors[colorIndex];

            console.log(`Assigned color ${userColors[colorIndex]} to user ${username} (index: ${colorIndex})`);
            return userColorMap[username];
        }

        function addChatMessage(data) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';

            const time = new Date(data.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            const userColor = getUserColor(data.username);

            // Build reply HTML if this is a reply
            let replyHTML = '';
            if (data.replyTo) {
                const replyUserColor = getUserColor(data.replyTo.username);
                replyHTML = `
                    <div class="replying-to">
                         <span style="color: ${replyUserColor};">${escapeHtml(data.replyTo.username)}</span>: ${escapeHtml(data.replyTo.messageText.substring(0, 30))}${data.replyTo.messageText.length > 30 ? '...' : ''}
                    </div>
                `;
            }

            messageDiv.innerHTML = `
                <div class="chat-message-header">
                    <span class="chat-username" style="color: ${userColor};">${escapeHtml(data.username)}</span>
                    <span class="chat-timestamp">${time}</span>
                </div>
                ${replyHTML}
                <div class="chat-text">${escapeHtml(data.message)}</div>
            `;

            // Add click handler to set reply
            messageDiv.addEventListener('click', () => {
                setReplyTo(data.username, data.message);
            });

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function addSystemMessage(text) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            messageDiv.innerHTML = `
                <div class="chat-text" style="background: rgba(0, 122, 255, 0.1); border-left: 3px solid #007AFF; font-style: italic; color: #007AFF;">
                    ${text}
                </div>
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showSyncIndicator(message) {
            const indicator = document.getElementById('syncIndicator');
            indicator.textContent = message;
            indicator.classList.add('show');

            setTimeout(() => {
                indicator.classList.remove('show');
            }, 2000);
        }

        function syncWithRoomState(state) {
            // This would sync the video player with the room state
            console.log('Syncing with room state:', state);
            // In a real implementation, you would control the iframe here
        }

        function formatTime(seconds) {
            if (!seconds || seconds < 0) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function reloadPlayerWithTimestamp(timestamp) {
            if (!currentContentUrl) return;

            // Parse the URL correctly
            let url;
            try {
                url = new URL(currentContentUrl);
            } catch (e) {
                // If it's a relative URL, use window.location.origin
                url = new URL(currentContentUrl, window.location.origin);
            }

            const timeInSeconds = Math.floor(timestamp);

            // Remove any existing time parameters
            url.searchParams.delete('t');
            url.searchParams.delete('time');
            url.searchParams.delete('start');
            url.searchParams.delete('timestamp');

            // VidKing uses 't' parameter for timestamp (like YouTube)
            // Add it in the format most embedded players support
            url.searchParams.set('t', timeInSeconds);

            // Add autoplay for watchparty sync
            if (watchpartyActive) {
                url.searchParams.set('autoplay', '1');
            }

            const player = document.getElementById('contentPlayer');
            const newUrl = url.toString();

            // Force reload by setting src to empty first, then to new URL
            player.src = 'about:blank';
            setTimeout(() => {
                player.src = newUrl;
            }, 100);

            console.log('Reloading player with timestamp:', timestamp, 'seconds');
            console.log('New URL:', newUrl);
            showStatus(`Syncing to ${formatTime(timestamp)}...`);
        }

        // Initialize socket on page load
        window.addEventListener('load', () => {
            initSocket();
        });


        // Global state for VidKing sync
        let vidkingHostTime = 0;
        let vidkingDuration = 0;

        window.addEventListener('message', function(event) {
            // Debug: log all postMessages from iframes
            if (event.data && typeof event.data === 'object') {
                console.log('[postMessage]', JSON.stringify(event.data).substring(0, 200));
            }
            if (!event.data || event.data.type !== 'PLAYER_EVENT') return;
            const { event: playerEvent, currentTime, duration } = event.data.data;

            // Always track time from timeupdate
            if (playerEvent === 'timeupdate') {
                vidkingHostTime = currentTime;
                vidkingDuration = duration || vidkingDuration;
            }

            // Only emit sync events if we're in a watchparty
            if (!watchpartyActive || !socket) return;
            if (isSyncing) return; // prevent loops

            switch (playerEvent) {
                case 'play':
                    socket.emit('playback_play', { currentTime });
                    break;
                case 'pause':
                    socket.emit('playback_pause', { currentTime });
                    break;
                case 'seeked':
                    socket.emit('playback_seek', { currentTime });
                    break;
            }
        });

        // Setup video sync listeners for watchparty
        let isSyncing = false; // Flag to prevent sync loops
        let videoSyncListenersAttached = false; // Track if listeners are already attached
        let driftCorrectionInterval = null; // Interval for drift correction

        function setupVideoSyncListeners(videoElement) {
            if (!videoElement) {
                console.log('[Sync] No video element provided, skipping sync listener setup');
                return;
            }

            // Prevent duplicate listeners
            if (videoSyncListenersAttached) {
                console.log('[Sync] Video sync listeners already attached, skipping');
                return;
            }

            // Anyone in watchparty can send sync events (Mode 2: Shared controls)
            if (watchpartyActive) {
                console.log('[Sync] Setting up automatic sync listeners for video playback');
                console.log('[Sync] Watchparty active:', watchpartyActive);

                // Play event
                videoElement.addEventListener('play', function() {
                    if (isSyncing) {
                        console.log('[Sync] Skipping play sync (isSyncing flag is true)');
                        return; // Prevent sync loops
                    }

                    const currentTime = Math.floor(videoElement.currentTime);
                    console.log('[Sync] Video played at', currentTime, '- emitting playback_play');

                    socket.emit('playback_play', {
                        currentTime: currentTime
                    });
                });

                // Pause event
                videoElement.addEventListener('pause', function() {
                    if (isSyncing) {
                        console.log('[Sync] Skipping pause sync (isSyncing flag is true)');
                        return; // Prevent sync loops
                    }

                    const currentTime = Math.floor(videoElement.currentTime);
                    console.log('[Sync] Video paused at', currentTime, '- emitting playback_pause');

                    socket.emit('playback_pause', {
                        currentTime: currentTime
                    });
                });

                // Seeked event (when user scrubs through video)
                videoElement.addEventListener('seeked', function() {
                    if (isSyncing) {
                        console.log('[Sync] Skipping seek sync (isSyncing flag is true)');
                        return; // Prevent sync loops
                    }

                    const currentTime = Math.floor(videoElement.currentTime);
                    console.log('[Sync] Video seeked to', currentTime, '- emitting playback_seek');

                    socket.emit('playback_seek', {
                        currentTime: currentTime
                    });
                });

                videoSyncListenersAttached = true;
                console.log('[Sync]  Video sync listeners attached successfully - automatic sync enabled');

                // Start drift correction
                startDriftCorrection(videoElement);
            } else {
                console.log('[Sync] Not in active watchparty - no sync listeners attached');
            }
        }

        function startDriftCorrection(videoElement) {
            // Clear any existing interval
            if (driftCorrectionInterval) {
                clearInterval(driftCorrectionInterval);
            }

            console.log('[Drift] Starting drift correction (checks every 5 seconds)');

            driftCorrectionInterval = setInterval(() => {
                if (!watchpartyActive || !videoElement) {
                    stopDriftCorrection();
                    return;
                }

                // Only check drift if video is playing
                if (videoElement.paused) {
                    return;
                }

                // Request current time from backend by emitting a drift check
                // Backend will respond with the authoritative time
                socket.emit('request_sync_status');
            }, 5000); // Check every 5 seconds
        }

        function stopDriftCorrection() {
            if (driftCorrectionInterval) {
                console.log('[Drift] Stopping drift correction');
                clearInterval(driftCorrectionInterval);
                driftCorrectionInterval = null;
            }
        }

        // ============= END WATCHPARTY FUNCTIONS =============

        // ============= KEYBOARD SHORTCUTS =============

        let playerContainerFocused = false;

        // Setup keyboard shortcuts when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Setup player container for keyboard shortcuts
            const playerContainer = document.querySelector('.player-container');
            if (playerContainer) {
                console.log('Player container found, setting up keyboard shortcuts');

                // Make player container focusable
                playerContainer.setAttribute('tabindex', '0');
                playerContainer.style.outline = 'none'; // Remove focus outline for aesthetics

                // Track focus state
                playerContainer.addEventListener('click', (e) => {
                    // Don't steal focus if clicking on watchparty elements
                    const watchpartySidebar = document.getElementById('watchpartySidebar');
                    if (watchpartySidebar && watchpartySidebar.contains(e.target)) {
                        console.log('Click on watchparty sidebar - not stealing focus');
                        return; // Let the watchparty elements handle their own focus
                    }

                    playerContainerFocused = true;
                    playerContainer.focus();
                    console.log('Player container clicked and focused');
                });

                playerContainer.addEventListener('focus', () => {
                    playerContainerFocused = true;
                    console.log('Player container focused');
                });

                playerContainer.addEventListener('blur', () => {
                    playerContainerFocused = false;
                    console.log('Player container blurred');
                });
            } else {
                console.error('Player container not found!');
            }
        });

        // ============= END KEYBOARD SHORTCUTS =============

        // ============= THEME SYSTEM =============
        const themes = {
            'matrix': { name: 'Matrix', color: '#00ff9f' },
            'hacker': { name: 'Hacker', color: '#00ff00' },
            'sunset': { name: 'Sunset', color: '#ff6b35' },
            'vaporwave': { name: 'Vaporwave', color: '#ff00ff' },
            'ocean': { name: 'Ocean', color: '#00d4ff' },
            'dracula': { name: 'Dracula', color: '#bd93f9' },
            'midnight': { name: 'Midnight Oil', color: '#ffd700' },
            'jspecial': { name: "J's Special", color: '#ff1493' },
            'phosphor': { name: 'Phosphor Burn', color: '#ffb000' }
        };

        let currentTheme = localStorage.getItem('selectedTheme') || 'jspecial';

        // Background effects state
        let activeEffects = JSON.parse(localStorage.getItem('bgEffects') || '{"matrix":false,"stars":true,"particles":true,"scanline":true}');

        // Clean up removed effects from old localStorage data
        if (activeEffects.vhs !== undefined || activeEffects.crt !== undefined || activeEffects.filmgrain !== undefined) {
            delete activeEffects.vhs;
            delete activeEffects.crt;
            delete activeEffects.filmgrain;
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));
        }

        function applyTheme(themeName) {
            document.documentElement.setAttribute('data-theme', themeName);
            currentTheme = themeName;
            localStorage.setItem('selectedTheme', themeName);

            // Update active state in theme selector
            document.querySelectorAll('.theme-option').forEach(opt => {
                opt.classList.remove('active');
                if (opt.dataset.theme === themeName) {
                    opt.classList.add('active');
                }
            });

            // Handle phosphor/jspecial theme specific elements
            updateModernThemeElements(themeName);
        }

        // Show/hide modern theme UI elements (phosphor and jspecial)
        function updateModernThemeElements(themeName) {
            const isModernTheme = themeName === 'phosphor' || themeName === 'jspecial';
            const scanlines = document.getElementById('crtScanlines');
            const curvature = document.getElementById('crtCurvature');
            const powerLed = document.getElementById('crtPowerLed');
            const floatingSearch = document.getElementById('floatingSearch');
            const watchlistContainer = document.getElementById('watchlistContainer');

            if (isModernTheme) {
                // Modern themes - hide all CRT effects
                if (scanlines) scanlines.style.display = 'none';
                if (curvature) curvature.style.display = 'none';
                if (powerLed) powerLed.style.display = 'none';
                // Show modern floating elements
                if (floatingSearch) floatingSearch.style.display = 'block';
                if (watchlistContainer) watchlistContainer.style.display = 'block';
                // Render the watchlist lists
                if (typeof renderWatchlistLists === 'function') {
                    renderWatchlistLists();
                }
                // Update auth UI to add menu items
                updateAuthUI();
            } else {
                if (scanlines) scanlines.style.display = 'none';
                if (curvature) curvature.style.display = 'none';
                if (powerLed) powerLed.style.display = 'none';
                if (floatingSearch) floatingSearch.style.display = 'none';
                if (watchlistContainer) watchlistContainer.style.display = 'none';
            }
        }

        // Helper function to close all popup panels
        function closeAllPopupPanels() {
            const themePanel = document.getElementById('themeSelectorPanel');
            const effectsPanel = document.getElementById('bgEffectsPanel');
            const watchpartyPanel = document.getElementById('watchpartyPanel');
            
            if (themePanel) themePanel.classList.remove('active');
            if (effectsPanel) effectsPanel.classList.remove('active');
            if (watchpartyPanel) watchpartyPanel.classList.remove('active');
        }

        window.toggleThemeSelector = function() {
            const panel = document.getElementById('themeSelectorPanel');
            const isActive = panel.classList.contains('active');
            
            // Close all panels first
            closeAllPopupPanels();
            
            // Toggle this panel if it wasn't active
            if (!isActive) {
                panel.classList.add('active');
            }
        }

        window.toggleEffectsPanel = function() {
            const panel = document.getElementById('bgEffectsPanel');
            const isActive = panel.classList.contains('active');
            
            // Close all panels first
            closeAllPopupPanels();
            
            // Toggle this panel if it wasn't active
            if (!isActive) {
                panel.classList.add('active');
            }
        }

        window.toggleWatchpartyPanel = function() {
            const panel = document.getElementById('watchpartyPanel');
            const isActive = panel.classList.contains('active');
            
            // Close all panels first
            closeAllPopupPanels();
            
            // Toggle this panel if it wasn't active
            if (!isActive) {
                panel.classList.add('active');
            }
        }

        window.toggleEffect = function(effectName) {
            activeEffects[effectName] = !activeEffects[effectName];
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));

            // Update UI
            const option = document.querySelector(`[data-effect="${effectName}"]`);
            if (activeEffects[effectName]) {
                option.classList.add('active');
            } else {
                option.classList.remove('active');
            }

            // Update background
            updateBackgroundEffects();
        }

        window.enableAllEffects = function() {
            activeEffects = {matrix: true, stars: true, particles: true, scanline: true};
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));
            updateEffectsUI();
            updateBackgroundEffects();
        }

        window.disableAllEffects = function() {
            activeEffects = {matrix: false, stars: false, particles: false, scanline: false};
            localStorage.setItem('bgEffects', JSON.stringify(activeEffects));
            updateEffectsUI();
            updateBackgroundEffects();
        }

        function updateEffectsUI() {
            Object.keys(activeEffects).forEach(effect => {
                const option = document.querySelector(`[data-effect="${effect}"]`);
                if (option) {
                    if (activeEffects[effect]) {
                        option.classList.add('active');
                    } else {
                        option.classList.remove('active');
                    }
                }
            });
        }

        function updateBackgroundEffects() {
            const container = document.getElementById('bgAnimation');
            container.innerHTML = '';

            if (activeEffects.matrix) createMatrixRain();
            if (activeEffects.stars) createPixelStars();
            if (activeEffects.particles) createParticles();
            if (activeEffects.scanline) createScanline();
        }

        // ============= AURORA SHADER BACKGROUND =============
        function initShaderBackground() {
            const container = document.getElementById('shaderBackground');
            if (!container || typeof THREE === 'undefined') return;

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });

            // Render at half resolution - CSS scales it up, barely noticeable for a background
            const scale = 0.5;
            renderer.setSize(window.innerWidth * scale, window.innerHeight * scale);
            renderer.setPixelRatio(1);
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            container.appendChild(renderer.domElement);

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2(window.innerWidth * scale, window.innerHeight * scale) }
                },
                vertexShader: `
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float iTime;
                    uniform vec2 iResolution;

                    float rand(vec2 n) {
                        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
                    }

                    float noise(vec2 p) {
                        vec2 ip = floor(p);
                        vec2 u = fract(p);
                        u = u*u*(3.0-2.0*u);
                        float res = mix(
                            mix(rand(ip), rand(ip + vec2(1.0, 0.0)), u.x),
                            mix(rand(ip + vec2(0.0, 1.0)), rand(ip + vec2(1.0, 1.0)), u.x), u.y);
                        return res * res;
                    }

                    float fbm(vec2 x) {
                        float v = 0.0;
                        float a = 0.3;
                        vec2 shift = vec2(100);
                        mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));
                        for (int i = 0; i < 2; ++i) {
                            v += a * noise(x);
                            x = rot * x * 2.0 + shift;
                            a *= 0.4;
                        }
                        return v;
                    }

                    void main() {
                        vec2 shake = vec2(sin(iTime * 1.2) * 0.005, cos(iTime * 2.1) * 0.005);
                        vec2 p = ((gl_FragCoord.xy + shake * iResolution.xy) - iResolution.xy * 0.5) / iResolution.y * mat2(6.0, -4.0, 4.0, 6.0);
                        vec2 v;
                        vec4 o = vec4(0.0);

                        float f = 2.0 + fbm(p + vec2(iTime * 5.0, 0.0)) * 0.5;

                        for (float i = 0.0; i < 18.0; i++) {
                            v = p + cos(i * i + (iTime + p.x * 0.08) * 0.025 + i * vec2(13.0, 11.0)) * 3.5 + vec2(sin(iTime * 3.0 + i) * 0.003, cos(iTime * 3.5 - i) * 0.003);
                            float tailNoise = rand(v + vec2(iTime * 0.3, i)) * 0.25 * (1.0 - (i / 18.0));
                            vec4 auroraColors = vec4(
                                0.1 + 0.3 * sin(i * 0.2 + iTime * 0.4),
                                0.3 + 0.5 * cos(i * 0.3 + iTime * 0.5),
                                0.7 + 0.3 * sin(i * 0.4 + iTime * 0.3),
                                1.0
                            );
                            vec4 currentContribution = auroraColors * exp(sin(i * i + iTime * 0.8)) / length(max(v, vec2(v.x * f * 0.015, v.y * 1.5)));
                            float thinnessFactor = smoothstep(0.0, 1.0, i / 18.0) * 0.6;
                            o += currentContribution * (1.0 + tailNoise * 0.8) * thinnessFactor;
                        }

                        o = tanh(pow(o / 55.0, vec4(1.6)));
                        gl_FragColor = o * 1.5;
                    }
                `
            });

            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Throttle to ~30fps instead of 60
            let frameId;
            let lastTime = 0;
            const interval = 1000 / 30;
            const animate = (now) => {
                frameId = requestAnimationFrame(animate);
                if (now - lastTime < interval) return;
                lastTime = now;
                material.uniforms.iTime.value += 0.033;
                renderer.render(scene, camera);
            };
            frameId = requestAnimationFrame(animate);

            const handleResize = () => {
                renderer.setSize(window.innerWidth * scale, window.innerHeight * scale);
                material.uniforms.iResolution.value.set(window.innerWidth * scale, window.innerHeight * scale);
            };
            window.addEventListener('resize', handleResize);

            // Store cleanup reference
            window._shaderCleanup = () => {
                cancelAnimationFrame(frameId);
                window.removeEventListener('resize', handleResize);
                if (container.contains(renderer.domElement)) {
                    container.removeChild(renderer.domElement);
                }
                geometry.dispose();
                material.dispose();
                renderer.dispose();
            };
        }

        function initThemeSelector() {
            const panel = document.getElementById('themeSelectorPanel');
            // Use the container if it exists, otherwise use the panel directly
            const container = panel.querySelector('.theme-options-container') || panel;
            
            Object.keys(themes).forEach(themeKey => {
                const theme = themes[themeKey];
                const option = document.createElement('div');
                option.className = 'theme-option';
                option.dataset.theme = themeKey;
                if (themeKey === currentTheme) option.classList.add('active');

                option.innerHTML = `
                    <div class="theme-color-preview" style="background: ${theme.color};"></div>
                    <div class="theme-name">${theme.name}</div>
                `;

                option.addEventListener('click', () => {
                    applyTheme(themeKey);
                    toggleThemeSelector();
                });

                container.appendChild(option);
            });
        }

        // ============= ANIMATED BACKGROUND =============
        function createMatrixRain() {
            const container = document.getElementById('bgAnimation');
            const chars = '01';

            for (let i = 0; i < 30; i++) {
                const drop = document.createElement('div');
                drop.className = 'matrix-rain';
                drop.textContent = chars[Math.floor(Math.random() * chars.length)].repeat(Math.floor(Math.random() * 15) + 5);
                drop.style.left = Math.random() * 100 + '%';
                drop.style.animationDuration = (Math.random() * 3 + 2) + 's';
                drop.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(drop);
            }
        }

        function createPixelStars() {
            const container = document.getElementById('bgAnimation');

            for (let i = 0; i < 50; i++) {
                const star = document.createElement('div');
                star.className = 'pixel-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(star);
            }
        }

        function createParticles() {
            const container = document.getElementById('bgAnimation');

            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                particle.style.animationDelay = Math.random() * 5 + 's';
                container.appendChild(particle);
            }
        }

        function createPlayerStars() {
            const container = document.getElementById('playerBgAnimation');
            if (!container) return;

            container.innerHTML = ''; // Clear existing

            for (let i = 0; i < 30; i++) {
                const star = document.createElement('div');
                star.className = 'pixel-star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                container.appendChild(star);
            }
        }

        function createPlayerParticles() {
            const container = document.getElementById('playerBgAnimation');
            if (!container) return;

            for (let i = 0; i < 15; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
                particle.style.animationDelay = Math.random() * 5 + 's';
                container.appendChild(particle);
            }
        }

        function initPlayerBackgroundEffects() {
            createPlayerStars();
            createPlayerParticles();
        }

        function clearPlayerBackgroundEffects() {
            const container = document.getElementById('playerBgAnimation');
            if (container) {
                container.innerHTML = '';
            }
        }

        function createScanline() {
            const container = document.getElementById('bgAnimation');
            const scanline = document.createElement('div');
            scanline.className = 'scanline';
            container.appendChild(scanline);
        }

        function createVHSEffect() {
            const container = document.getElementById('bgAnimation');
            const vhs = document.createElement('div');
            vhs.className = 'vhs-effect';
            container.appendChild(vhs);
        }

        function createCRTEffect() {
            const container = document.getElementById('bgAnimation');
            const crt = document.createElement('div');
            crt.className = 'crt-effect';
            container.appendChild(crt);
        }

        function createFilmGrain() {
            const container = document.getElementById('bgAnimation');
            const grain = document.createElement('div');
            grain.className = 'filmgrain-effect';
            container.appendChild(grain);
        }

        function initBgAnimation() {
            // Initialize effects UI
            updateEffectsUI();
            // Create enabled effects
            updateBackgroundEffects();
        }

        // ============= PHOSPHOR THEME CRT BOOT SEQUENCE =============
        let crtBootCompleted = sessionStorage.getItem('crtBootCompleted') === 'true';

        function runCrtBootSequence() {
            if (crtBootCompleted) {
                // Skip boot if already completed this session
                return Promise.resolve();
            }

            return new Promise((resolve) => {
                const overlay = document.getElementById('crtBootOverlay');

                if (!overlay) {
                    resolve();
                    return;
                }

                const bootLine = overlay.querySelector('.crt-boot-line');
                const bootText = overlay.querySelector('.crt-boot-text');

                // Failsafe: always hide overlay after 5 seconds max
                const failsafeTimeout = setTimeout(() => {
                    console.log('CRT boot failsafe triggered');
                    overlay.style.display = 'none';
                    overlay.classList.remove('active');
                    sessionStorage.setItem('crtBootCompleted', 'true');
                    crtBootCompleted = true;
                    resolve();
                }, 5000);

                // If GSAP not available, skip boot animation
                if (typeof gsap === 'undefined') {
                    clearTimeout(failsafeTimeout);
                    console.log('GSAP not available, skipping boot sequence');
                    resolve();
                    return;
                }

                overlay.style.display = 'block';
                overlay.classList.add('active');

                const bootMessages = [
                    'LOADING #1 STREAMING WEBSITE WORLDWIDE BY KOBYKODES...',
                    'INITIALIZING GLITCHBOX v2.0...',
                    'LOADING PHOSPHOR DISPLAY DRIVER...',
                    'CALIBRATING CRT BEAM...',
                    'SYSTEM READY'
                ];

                // Timeline for boot animation
                const tl = gsap.timeline({
                    onComplete: () => {
                        clearTimeout(failsafeTimeout);
                        gsap.to(overlay, {
                            opacity: 0,
                            duration: 0.5,
                            onComplete: () => {
                                overlay.style.display = 'none';
                                overlay.classList.remove('active');
                                overlay.style.opacity = 1;
                                if (bootText) bootText.textContent = '';
                                if (bootLine) bootLine.classList.remove('expanding');
                                sessionStorage.setItem('crtBootCompleted', 'true');
                                crtBootCompleted = true;
                                resolve();
                            }
                        });
                    }
                });

                // Phase 1: Amber glow warmup
                tl.to(overlay, {
                    backgroundColor: '#0a0800',
                    duration: 0.3
                });

                // Phase 2: Horizontal line expands
                tl.add(() => {
                    bootLine.classList.add('expanding');
                }, '+=0.2');

                tl.to({}, { duration: 0.6 });

                // Phase 3: Type out boot messages
                let messageIndex = 0;
                const typeMessage = () => {
                    if (messageIndex >= bootMessages.length) return;

                    const message = bootMessages[messageIndex];
                    let charIndex = 0;

                    const typeInterval = setInterval(() => {
                        if (charIndex < message.length) {
                            bootText.textContent += message[charIndex];
                            charIndex++;
                        } else {
                            clearInterval(typeInterval);
                            bootText.textContent += '\n';
                            messageIndex++;
                            if (messageIndex < bootMessages.length) {
                                setTimeout(typeMessage, 200);
                            }
                        }
                    }, 30);
                };

                tl.add(() => {
                    typeMessage();
                }, '+=0.3');

                // Wait for typing to complete
                tl.to({}, { duration: 2.5 });

                // Phase 4: Screen flicker before reveal
                tl.to(overlay, {
                    opacity: 0.8,
                    duration: 0.05,
                    repeat: 3,
                    yoyo: true
                });
            });
        }

        // ============= FLOATING SEARCH FUNCTIONALITY =============
        let floatingSearchOpen = false;
        let floatingSearchDebounceTimer = null;

        window.toggleFloatingSearch = function() {
            const panel = document.querySelector('.floating-search-panel');
            const input = document.getElementById('floatingSearchInput');

            if (!panel) return;

            floatingSearchOpen = !floatingSearchOpen;

            if (floatingSearchOpen) {
                // Close radial menus if open
                if (typeof closeAllRadialMenus === 'function') {
                    closeAllRadialMenus();
                }

                // Use GSAP for smooth animation if available
                if (typeof gsap !== 'undefined') {
                    gsap.to(panel, {
                        scaleY: 1,
                        opacity: 1,
                        duration: 0.4,
                        ease: 'back.out(1.7)',
                        onComplete: () => {
                            panel.classList.add('active');
                            if (input) input.focus();
                        }
                    });
                } else {
                    panel.classList.add('active');
                    if (input) input.focus();
                }
            } else {
                if (typeof gsap !== 'undefined') {
                    gsap.to(panel, {
                        scaleY: 0,
                        opacity: 0,
                        duration: 0.3,
                        ease: 'power2.in',
                        onComplete: () => {
                            panel.classList.remove('active');
                        }
                    });
                } else {
                    panel.classList.remove('active');
                }
            }
        };

        function initFloatingSearch() {
            const input = document.getElementById('floatingSearchInput');
            const resultsDiv = document.getElementById('floatingSearchResults');

            if (!input || !resultsDiv) return;

            input.addEventListener('input', function(e) {
                const query = e.target.value.trim();
                const clearBtn = document.getElementById('floatingSearchClear');
                if (clearBtn) {
                    clearBtn.classList.toggle('visible', e.target.value.length > 0);
                }

                if (floatingSearchDebounceTimer) {
                    clearTimeout(floatingSearchDebounceTimer);
                }

                if (query.length < 2) {
                    resultsDiv.innerHTML = '';
                    return;
                }

                floatingSearchDebounceTimer = setTimeout(async () => {
                    try {
                        resultsDiv.innerHTML = '<div style="padding: 16px; color: #ffb000;">Searching...</div>';

                        // Use the existing search function
                        const response = await fetch(`https://api.themoviedb.org/3/search/multi?api_key=e577f3394a629d69efa3a9414e172237&query=${encodeURIComponent(query)}`);
                        const data = await response.json();

                        if (data.results && data.results.length > 0) {
                            const filteredResults = data.results
                                .filter(item => item.media_type === 'movie' || item.media_type === 'tv')
                                .slice(0, 6);

                            resultsDiv.innerHTML = filteredResults.map(item => {
                                const title = item.title || item.name;
                                const year = item.release_date || item.first_air_date;
                                const yearStr = year ? year.substring(0, 4) : 'N/A';
                                const posterPath = item.poster_path
                                    ? `https://image.tmdb.org/t/p/w185${item.poster_path}`
                                    : 'https://via.placeholder.com/80x120/333/fff?text=N/A';
                                const type = item.media_type === 'tv' ? 'TV' : 'Movie';
                                const contentType = item.media_type === 'tv' ? 'tv' : 'movie';
                                const inWatchlist = typeof isItemInWatchlist === 'function' && isItemInWatchlist(item.id, contentType);
                                const heartIcon = inWatchlist ? 'Icons/heart-filled.png' : 'Icons/heart-nofill.png';

                                return `
                                    <div class="floating-search-result-item" onclick="floatingSearchSelect(${item.id}, '${title.replace(/'/g, "\\'")}', '${item.media_type}')">
                                        <img src="${posterPath}" alt="${title}" onerror="this.src='https://via.placeholder.com/80x120/333/fff?text=N/A'">
                                        <div class="floating-search-result-info">
                                            <div class="floating-search-result-title">${title}</div>
                                            <div class="floating-search-result-year">${yearStr}  ${type}</div>
                                        </div>
                                        <button class="floating-search-watchlist-btn" onclick="event.stopPropagation(); toggleSearchResultWatchlist(${item.id}, '${contentType}', '${title.replace(/'/g, "\\'")}', '${posterPath.replace(/'/g, "\\'")}', '${yearStr}', this)" title="${inWatchlist ? 'Remove from Watchlist' : 'Add to Watchlist'}">
                                            <img src="${heartIcon}" alt="Watchlist" onerror="this.parentElement.innerHTML='${inWatchlist ? '' : ''}'">
                                        </button>
                                    </div>
                                `;
                            }).join('');
                        } else {
                            resultsDiv.innerHTML = '<div style="padding: 16px; color: rgba(255, 176, 0, 0.6);">No results found</div>';
                        }
                    } catch (error) {
                        console.error('Floating search error:', error);
                        resultsDiv.innerHTML = '<div style="padding: 16px; color: #ff6666;">Search error</div>';
                    }
                }, 300);
            });

            // Handle Enter key
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    const firstResult = resultsDiv.querySelector('.floating-search-result-item');
                    if (firstResult) {
                        firstResult.click();
                    }
                } else if (e.key === 'Escape') {
                    toggleFloatingSearch();
                }
            });
        }

        window.floatingSearchSelect = function(id, title, type) {
            // Close the search panel
            toggleFloatingSearch();

            // Clear the input
            const input = document.getElementById('floatingSearchInput');
            if (input) input.value = '';

            // Clear results
            const resultsDiv = document.getElementById('floatingSearchResults');
            if (resultsDiv) resultsDiv.innerHTML = '';

            // Hide clear button
            const clearBtn = document.getElementById('floatingSearchClear');
            if (clearBtn) clearBtn.classList.remove('visible');

            // Play the selected content
            playContent(id, title, type);
        };

        window.clearFloatingSearch = function() {
            const input = document.getElementById('floatingSearchInput');
            const resultsDiv = document.getElementById('floatingSearchResults');
            const clearBtn = document.getElementById('floatingSearchClear');
            if (input) { input.value = ''; input.focus(); }
            if (resultsDiv) resultsDiv.innerHTML = '';
            if (clearBtn) clearBtn.classList.remove('visible');
        };

        window.toggleSearchResultWatchlist = function(id, type, title, posterUrl, year, btnElement) {
            const panel = document.getElementById('watchlistPanel');
            if (!panel) return;

            const isVisible = panel.classList.contains('active');

            // If panel is already open for the same item, close it
            if (isVisible && window.pendingWatchlistPanelItem && window.pendingWatchlistPanelItem.id === id) {
                panel.classList.remove('active');
                setTimeout(() => { panel.style.display = 'none'; }, 250);
                window.pendingWatchlistPanelItem = null;
                return;
            }

            // Store item data for the watchlist panel
            window.pendingWatchlistPanelItem = {
                id: id,
                title: title,
                type: type,
                posterUrl: posterUrl,
                year: year,
                rating: 0,
                addedAt: new Date().toISOString()
            };

            // Check if in any watchlist
            const inLists = Object.keys(watchlists).filter(listName =>
                watchlists[listName].some(item => item.id === id && item.type === type)
            );

            updateWatchlistPanel(inLists);

            // Use fixed positioning so the panel escapes the floating-search stacking context
            panel.style.position = 'fixed';

            // Position panel next to the heart button using viewport coordinates
            const rect = btnElement.getBoundingClientRect();
            const panelWidth = 360;
            let top = rect.top;
            let left = rect.left - panelWidth - 8;

            // If too close to left edge, position to the right instead
            if (left < 10) {
                left = rect.right + 8;
            }

            // Ensure it doesn't go off-screen bottom
            if (top + 300 > window.innerHeight) {
                top = window.innerHeight - 310;
            }

            panel.style.top = `${top}px`;
            panel.style.left = `${left}px`;
            panel.style.display = 'flex';
            requestAnimationFrame(() => {
                panel.classList.add('active');
            });

            // Store reference to update the heart icon after add/remove
            window._searchWatchlistBtnElement = btnElement;

            // Patch addToWatchlistPanel and removeFromWatchlistPanel callbacks to update heart
            const origClose = panel.querySelector('.player-watchlist-close');
            if (origClose) {
                origClose.onclick = function() {
                    panel.classList.remove('active');
                    setTimeout(() => { panel.style.display = 'none'; }, 250);
                    window.pendingWatchlistPanelItem = null;
                };
            }
        };

        // Close floating search when clicking outside
        function setupFloatingSearchClickOutside() {
            document.addEventListener('click', function(e) {
                const floatingSearch = document.getElementById('floatingSearch');
                if (floatingSearchOpen && floatingSearch && !floatingSearch.contains(e.target)) {
                    toggleFloatingSearch();
                }
            });
        }

        // Animate cards on reveal (phosphor theme)
        function animatePhosphorCards() {
            if (currentTheme !== 'phosphor' || typeof gsap === 'undefined') return;

            const cards = document.querySelectorAll('.content-card');
            gsap.fromTo(cards,
                {
                    opacity: 0,
                    y: 20,
                    scale: 0.95
                },
                {
                    opacity: 1,
                    y: 0,
                    scale: 1,
                    duration: 0.4,
                    stagger: 0.05,
                    ease: 'power2.out'
                }
            );
        }

        // ============= WATCHLIST PANEL FUNCTIONS =============
        let watchlistPanelOpen = false;
        let currentWatchlistView = 'lists'; // 'lists' or 'items'
        let selectedListName = '';

        window.toggleWatchlistPanel = function() {
            const panel = document.getElementById('watchlistSlidePanel');
            if (!panel) return;

            watchlistPanelOpen = !watchlistPanelOpen;

            if (watchlistPanelOpen) {
                panel.classList.add('active');
                renderWatchlistLists();
            } else {
                panel.classList.remove('active');
                // Reset to lists view when closing
                setTimeout(() => {
                    showWatchlistListsView();
                }, 300);
            }
        };

        window.showWatchlistListsView = function() {
            const listsContainer = document.getElementById('watchlistSlideLists');
            const itemsContainer = document.getElementById('watchlistSlideItems');
            const title = document.getElementById('watchlistSlideTitle');

            if (listsContainer) listsContainer.style.display = 'block';
            if (itemsContainer) itemsContainer.style.display = 'none';
            if (title) title.textContent = 'My Watchlists';
            currentWatchlistView = 'lists';
        };

        function renderWatchlistLists() {
            const container = document.getElementById('watchlistSlideLists');
            if (!container) return;

            const listNames = Object.keys(watchlists);

            // Create the "Create New List" button HTML
            const createBtnHTML = `
                <button class="watchlist-slide-create-btn" onclick="promptCreateNewList()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 5v14M5 12h14"/>
                    </svg>
                    Create New List
                </button>
            `;

            if (listNames.length === 0) {
                container.innerHTML = `
                    ${createBtnHTML}
                    <div class="watchlist-slide-empty">
                        <div class="watchlist-slide-empty-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                            </svg>
                        </div>
                        <p class="watchlist-slide-empty-text">No watchlists yet.<br>Start adding movies and shows!</p>
                    </div>
                `;
                return;
            }

            const listsHTML = listNames.map(listName => {
                const items = watchlists[listName] || [];
                const count = items.length;
                const escapedName = listName.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                return `
                    <div class="watchlist-slide-list-card" onclick="showWatchlistItems('${escapedName}')">
                        <div class="watchlist-slide-list-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                            </svg>
                        </div>
                        <div class="watchlist-slide-list-details">
                            <div class="watchlist-slide-list-name">${listName}</div>
                            <div class="watchlist-slide-list-count">${count} ${count === 1 ? 'item' : 'items'}</div>
                        </div>
                        <button class="watchlist-slide-list-rename" onclick="event.stopPropagation(); promptRenameList('${escapedName}')" title="Rename list">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                            </svg>
                        </button>
                        <button class="watchlist-slide-list-delete" onclick="event.stopPropagation(); promptDeleteList('${escapedName}')" title="Delete list">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14zM10 11v6M14 11v6"/>
                            </svg>
                        </button>
                        <div class="watchlist-slide-list-arrow">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = createBtnHTML + listsHTML;
        }

        // Open the Create New List modal
        window.promptCreateNewList = function() {
            const overlay = document.getElementById('createListModalOverlay');
            const input = document.getElementById('createListNameInput');
            const errorEl = document.getElementById('createListError');

            if (overlay) {
                overlay.classList.add('active');
                if (input) {
                    input.value = '';
                    input.classList.remove('error');
                    input.focus();
                }
                if (errorEl) {
                    errorEl.classList.remove('visible');
                }
            }
        }

        // Close the Create New List modal
        window.closeCreateListModal = function() {
            const overlay = document.getElementById('createListModalOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }

        // Confirm and create the new list
        window.confirmCreateList = function() {
            const input = document.getElementById('createListNameInput');
            const errorEl = document.getElementById('createListError');

            if (!input) return;

            const listName = input.value.trim();

            // Validate empty name
            if (!listName) {
                input.classList.add('error');
                errorEl.textContent = 'Please enter a name for your list';
                errorEl.classList.add('visible');
                input.focus();
                return;
            }

            // Check for duplicate names (case-insensitive)
            const existingNames = Object.keys(watchlists).map(name => name.toLowerCase());
            if (existingNames.includes(listName.toLowerCase())) {
                input.classList.add('error');
                errorEl.textContent = 'A list with this name already exists';
                errorEl.classList.add('visible');
                input.focus();
                return;
            }

            // Create the list
            watchlists[listName] = [];
            localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
            showStatus(`Created new list: ${listName}`);
            renderWatchlistLists();
            closeCreateListModal();
        }

        // Delete list functionality
        let pendingDeleteListName = null;

        window.promptDeleteList = function(listName) {
            pendingDeleteListName = listName;
            const overlay = document.getElementById('deleteListModalOverlay');
            const nameDisplay = document.getElementById('deleteListName');

            if (nameDisplay) {
                nameDisplay.textContent = listName;
            }

            if (overlay) {
                overlay.classList.add('active');
            }
        }

        window.closeDeleteListModal = function() {
            const overlay = document.getElementById('deleteListModalOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
            pendingDeleteListName = null;
        }

        window.confirmDeleteList = function() {
            if (!pendingDeleteListName) return;

            const listName = pendingDeleteListName;

            // Delete the list
            if (watchlists[listName] !== undefined) {
                delete watchlists[listName];
                localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));
                showStatus(`Deleted list: ${listName}`);
                renderWatchlistLists();
            }

            closeDeleteListModal();
        }

        // Rename list functionality
        let pendingRenameListName = null;

        window.promptRenameList = function(listName) {
            pendingRenameListName = listName;
            const overlay = document.getElementById('renameListModalOverlay');
            const input = document.getElementById('renameListInput');
            const errorEl = document.getElementById('renameListError');

            if (input) {
                input.value = listName;
                input.select();
            }
            if (errorEl) {
                errorEl.textContent = '';
                errorEl.classList.remove('visible');
            }
            if (overlay) {
                overlay.classList.add('active');
                setTimeout(() => { if (input) input.focus(); }, 200);
            }
        }

        window.closeRenameListModal = function() {
            const overlay = document.getElementById('renameListModalOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
            pendingRenameListName = null;
        }

        window.confirmRenameList = async function() {
            if (!pendingRenameListName) return;

            const oldName = pendingRenameListName;
            const input = document.getElementById('renameListInput');
            const errorEl = document.getElementById('renameListError');
            const newName = input ? input.value.trim() : '';

            if (!newName) {
                if (errorEl) {
                    errorEl.textContent = 'Please enter a list name';
                    errorEl.classList.add('visible');
                }
                return;
            }

            if (newName.length > 50) {
                if (errorEl) {
                    errorEl.textContent = 'Name must be 50 characters or less';
                    errorEl.classList.add('visible');
                }
                return;
            }

            if (newName === oldName) {
                closeRenameListModal();
                return;
            }

            // Check for duplicate (case-insensitive)
            const duplicate = Object.keys(watchlists).find(
                name => name.toLowerCase() === newName.toLowerCase() && name !== oldName
            );
            if (duplicate) {
                if (errorEl) {
                    errorEl.textContent = 'A list with this name already exists';
                    errorEl.classList.add('visible');
                }
                return;
            }

            // Rename in local watchlists object
            watchlists[newName] = watchlists[oldName];
            delete watchlists[oldName];
            localStorage.setItem('streamingSite_watchlists', JSON.stringify(watchlists));

            // Rename in database for authenticated users
            if (authToken) {
                try {
                    await apiRequest('/watchlist/rename', {
                        method: 'PUT',
                        body: JSON.stringify({
                            old_name: oldName,
                            new_name: newName
                        })
                    });
                } catch (error) {
                    console.error('Failed to rename list in database:', error);
                }
            }

            showStatus(`Renamed list to: ${newName}`);
            renderWatchlistLists();
            closeRenameListModal();
        }

        // Handle Enter key in create list and rename list inputs
        document.addEventListener('DOMContentLoaded', function() {
            const createListInput = document.getElementById('createListNameInput');
            if (createListInput) {
                createListInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmCreateList();
                    }
                });
                // Clear error state on input
                createListInput.addEventListener('input', function() {
                    this.classList.remove('error');
                    document.getElementById('createListError')?.classList.remove('visible');
                });
            }

            const renameListInput = document.getElementById('renameListInput');
            if (renameListInput) {
                renameListInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmRenameList();
                    }
                });
                renameListInput.addEventListener('input', function() {
                    document.getElementById('renameListError')?.classList.remove('visible');
                });
            }
        });

        window.showWatchlistItems = async function(listName) {
            const listsContainer = document.getElementById('watchlistSlideLists');
            const itemsContainer = document.getElementById('watchlistSlideItems');
            const itemsGrid = document.getElementById('watchlistSlideItemsGrid');
            const title = document.getElementById('watchlistSlideTitle');

            if (listsContainer) listsContainer.style.display = 'none';
            if (itemsContainer) itemsContainer.style.display = 'block';
            if (title) title.textContent = listName;

            selectedListName = listName;
            currentWatchlistView = 'items';

            const items = watchlists[listName] || [];

            if (items.length === 0) {
                itemsGrid.innerHTML = `
                    <div class="watchlist-slide-empty">
                        <div class="watchlist-slide-empty-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                <path d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                <path d="M9 10h.01M15 10h.01M8 14s1.5 2 4 2 4-2 4-2"/>
                            </svg>
                        </div>
                        <p class="watchlist-slide-empty-text">This list is empty.<br>Add some content to get started!</p>
                    </div>
                `;
                return;
            }

            // Show loading state first
            itemsGrid.innerHTML = items.map(() => `
                <div class="watchlist-item-card" style="opacity: 0.5;">
                    <div class="watchlist-item-poster" style="background: var(--bg-medium);"></div>
                    <div class="watchlist-item-info">
                        <div class="watchlist-item-title" style="background: var(--bg-medium); height: 18px; width: 80%; border-radius: 4px;"></div>
                        <div class="watchlist-item-meta" style="background: var(--bg-medium); height: 14px; width: 60%; border-radius: 4px; margin-top: 8px;"></div>
                    </div>
                </div>
            `).join('');

            // Fetch IMDB ratings for each item
            const itemsWithRatings = await Promise.all(items.map(async (item) => {
                let rating = null;
                try {
                    // Fetch details to get vote_average (TMDB rating) which we'll display
                    const endpoint = item.type === 'movie'
                        ? `https://api.themoviedb.org/3/movie/${item.id}`
                        : `https://api.themoviedb.org/3/tv/${item.id}`;

                    const response = await fetch(`${endpoint}?api_key=e577f3394a629d69efa3a9414e172237`);
                    if (response.ok) {
                        const data = await response.json();
                        rating = data.vote_average ? data.vote_average.toFixed(1) : null;
                    }
                } catch (e) {
                    console.log('Failed to fetch rating for', item.title);
                }
                return { ...item, rating };
            }));

            // Render items with ratings
            itemsGrid.innerHTML = itemsWithRatings.map(item => `
                <div class="watchlist-item-card" onclick="playWatchlistItem(${item.id}, '${item.type}')">
                    <img class="watchlist-item-poster"
                         src="${item.posterUrl || 'https://via.placeholder.com/64x96/242019/666?text=No+Image'}"
                         alt="${item.title}"
                         onerror="this.src='https://via.placeholder.com/64x96/242019/666?text=No+Image'">
                    <div class="watchlist-item-info">
                        <div class="watchlist-item-title">${item.title}</div>
                        <div class="watchlist-item-meta">
                            <span class="watchlist-item-type">${item.type === 'movie' ? 'Movie' : 'TV Show'}</span>
                            ${item.rating ? `
                                <span class="watchlist-item-rating">
                                    <svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
                                    <span class="watchlist-item-rating-value">${item.rating}</span>
                                </span>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        };

        window.playWatchlistItem = function(id, type) {
            // Close the panel
            toggleWatchlistPanel();

            // Play content in current page
            playContent(id, '', type);
        };

        // Click outside to close watchlist panel
        function setupWatchlistClickOutside() {
            document.addEventListener('click', function(event) {
                const container = document.getElementById('watchlistContainer');
                const panel = document.getElementById('watchlistSlidePanel');

                if (watchlistPanelOpen && container && !container.contains(event.target)) {
                    toggleWatchlistPanel();
                }
            });
        }

        // ============= LIVE PANEL FUNCTIONS =============
        let livePanelOpen = false;

        window.toggleLivePanel = function() {
            const panel = document.getElementById('liveSlidePanel');
            if (!panel) return;

            livePanelOpen = !livePanelOpen;

            if (livePanelOpen) {
                panel.classList.add('active');
                showLiveMainOptions(); // Reset to main view when opening
            } else {
                panel.classList.remove('active');
            }
        };

        window.showLiveMainOptions = function() {
            document.getElementById('liveMainOptions').style.display = 'block';
            document.getElementById('liveChannelsCategories').style.display = 'none';
            document.getElementById('liveSportsCategories').style.display = 'none';
        };

        window.showLiveCategories = function(section) {
            document.getElementById('liveMainOptions').style.display = 'none';
            if (section === 'channels') {
                document.getElementById('liveChannelsCategories').style.display = 'block';
                document.getElementById('liveSportsCategories').style.display = 'none';
            } else if (section === 'sports') {
                document.getElementById('liveChannelsCategories').style.display = 'none';
                document.getElementById('liveSportsCategories').style.display = 'block';
            }
        };

        window.loadChannelCategory = function(category) {
            // Close the live panel
            toggleLivePanel();

            // Hide all displays first
            const continueWatching = document.getElementById('continueWatchingDisplay');
            const statistics = document.getElementById('statisticsDisplay');
            const contentResults = document.getElementById('contentResults');
            const sportsDisplay = document.getElementById('sportsDisplay');
            const channelsDisplay = document.getElementById('channelsDisplay');

            if (continueWatching) continueWatching.style.display = 'none';
            if (statistics) statistics.style.display = 'none';
            if (contentResults) contentResults.style.display = 'none';
            if (sportsDisplay) sportsDisplay.style.display = 'none';
            if (channelsDisplay) channelsDisplay.style.display = 'block';

            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

            // Load channels with the selected category filter
            loadLiveChannels(category);
        };

        window.loadSportsCategory = function(category) {
            // Close the live panel
            toggleLivePanel();

            // Hide all displays first
            const continueWatching = document.getElementById('continueWatchingDisplay');
            const statistics = document.getElementById('statisticsDisplay');
            const contentResults = document.getElementById('contentResults');
            const sportsDisplay = document.getElementById('sportsDisplay');
            const channelsDisplay = document.getElementById('channelsDisplay');
            const watchlistDisplay = document.getElementById('watchlistDisplay');

            if (continueWatching) continueWatching.style.display = 'none';
            if (statistics) statistics.style.display = 'none';
            if (contentResults) contentResults.style.display = 'none';
            if (channelsDisplay) channelsDisplay.style.display = 'none';
            if (watchlistDisplay) watchlistDisplay.style.display = 'none';
            if (sportsDisplay) sportsDisplay.style.display = 'block';

            // Hide movie/show filter buttons
            const genreContainer = document.getElementById('genreFilterContainer');
            const genreDropdown = document.getElementById('genreDropdown');
            const contentTypeFilters = document.getElementById('contentTypeFilters');
            if (genreContainer) genreContainer.style.display = 'none';
            if (genreDropdown) genreDropdown.classList.remove('active');
            if (contentTypeFilters) contentTypeFilters.style.display = 'none';

            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));

            // Load sports with the selected category filter
            loadSportsData(category);
        };

        // Click outside to close live panel
        function setupLiveClickOutside() {
            document.addEventListener('click', function(event) {
                const container = document.getElementById('liveContainer');
                const panel = document.getElementById('liveSlidePanel');

                if (livePanelOpen && container && !container.contains(event.target)) {
                    toggleLivePanel();
                }
            });
        }

        // ============= END PHOSPHOR THEME FUNCTIONS =============

        // Initialize theme and animations
        document.addEventListener('DOMContentLoaded', async () => {
            // Check if phosphor theme should show boot sequence
            if (currentTheme === 'phosphor' && !crtBootCompleted) {
                await runCrtBootSequence();
            }

            applyTheme(currentTheme);
            initThemeSelector();
            initBgAnimation();
            setupClickOutsideListeners();
            initFloatingSearch();
            setupFloatingSearchClickOutside();
            setupWatchlistClickOutside();
            setupLiveClickOutside();
        });

        // ============= CLICK OUTSIDE TO CLOSE PANELS =============
        function setupClickOutsideListeners() {
            document.addEventListener('click', function(event) {
                // Season Panel
                const seasonPanel = document.getElementById('seasonPanel');
                const seasonButton = document.getElementById('seasonButton');
                if (seasonPanel && seasonPanel.style.display === 'flex') {
                    if (!seasonPanel.contains(event.target) && !seasonButton.contains(event.target)) {
                        closePanelAnimated(seasonPanel);
                    }
                }

                // Episode Panel
                const episodePanel = document.getElementById('episodePanel');
                const episodeButton = document.getElementById('episodeButton');
                if (episodePanel && episodePanel.style.display === 'flex') {
                    if (!episodePanel.contains(event.target) && !episodeButton.contains(event.target)) {
                        closePanelAnimated(episodePanel);
                    }
                }

                // Watchlist Panel
                const watchlistPanel = document.getElementById('watchlistPanel');
                const playerWatchlistBtn = document.getElementById('playerWatchlistBtn');
                if (watchlistPanel && (watchlistPanel.style.display === 'flex' || watchlistPanel.classList.contains('active'))) {
                    // Check if click is on any watchlist button or the panel itself
                    const isWatchlistButton = event.target.classList.contains('watchlist-btn') ||
                                             event.target.closest('.watchlist-btn') ||
                                             (playerWatchlistBtn && playerWatchlistBtn.contains(event.target));

                    if (!watchlistPanel.contains(event.target) && !isWatchlistButton) {
                        watchlistPanel.classList.remove('active');
                        setTimeout(() => { watchlistPanel.style.display = 'none'; }, 250);
                        window.pendingWatchlistPanelItem = null;
                    }
                }

                // Theme Selector Panel
                const themeSelectorPanel = document.getElementById('themeSelectorPanel');
                const themeSelectorBtn = document.querySelector('.theme-selector-btn');
                const userMenuDropdown = document.getElementById('userMenuDropdown');
                if (themeSelectorPanel && themeSelectorPanel.classList.contains('active')) {
                    const isUserMenuItem = userMenuDropdown && userMenuDropdown.contains(event.target);
                    if (!themeSelectorPanel.contains(event.target) &&
                        (!themeSelectorBtn || !themeSelectorBtn.contains(event.target)) &&
                        !isUserMenuItem) {
                        themeSelectorPanel.classList.remove('active');
                    }
                }

                // Effects Panel
                const bgEffectsPanel = document.getElementById('bgEffectsPanel');
                const effectsToggleBtn = document.querySelector('.bg-animation-toggle[onclick*="toggleEffectsPanel"]');
                if (bgEffectsPanel && bgEffectsPanel.classList.contains('active')) {
                    const isUserMenuItem = userMenuDropdown && userMenuDropdown.contains(event.target);
                    if (!bgEffectsPanel.contains(event.target) &&
                        (!effectsToggleBtn || !effectsToggleBtn.contains(event.target)) &&
                        !isUserMenuItem) {
                        bgEffectsPanel.classList.remove('active');
                    }
                }

                // Watchparty Panel
                const watchpartyPanel = document.getElementById('watchpartyPanel');
                const watchpartyToggleBtn = document.querySelector('.bg-animation-toggle[onclick*="toggleWatchpartyPanel"]');
                if (watchpartyPanel && watchpartyPanel.classList.contains('active')) {
                    const isUserMenuItem = userMenuDropdown && userMenuDropdown.contains(event.target);
                    if (!watchpartyPanel.contains(event.target) &&
                        (!watchpartyToggleBtn || !watchpartyToggleBtn.contains(event.target)) &&
                        !isUserMenuItem) {
                        watchpartyPanel.classList.remove('active');
                    }
                }
            });
        }
        // ============= END CLICK OUTSIDE TO CLOSE PANELS =============

        // ============= END THEME & ANIMATION SYSTEM =============

        // ============= SPORTS STREAMING SECTION =============

        const WESTREAM_BASE_URL = 'https://westream.su';  // Free sports streaming API with Arabic commentary
        let allSportsMatches = [];
        let availableSports = [];
        let isLiveFilterActive = false; // Toggle state for live filter
        let currentSportType = null; // null means all sports, or a specific sport id
        let currentDisplayedMatches = []; // Keep track of currently filtered matches
        let allMatchesForCurrentSport = []; // All matches for selected sport (before live filter)

        // Sports stream source management
        let currentSportsMatch = null; // Store the current match being played
        let currentSportsSourceIndex = 0; // Track which source is currently selected

        // SportSRC additional source
        const SPORTSRC_BASE_URL = 'https://api.sportsrc.org/';
        let sportsrcDetailCache = {};

        // Timeout wrapper for fetch  rejects if not done in time
        function fetchWithTimeout(url, ms = 5000) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), ms);
            return fetch(url, { signal: controller.signal }).finally(() => clearTimeout(timeout));
        }

        // Load sports data from both APIs
        async function loadSportsData(category) {
            try {
                showLoading();

                // Map category to sport type
                const categoryMap = {
                    'football': 'Football',
                    'basketball': 'Basketball',
                    'american-football': 'American Football',
                    'hockey': 'Ice Hockey',
                    'baseball': 'Baseball',
                    'motor-sports': 'Motorsport',
                    'fight': 'MMA',
                    'tennis': 'Tennis',
                    'rugby': 'Rugby',
                    'golf': 'Golf',
                    'cricket': 'Cricket',
                    'darts': 'Darts',
                    'other': null // Show all for "other"
                };

                // Reset filters to default
                isLiveFilterActive = false;
                currentSportType = category ? categoryMap[category] : null;

                // Clear search input
                const searchInput = document.getElementById('sportsSearchInput');
                const clearBtn = document.getElementById('clearSportsSearchBtn');
                if (searchInput) searchInput.value = '';
                if (clearBtn) clearBtn.style.display = 'none';

                // Reset button states
                const liveBtn = document.getElementById('liveSportsBtn');
                if (liveBtn) liveBtn.classList.remove('active');

                // Build parallel fetch promises
                const westreamPromise = (async () => {
                    const sportsResponse = await fetchWithTimeout(`${WESTREAM_BASE_URL}/sports`);
                    const sports = await sportsResponse.json();
                    const matchesResponse = await fetchWithTimeout(`${WESTREAM_BASE_URL}/matches`);
                    const matches = await matchesResponse.json();
                    return { sports, matches };
                })();

                const sportsrcPromise = (category && category !== 'other') ? (async () => {
                    const srcCategory = sportsrcCategoryFor(category);
                    const response = await fetch(`${SPORTSRC_BASE_URL}?data=matches&category=${encodeURIComponent(srcCategory)}`);
                    const matches = await response.json();
                    return (Array.isArray(matches) ? matches : []).map(m => normalizeSportSRCMatch(m, srcCategory));
                })() : Promise.resolve([]);

                const [westreamResult, sportsrcResult] = await Promise.allSettled([westreamPromise, sportsrcPromise]);

                // Process westream results
                let westreamMatches = [];
                if (westreamResult.status === 'fulfilled') {
                    availableSports = westreamResult.value.sports;
                    westreamMatches = westreamResult.value.matches;
                } else {
                    console.warn('Westream fetch failed:', westreamResult.reason);
                }

                // Process SportSRC results
                let sportsrcMatches = [];
                if (sportsrcResult.status === 'fulfilled') {
                    sportsrcMatches = sportsrcResult.value;
                } else {
                    console.warn('SportSRC fetch failed:', sportsrcResult.reason);
                }

                // Merge both sources
                allSportsMatches = mergeMatchLists(westreamMatches, sportsrcMatches);

                // If a category was selected, find the matching sport ID for API calls
                if (category && currentSportType) {
                    const matchingSport = availableSports.find(sport => {
                        const sportName = sport.name || sport;
                        const sportId = sport.id || sport;
                        return sportName === currentSportType ||
                               sportName.toLowerCase() === currentSportType.toLowerCase() ||
                               sportId === category;
                    });

                    if (matchingSport) {
                        currentSportType = matchingSport.id || matchingSport;
                    }
                }

                // Display matches based on current filter
                filterAndDisplayMatches();

                hideLoading();
            } catch (error) {
                console.error('Error loading sports data:', error);
                showError('Failed to load sports data');
                hideLoading();
            }
        }

        // Map UI category slugs to SportSRC category IDs
        function sportsrcCategoryFor(uiCategory) {
            const map = {
                'american-football': 'american-football',
                'motor-sports': 'motor-sports',
                'hockey': 'ice-hockey'
            };
            return map[uiCategory] || uiCategory;
        }

        // Normalize a SportSRC match to match westream's shape
        function normalizeSportSRCMatch(match, category) {
            return {
                id: match.id,
                title: match.title,
                category: match.category || category,
                date: match.date ? new Date(match.date).toISOString() : null,
                teams: match.teams || null,
                image: match.poster || null,
                thumbnail: match.poster || null,
                sources: null, // lazy-loaded via detail endpoint
                _provider: 'sportsrc',
                _sportsrcCategory: match.category || category
            };
        }

        // Lazy-load sources for a SportSRC match via the detail endpoint
        async function fetchSportSRCDetail(match) {
            const cacheKey = `${match._sportsrcCategory}:${match.id}`;
            if (sportsrcDetailCache[cacheKey]) return sportsrcDetailCache[cacheKey];

            const url = `${SPORTSRC_BASE_URL}?data=detail&category=${encodeURIComponent(match._sportsrcCategory)}&id=${encodeURIComponent(match.id)}`;
            const response = await fetch(url);
            const json = await response.json();

            const sources = (json.data?.sources || []).map(s => ({
                id: s.id,
                source: s.source,
                streamNo: s.streamNo,
                embedUrl: s.embedUrl,
                hd: s.hd,
                viewers: s.viewers,
                _provider: 'sportsrc'
            }));

            sportsrcDetailCache[cacheKey] = sources;
            return sources;
        }

        // Merge westream and SportSRC match lists, deduplicating by title
        function mergeMatchLists(westreamMatches, sportsrcMatches) {
            const merged = westreamMatches.map(m => ({ ...m, _provider: m._provider || 'westream' }));

            for (const srcMatch of sportsrcMatches) {
                const titleLower = (srcMatch.title || '').toLowerCase();
                const duplicate = merged.find(m => {
                    const mTitle = (m.title || '').toLowerCase();
                    return mTitle === titleLower && titleLower.length > 0;
                });

                if (duplicate) {
                    duplicate._sportsrcDuplicate = srcMatch;
                } else {
                    merged.push(srcMatch);
                }
            }

            return merged;
        }

        // Toggle live filter on/off
        function toggleLiveFilter() {
            // Toggle the live filter state
            isLiveFilterActive = !isLiveFilterActive;

            // Clear search input when toggling
            const searchInput = document.getElementById('sportsSearchInput');
            if (searchInput) searchInput.value = '';

            // Update button state with red glow when active
            const liveBtn = document.getElementById('liveSportsBtn');
            if (liveBtn) {
                if (isLiveFilterActive) {
                    liveBtn.style.boxShadow = '0 0 20px 5px rgba(255, 0, 0, 0.7)';
                    liveBtn.style.filter = 'drop-shadow(0 0 10px rgba(255, 0, 0, 0.5))';
                } else {
                    liveBtn.style.boxShadow = 'none';
                    liveBtn.style.filter = 'none';
                }
            }

            // Filter matches based on live status and selected sport
            filterAndDisplayMatches();
        }

        // Filter and display matches
        async function filterAndDisplayMatches() {
            let sportMatches = [];
            let filteredMatches = [];

            try {
                // Step 1: Filter by sport type  fetch from both APIs in parallel
                if (currentSportType) {
                    const westreamPromise = (async () => {
                        const response = await fetchWithTimeout(`${WESTREAM_BASE_URL}/matches/${currentSportType}`);
                        return await response.json();
                    })();

                    // Find the UI category slug for SportSRC
                    const uiCategory = Object.entries({
                        'football': 'Football', 'basketball': 'Basketball',
                        'american-football': 'American Football', 'hockey': 'Ice Hockey',
                        'baseball': 'Baseball', 'motor-sports': 'Motorsport',
                        'fight': 'MMA', 'tennis': 'Tennis', 'rugby': 'Rugby',
                        'golf': 'Golf', 'cricket': 'Cricket', 'darts': 'Darts'
                    }).find(([, v]) => v === currentSportType || v.toLowerCase() === String(currentSportType).toLowerCase())?.[0];

                    const sportsrcPromise = uiCategory ? (async () => {
                        const srcCat = sportsrcCategoryFor(uiCategory);
                        const response = await fetch(`${SPORTSRC_BASE_URL}?data=matches&category=${encodeURIComponent(srcCat)}`);
                        const matches = await response.json();
                        return (Array.isArray(matches) ? matches : []).map(m => normalizeSportSRCMatch(m, srcCat));
                    })() : Promise.resolve([]);

                    const [wsResult, srcResult] = await Promise.allSettled([westreamPromise, sportsrcPromise]);

                    const wsMatches = wsResult.status === 'fulfilled' ? wsResult.value : [];
                    const srcMatches = srcResult.status === 'fulfilled' ? srcResult.value : [];
                    if (wsResult.status === 'rejected') console.warn('Westream sport fetch failed:', wsResult.reason);
                    if (srcResult.status === 'rejected') console.warn('SportSRC sport fetch failed:', srcResult.reason);

                    sportMatches = mergeMatchLists(Array.isArray(wsMatches) ? wsMatches : [], srcMatches);
                } else {
                    sportMatches = allSportsMatches;
                }

                // Store all matches for current sport (before live filter)
                allMatchesForCurrentSport = sportMatches;

                // Step 2: Apply live filter if active
                if (isLiveFilterActive) {
                    const liveResponse = await fetchWithTimeout(`${WESTREAM_BASE_URL}/matches/live`);
                    const allLiveMatches = await liveResponse.json();

                    // Also include SportSRC matches that are within ~2 hours of now as "live"
                    const now = Date.now();
                    const twoHours = 2 * 60 * 60 * 1000;
                    const liveSportsrc = sportMatches.filter(m =>
                        m._provider === 'sportsrc' && m.date &&
                        Math.abs(new Date(m.date).getTime() - now) < twoHours
                    );

                    let combinedLive = mergeMatchLists(
                        Array.isArray(allLiveMatches) ? allLiveMatches : [],
                        liveSportsrc
                    );

                    if (currentSportType) {
                        filteredMatches = combinedLive.filter(match =>
                            match.category === currentSportType ||
                            match._provider === 'sportsrc'
                        );
                    } else {
                        filteredMatches = combinedLive;
                    }
                } else {
                    filteredMatches = sportMatches;
                }

                displaySportsMatches(filteredMatches);
            } catch (error) {
                console.error('Error filtering matches:', error);
                showError('Failed to load matches');
            }
        }

        // Display sports matches as a list
        function displaySportsMatches(matches) {
            const container = document.getElementById('sportsMatches');

            if (!matches || matches.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: #666;">
                        <h3 style="font-size: 24px; margin-bottom: 12px; color: #00d9ff;">No matches available</h3>
                        <p style="font-size: 18px;">Check back later for live sports events</p>
                    </div>
                `;
                return;
            }

            // Store matches globally for access by playSportsStream and search
            window.currentSportsMatches = matches;
            currentDisplayedMatches = matches;

            container.innerHTML = `
                <div class="sports-list" style="display: flex; flex-direction: column; gap: 8px;">
                    ${matches.map((match, index) => createSportsMatchRow(match, index)).join('')}
                </div>
            `;
        }

        // Search sports matches
        function searchSportsMatches() {
            const searchInput = document.getElementById('sportsSearchInput');
            const clearBtn = document.getElementById('clearSportsSearchBtn');
            const query = searchInput.value.toLowerCase().trim();

            // Show/hide clear button
            if (clearBtn) {
                clearBtn.style.display = query ? 'block' : 'none';
            }

            // If search is empty, show all currently filtered matches
            if (!query) {
                displaySportsMatches(currentDisplayedMatches);
                return;
            }

            // Filter matches based on search query
            const filteredMatches = currentDisplayedMatches.filter(match => {
                // Extract team names
                let homeTeam = '';
                let awayTeam = '';

                if (match.teams?.home?.name && match.teams?.away?.name) {
                    homeTeam = match.teams.home.name.toLowerCase();
                    awayTeam = match.teams.away.name.toLowerCase();
                } else if (match.title) {
                    const parts = match.title.split(/\s+(?:vs|VS|-)\s+/);
                    if (parts.length === 2) {
                        homeTeam = parts[0].trim().toLowerCase();
                        awayTeam = parts[1].trim().toLowerCase();
                    }
                }

                const title = (match.title || '').toLowerCase();
                const category = (match.category || '').toLowerCase();

                // Search in title, teams, and category
                return title.includes(query) ||
                       homeTeam.includes(query) ||
                       awayTeam.includes(query) ||
                       category.includes(query);
            });

            displaySportsMatches(filteredMatches);
        }

        // Clear sports search
        function clearSportsSearch() {
            const searchInput = document.getElementById('sportsSearchInput');
            const clearBtn = document.getElementById('clearSportsSearchBtn');

            if (searchInput) searchInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';

            displaySportsMatches(currentDisplayedMatches);
        }

        // Create a sports match row for list view
        function createSportsMatchRow(match, index) {
            // Check if live filter is active to determine if this is a live match
            const isLive = isLiveFilterActive;

            // Extract team names from teams object or parse from title
            let homeTeam = 'Home Team';
            let awayTeam = 'Away Team';

            if (match.teams?.home?.name && match.teams?.away?.name) {
                homeTeam = match.teams.home.name;
                awayTeam = match.teams.away.name;
            } else if (match.title) {
                // Parse title like "Team A vs Team B" or "Team A - Team B"
                const parts = match.title.split(/\s+(?:vs|VS|-)\s+/);
                if (parts.length === 2) {
                    homeTeam = parts[0].trim();
                    awayTeam = parts[1].trim();
                } else {
                    homeTeam = match.title;
                    awayTeam = '';
                }
            }

            // Format date and time
            const matchDate = match.date ? new Date(match.date) : null;
            const matchTime = matchDate ? matchDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'TBD';
            const matchDateStr = matchDate ? matchDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) : '';

            // Get sport category
            const sport = match.category || 'Sports';
            const sportDisplay = sport.charAt(0).toUpperCase() + sport.slice(1);

            // Sport icon images - include multiple variations of sport names
            const sportIconPaths = {
                // Capitalized
                'Football': 'Icons/LiveIcons/soccer.png',
                'Basketball': 'Icons/LiveIcons/basketball.png',
                'American Football': 'Icons/LiveIcons/american-football.png',
                'Ice Hockey': 'Icons/LiveIcons/ice-hockey.png',
                'Baseball': 'Icons/LiveIcons/baseball-player.png',
                'Tennis': 'Icons/LiveIcons/smash.png',
                'Golf': 'Icons/LiveIcons/golf-player.png',
                'Cricket': 'Icons/LiveIcons/cricket.png',
                'Rugby': 'Icons/LiveIcons/rugby.png',
                'MMA': 'Icons/LiveIcons/attack.png',
                'Motorsport': 'Icons/LiveIcons/f1.png',
                'Darts': 'Icons/LiveIcons/dart.png',
                // Lowercase
                'football': 'Icons/LiveIcons/soccer.png',
                'basketball': 'Icons/LiveIcons/basketball.png',
                'american football': 'Icons/LiveIcons/american-football.png',
                'american-football': 'Icons/LiveIcons/american-football.png',
                'ice hockey': 'Icons/LiveIcons/ice-hockey.png',
                'ice-hockey': 'Icons/LiveIcons/ice-hockey.png',
                'hockey': 'Icons/LiveIcons/ice-hockey.png',
                'baseball': 'Icons/LiveIcons/baseball-player.png',
                'tennis': 'Icons/LiveIcons/smash.png',
                'golf': 'Icons/LiveIcons/golf-player.png',
                'cricket': 'Icons/LiveIcons/cricket.png',
                'rugby': 'Icons/LiveIcons/rugby.png',
                'mma': 'Icons/LiveIcons/attack.png',
                'fight': 'Icons/LiveIcons/attack.png',
                'motorsport': 'Icons/LiveIcons/f1.png',
                'motor-sports': 'Icons/LiveIcons/f1.png',
                'darts': 'Icons/LiveIcons/dart.png',
                'soccer': 'Icons/LiveIcons/soccer.png'
            };
            const sportIconPath = sportIconPaths[sport] || sportIconPaths[sport?.toLowerCase()] || 'Icons/LiveIcons/sports.png';

            return `
                <div onclick='playSportsStream(${index})' style="
                    display: flex;
                    align-items: center;
                    padding: 16px 20px;
                    background: linear-gradient(135deg, rgba(15, 15, 30, 0.9) 0%, rgba(26, 26, 46, 0.9) 100%);
                    border: 1px solid ${isLive ? 'rgba(255, 0, 0, 0.4)' : 'rgba(0, 217, 255, 0.2)'};
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    gap: 16px;
                " onmouseover="this.style.background='linear-gradient(135deg, rgba(26, 26, 46, 1) 0%, rgba(30, 30, 60, 1) 100%)'; this.style.borderColor='${isLive ? '#ff0000' : '#00d9ff'}';" onmouseout="this.style.background='linear-gradient(135deg, rgba(15, 15, 30, 0.9) 0%, rgba(26, 26, 46, 0.9) 100%)'; this.style.borderColor='${isLive ? 'rgba(255, 0, 0, 0.4)' : 'rgba(0, 217, 255, 0.2)'}'; ">

                    <!-- Live Indicator -->
                    ${isLive ? `
                        <div style="
                            min-width: 70px;
                            padding: 6px 12px;
                            background: rgba(255, 0, 0, 0.2);
                            border: 1px solid #ff0000;
                            border-radius: 4px;
                            color: #ff0000;
                            font-size: 12px;
                            font-weight: bold;
                            text-align: center;
                            animation: pulse 2s infinite;
                        "> LIVE</div>
                    ` : `
                        <div style="
                            min-width: 70px;
                            padding: 6px 12px;
                            background: rgba(0, 217, 255, 0.1);
                            border: 1px solid rgba(0, 217, 255, 0.3);
                            border-radius: 4px;
                            color: #00d9ff;
                            font-size: 12px;
                            text-align: center;
                        ">${matchTime}</div>
                    `}

                    <!-- Sport Type -->
                    <div style="
                        min-width: 50px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    ">
                        <img src="${sportIconPath}" alt="${sportDisplay}" style="width: 48px; height: 48px; object-fit: contain;">
                    </div>

                    <!-- Teams/Match -->
                    <div style="flex: 1; display: flex; align-items: center; gap: 12px; min-width: 0;">
                        <span style="color: #00ff9f; font-weight: bold; font-size: 16px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${homeTeam}</span>
                        ${awayTeam ? `
                            <span style="color: #ff00ff; font-size: 14px; font-weight: bold;">VS</span>
                            <span style="color: #00ff9f; font-weight: bold; font-size: 16px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${awayTeam}</span>
                        ` : ''}
                    </div>

                    <!-- Date -->
                    ${matchDateStr && !isLive ? `
                        <div style="
                            min-width: 60px;
                            color: #666;
                            font-size: 12px;
                            text-align: right;
                        ">${matchDateStr}</div>
                    ` : ''}

                    <!-- Play Icon -->
                    <div style="
                        width: 36px;
                        height: 36px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: rgba(0, 255, 159, 0.1);
                        border: 1px solid rgba(0, 255, 159, 0.3);
                        border-radius: 50%;
                        color: #00ff9f;
                        font-size: 14px;
                    "></div>
                </div>
            `;
        }

        // Play sports stream in the content player
        async function playSportsStream(matchIndex, sourceIndex = 0) {
            // Get the match from the global array
            const match = window.currentSportsMatches[matchIndex];
            if (!match) {
                showError('Match not found');
                return;
            }

            // Lazy-load sources for SportSRC matches
            if (match.sources === null && match._provider === 'sportsrc') {
                showStatus('Loading stream sources...');
                try {
                    match.sources = await fetchSportSRCDetail(match);
                } catch (e) {
                    console.error('Failed to load SportSRC sources:', e);
                    showError('Failed to load stream sources');
                    return;
                }
            }

            // If match exists in both APIs, also fetch SportSRC sources and append
            if (match._sportsrcDuplicate && !match._sportsrcDuplicate._sourcesFetched) {
                try {
                    const extraSources = await fetchSportSRCDetail(match._sportsrcDuplicate);
                    if (extraSources.length > 0) {
                        match.sources = [...(match.sources || []), ...extraSources];
                    }
                    match._sportsrcDuplicate._sourcesFetched = true;
                } catch (e) {
                    console.warn('Failed to load extra SportSRC sources:', e);
                }
            }

            // Get streaming source
            if (!match.sources || match.sources.length === 0) {
                showError('No streaming source available for this match');
                return;
            }

            // Store current match and source index
            currentSportsMatch = match;
            currentSportsSourceIndex = sourceIndex;

            // Get the selected source
            const selectedSource = match.sources[sourceIndex];

            // Build the embed URL based on provider
            let embedUrl;
            if (selectedSource._provider === 'sportsrc') {
                embedUrl = selectedSource.embedUrl;
            } else {
                const source = selectedSource.source;
                const sourceId = selectedSource.id;
                const streamNo = selectedSource.streamNo || 1;
                embedUrl = `https://westream.su/embed/${source}/${sourceId}/${streamNo}`;
            }

            console.log('Playing sports stream:', embedUrl);
            console.log('Match data:', match);
            console.log('Using source:', selectedSource);

            // Extract team names
            let homeTeam = 'Team 1';
            let awayTeam = 'Team 2';

            if (match.teams?.home?.name && match.teams?.away?.name) {
                homeTeam = match.teams.home.name;
                awayTeam = match.teams.away.name;
            } else if (match.title) {
                const parts = match.title.split(/\s+(?:vs|VS|-)\s+/);
                if (parts.length === 2) {
                    homeTeam = parts[0].trim();
                    awayTeam = parts[1].trim();
                } else {
                    homeTeam = match.title;
                    awayTeam = '';
                }
            }

            // Update current content info
            currentContentId = match.id;
            currentContentType = 'sports';
            currentContentTitle = awayTeam ? `${homeTeam} vs ${awayTeam}` : homeTeam;

            // Show the player section
            const playerSection = document.getElementById('playerSection');
            const currentContent = document.getElementById('currentContent');
            if (playerSection) playerSection.style.display = 'block';
            if (currentContent) currentContent.style.display = 'block';

            // Hide TV controls for sports
            const tvControls = document.getElementById('tvControls');
            if (tvControls) tvControls.style.display = 'none';

            // Hide OMDB details for sports
            const omdbDetails = document.getElementById('omdbDetails');
            const omdbRatings = document.getElementById('omdbRatings');
            if (omdbDetails) omdbDetails.style.display = 'none';
            if (omdbRatings) omdbRatings.style.display = 'none';

            // Update content info display with correct element IDs
            const titleEl = document.getElementById('currentTitle');
            const yearEl = document.getElementById('currentYear');
            const overviewEl = document.getElementById('currentOverview');
            const posterEl = document.getElementById('currentPoster');

            const sport = match.category || 'Sports';
            const sportDisplay = sport.charAt(0).toUpperCase() + sport.slice(1);

            if (titleEl) titleEl.textContent = currentContentTitle;
            if (yearEl) yearEl.textContent = `${sportDisplay}${isLiveFilterActive ? ' - Live Now' : ''}`;
            if (overviewEl) overviewEl.textContent = match.description || `Watch ${currentContentTitle}${isLiveFilterActive ? ' live' : ''}`;

            // Set backdrop if available
            const backdropImage = document.getElementById('backdropImage');
            if (backdropImage) {
                if (match.image || match.thumbnail) {
                    backdropImage.style.backgroundImage = `url(${match.image || match.thumbnail})`;
                } else {
                    backdropImage.style.backgroundImage = 'linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%)';
                }
            }

            // Set poster to placeholder or match image
            if (posterEl) {
                if (match.image || match.thumbnail) {
                    posterEl.src = match.image || match.thumbnail;
                    posterEl.style.display = 'block';
                } else {
                    posterEl.style.display = 'none';
                }
            }

            // Update sports source button
            updateSportsSourceButton();

            // Hide video source button (for movies/TV)
            const sourceMenuContainer = document.getElementById('sourceMenuContainer');
            if (sourceMenuContainer) sourceMenuContainer.style.display = 'none';

            // Hide source hint
            dismissSourceHint();

            // Hide next episode button
            const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
            if (nextEpisodeBtn) nextEpisodeBtn.style.display = 'none';

            // Load the stream in the iframe
            loadPlayerContent(embedUrl);

            // Scroll to player
            if (currentContent) {
                currentContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            showStatus(`Loading ${match.sport || 'Sports'} stream...`);
        }

        // Update sports source button display
        function updateSportsSourceButton() {
            const btn = document.getElementById('sportsSourceBtn');
            const btnText = document.getElementById('sportsSourceBtnText');

            if (!btn || !btnText || !currentSportsMatch) return;

            const sources = currentSportsMatch.sources || [];

            // Only show button if there are multiple sources
            if (sources.length > 1) {
                btn.style.display = 'inline-block';

                // Get source name with provider tag (only show tag if mixed providers)
                const currentSource = sources[currentSportsSourceIndex];
                const sourceName = currentSource?.source?.toUpperCase() || `Source ${currentSportsSourceIndex + 1}`;
                const hasMultipleProviders = sources.some(s => s._provider === 'sportsrc') && sources.some(s => !s._provider || s._provider === 'westream');
                const providerTag = hasMultipleProviders ? (currentSource?._provider === 'sportsrc' ? '[SRC] ' : '[WS] ') : '';

                btnText.textContent = `${providerTag}${sourceName} (${currentSportsSourceIndex + 1}/${sources.length})`;
            } else {
                btn.style.display = 'none';
            }
        }

        // Switch to the next available sports source
        window.switchSportsSource = async function() {
            if (!currentSportsMatch || !currentSportsMatch.sources) {
                showError('No match is currently playing');
                return;
            }

            const sources = currentSportsMatch.sources;
            if (sources.length <= 1) {
                showStatus('Only one source available for this match');
                return;
            }

            // Move to next source (cycle back to 0 after last one)
            currentSportsSourceIndex = (currentSportsSourceIndex + 1) % sources.length;

            // Get the match index in the current displayed matches
            const matchIndex = window.currentSportsMatches.findIndex(m => m.id === currentSportsMatch.id);

            if (matchIndex !== -1) {
                // Replay the match with the new source
                await playSportsStream(matchIndex, currentSportsSourceIndex);

                const currentSource = sources[currentSportsSourceIndex];
                const sourceName = currentSource.source.toUpperCase();
                const hasMultipleProviders = sources.some(s => s._provider === 'sportsrc') && sources.some(s => !s._provider || s._provider === 'westream');
                const providerTag = hasMultipleProviders ? (currentSource._provider === 'sportsrc' ? '[SRC] ' : '[WS] ') : '';
                showStatus(`Switched to ${providerTag}${sourceName} (${currentSportsSourceIndex + 1}/${sources.length})`);
            } else {
                showError('Unable to switch source');
            }
        }

        // Add pulse animation for live badge
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0%, 100% {
                    opacity: 1;
                    box-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
                }
                50% {
                    opacity: 0.8;
                    box-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
                }
            }
        `;
        document.head.appendChild(style);

        // ============= END SPORTS STREAMING SECTION =============

        // ============= LIVE CHANNELS SECTION =============

        // All TV Channels data organized by country
        // Verified working channels only (tested on 2025-11-01)
        // Total: 68 channels across 9 countries
        const allWorldChannels = [
            // Lebanon
            { name: 'Aghani Aghani TV', url: 'https://streaming-a-1035.cdn.nextologies.com/6zj8y5nemi8a32vyjjbkv0oqx/77pcakd8reik3g8qdqnexlkmq/playlist.m3u8', category: 'Music', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/o6HSfNg.png' },            { name: 'Al Mayadeen', url: 'https://mdnlv.cdn.octivid.com/almdn/smil:mpegts.stream.smil/playlist.m3u8', category: 'News', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/GtQOKeW.png' },            { name: 'Future TV', url: 'https://live.kwikmotion.com/futurelive/ftv.smil/playlist.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.postimg.cc/43Ww9bQV/futuretv.png' },
            { name: 'LBC International', url: 'https://pwultrp.alwaysdata.net/rotana.php?channel=rlbc&.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/V6CqaVq.png' },
            { name: 'LTV', url: 'https://p-ltv.akamaized.net/ltv/ltv.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB' },            { name: 'MTV Lebanon', url: 'https://hms.pfs.gdn/v1/broadcast/mtv/playlist.m3u8', category: 'Entertainment', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/hHRkvr3.png' },            { name: 'Red TV Lebanon', url: 'https://live.kwikmotion.com/redtvlive/redtv.smil/playlist.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB' },            { name: 'Tele Liban', url: 'https://cdn.catiacast.video/abr/ed8f807e2548db4507d2a6f4ba0c4a06/playlist.m3u8', category: 'General', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.postimg.cc/d3RWtcXq/teleliban.png' },            { name: 'Voice of Lebanon', url: 'https://svs.itworkscdn.net/vdltvlive/vdltv.smil/playlist.m3u8', category: 'News', country: 'Lebanon', countryCode: 'LB', logo: 'https://i.imgur.com/f8WcqRY.png' },

            // Saudi Arabia
            { name: 'Al Arabiya Al Hadath', url: 'https://av.alarabiya.net/alarabiapublish/alhadath.smil/playlist.m3u8', category: 'News', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'Al Ekhbariya', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-al-ekhbaria/297b3ef1cd0633ad9cfba7473a686a06/index.m3u8', category: 'News', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'Al Quran Al Kareem TV', url: 'https://cdn-globecast.akamaized.net/live/eds/saudi_quran/hls_roku/index.m3u8', category: 'Religious', country: 'Saudi Arabia', countryCode: 'SA' },            { name: 'Al Saudiya', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-saudi-tv/2ad66056b51fd8c1b624854623112e43/index.m3u8', category: 'General', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'Al Sunnah Al Nabawiyah TV', url: 'https://cdn-globecast.akamaized.net/live/eds/saudi_sunnah/hls_roku/index.m3u8', category: 'Religious', country: 'Saudi Arabia', countryCode: 'SA' },
            { name: 'SBC', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-sbc/90e09c0c28db26435799b4a14892a167/index.m3u8', category: 'General', country: 'Saudi Arabia', countryCode: 'SA' },

            // UAE
            { name: 'Abu Dhabi Emirates', url: 'https://vo-live-media.cdb.cdn.orange.com/Content/Channel/EmiratesChannel/HLS/index.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Abu Dhabi TV', url: 'https://vo-live-media.cdb.cdn.orange.com/Content/Channel/AbuDhabiChannel/HLS/index.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Dubai TV', url: 'https://dmieigthvllta.cdn.mgmlcdn.com/dubaitvht/smil:dubaitv.stream.smil/chunklist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Dubai Sports 1', url: 'https://dmidspta.cdn.mgmlcdn.com/dubaisports/smil:dubaisports.stream.smil/chunklist.m3u8', category: 'Sports', country: 'UAE', countryCode: 'AE' },
            { name: 'Sama Dubai', url: 'https://dmieigthvllta.cdn.mgmlcdn.com/samadubaiht/smil:samadubai.stream.smil/chunklist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Sharjah TV', url: 'https://svs.itworkscdn.net/smc1live/smc1.smil/playlist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Ajman TV', url: 'https://cdn1.logichost.in/ajmantv/live/playlist.m3u8', category: 'General', country: 'UAE', countryCode: 'AE' },
            { name: 'Noor Dubai', url: 'https://dmiffthftl.cdn.mangomolo.com/noordubaitv/smil:noordubaitv.smil/chunklist.m3u8', category: 'Religious', country: 'UAE', countryCode: 'AE' },
            { name: 'CNBC Arabiya', url: 'https://cnbc-live.akamaized.net/cnbc/master.m3u8', category: 'News', country: 'UAE', countryCode: 'AE' },
            { name: 'Al Arabiya', url: 'https://live.alarabiya.net/alarabiapublish/alarabiya.smil/playlist.m3u8', category: 'News', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/NXFkYFj.png' },
            { name: 'MBC 1', url: 'https://shls-live-enc.edgenextcdn.net/out/v1/0965e4d7deae49179172426cbfb3bc5e/index.m3u8', category: 'General', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/eKLtN03.png' },
            { name: 'MBC 4', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-mbc-4/24f134f1cd63db9346439e96b86ca6ed/index.m3u8', category: 'Entertainment', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/BcXASR9.png' },
            { name: 'MBC 5', url: 'https://shd-gcp-live.edgenextcdn.net/live/bitmovin-mbc-5/ee6b000cee0629411b666ab26cb13e9b/index.m3u8', category: 'Entertainment', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/fRWTV9F.png' },
            { name: 'MBC Drama', url: 'https://mbc1-enc.edgenextcdn.net/out/v1/b0b3a0e6750d4408bb86d703d5feffd1/index.m3u8', category: 'Entertainment', country: 'UAE', countryCode: 'AE', logo: 'https://i.imgur.com/g5PWnqp.png' },

            // Egypt            { name: 'MBC Masr', url: 'https://mbc1-enc.edgenextcdn.net/out/v1/d5036cabf11e45bf9d0db410ca135c18/index.m3u8', category: 'General', country: 'Egypt', countryCode: 'EG' },            // Canada            { name: 'CityNews Toronto', url: 'https://citynewsregional.akamaized.net/hls/live/1024052/Regional_Live_7/master.m3u8', category: 'News', country: 'Canada', countryCode: 'CA' },
            { name: 'TSN1', url: 'https://fl1.moveonjoy.com/TSN_1/index.m3u8', category: 'Sports', country: 'Canada', countryCode: 'CA' },            { name: 'Much', url: 'https://fl1.moveonjoy.com/MUCH/index.m3u8', category: 'Music', country: 'Canada', countryCode: 'CA' },
            { name: 'CPAC', url: 'https://d7z3qjdsxbwoq.cloudfront.net/groupa/live/f9809cea-1e07-47cd-a94d-2ddd3e1351db/live.isml/.m3u8', category: 'News', country: 'Canada', countryCode: 'CA' },
            { name: 'ICI Montreal', url: 'https://amdici.akamaized.net/hls/live/873426/ICI-Live-Stream/master.m3u8', category: 'General', country: 'Canada', countryCode: 'CA' },            { name: 'Golf Channel', url: 'https://fl1.moveonjoy.com/GOLF/index.m3u8', category: 'Sports', country: 'Canada', countryCode: 'CA' },
            // UK            { name: 'BBC Two HD', url: 'https://viamotionhsi.netplus.ch/live/eds/bbc2/browser-HLS8/bbc2.m3u8', category: 'General', country: 'UK', countryCode: 'GB' },            { name: 'ITV3', url: 'https://viamotionhsi.netplus.ch/live/eds/itv3/browser-HLS8/itv3.m3u8', category: 'Entertainment', country: 'UK', countryCode: 'GB' },            { name: 'Film4 HD', url: 'https://viamotionhsi.netplus.ch/live/eds/film4/browser-HLS8/film4.m3u8', category: 'Movies', country: 'UK', countryCode: 'GB' },            { name: 'QVC UK', url: 'https://qvcuk-live.akamaized.net/hls/live/2097112/qvc/master.m3u8', category: 'Shopping', country: 'UK', countryCode: 'GB' },
            // Germany
            { name: 'Das Erste', url: 'https://derste247liveint.akamaized.net/hls/live/662735/daserste_int/master.m3u8', category: 'General', country: 'Germany', countryCode: 'DE' },            { name: 'ARD-alpha', url: 'https://brlive-lh.akamaihd.net/i/bralpha_germany@119899/master.m3u8', category: 'Education', country: 'Germany', countryCode: 'DE' },            { name: 'tagesschau 24', url: 'https://tagesschau.akamaized.net/hls/live/2020115/tagesschau/tagesschau_1/master.m3u8', category: 'News', country: 'Germany', countryCode: 'DE' },
            { name: 'WELT', url: 'https://viamotionhsi.netplus.ch/live/eds/n24/browser-HLS8/n24.m3u8', category: 'News', country: 'Germany', countryCode: 'DE' },
            { name: 'Dokusat', url: 'https://muc3.iptv-playoutcenter.de/dokusat/dokusat1/playlist.m3u8', category: 'Documentary', country: 'Germany', countryCode: 'DE' },
            { name: 'KiKA', url: 'https://kikageohls.akamaized.net/hls/live/2022693/livetvkika_de/master.m3u8', category: 'Kids', country: 'Germany', countryCode: 'DE' },            { name: 'More Than Sports TV', url: 'https://mts1.iptv-playoutcenter.de/mts/mts-web/playlist.m3u8', category: 'Sports', country: 'Germany', countryCode: 'DE' },            { name: 'WDR Fernsehen', url: 'https://wdr-live.ard-mcdn.de/wdr/live/hls/de/master.m3u8', category: 'General', country: 'Germany', countryCode: 'DE' },

            // USA
            { name: 'ABC News New York', url: 'https://content.uplynk.com/channel/ext/72750b711f704e4a94b5cfe6dc99f5e1/wabc_24x7_news.m3u8', category: 'News', country: 'USA', countryCode: 'US', logo: 'https://upload.wikimedia.org/wikipedia/commons/thumb/a/a3/WABC_TV_New_2021.svg/512px-WABC_TV_New_2021.svg.png' },
            { name: 'CBS News New York', url: 'https://cbsn-ny.cbsnstream.cbsnews.com/out/v1/ec3897d58a9b45129a77d67aa247d136/master.m3u8', category: 'News', country: 'USA', countryCode: 'US' },
            { name: 'CBS News Chicago', url: 'https://cbsn-chi.cbsnstream.cbsnews.com/out/v1/b2fc0d5715d54908adf07f97d2616646/master.m3u8', category: 'News', country: 'USA', countryCode: 'US' },
            { name: 'CBS News Los Angeles', url: 'https://cbsn-la.cbsnstream.cbsnews.com/out/v1/57b6c4534a164accb6b1872b501e0028/master.m3u8', category: 'News', country: 'USA', countryCode: 'US' },
            { name: 'Cheddar News', url: 'https://cheddar-us.samsung.wurl.tv/playlist.m3u8', category: 'News', country: 'USA', countryCode: 'US' },            { name: 'CNBC', url: 'https://fl1.moveonjoy.com/CNBC/index.m3u8', category: 'News', country: 'USA', countryCode: 'US', logo: 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/e3/CNBC_logo.svg/512px-CNBC_logo.svg.png' },            { name: 'BBC America', url: 'https://bcovlive-a.akamaihd.net/7f5ec16d102f4b5d92e8e27bc95ff424/us-east-1/6240731308001/playlist.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },
            { name: 'Bravo', url: 'https://fl1.moveonjoy.com/BRAVO/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US', logo: 'https://i.imgur.com/JmTIRLF.png' },            { name: 'Comet', url: 'https://fast-channels.sinclairstoryline.com/COMET/index.m3u8', category: 'Movies', country: 'USA', countryCode: 'US' },            { name: 'CMT', url: 'https://fl1.moveonjoy.com/CMT/index.m3u8', category: 'Music', country: 'USA', countryCode: 'US' },
            { name: 'Antenna TV', url: 'https://fl1.moveonjoy.com/Antenna_TV/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },            { name: 'Buzzr', url: 'https://fl1.moveonjoy.com/Buzzr/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },
            { name: 'Aspire', url: 'https://fl1.moveonjoy.com/Aspire/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },            { name: 'CBS Sports Network', url: 'https://fl1.moveonjoy.com/CBS_SPORTS_NETWORK/index.m3u8', category: 'Sports', country: 'USA', countryCode: 'US', logo: 'https://i.imgur.com/A8CnA8g.png' },
            { name: 'ACC Network', url: 'https://fl1.moveonjoy.com/ACC_NETWORK/index.m3u8', category: 'Sports', country: 'USA', countryCode: 'US' },
            { name: 'AXS TV', url: 'https://fl1.moveonjoy.com/Axs_TV/index.m3u8', category: 'Entertainment', country: 'USA', countryCode: 'US' },
            { name: '3ABN Kids', url: 'https://3abn.bozztv.com/3abn2/Kids_live/smil:Kids_live.smil/playlist.m3u8', category: 'Kids', country: 'USA', countryCode: 'US' },
            { name: 'Baby Shark TV', url: 'https://newidco-babysharktv-1-eu.rakuten.wurl.tv/playlist.m3u8', category: 'Kids', country: 'USA', countryCode: 'US' },
            { name: 'BabyFirst', url: 'https://streams2.sofast.tv/v1/master/611d79b11b77e2f571934fd80ca1413453772ac7/c8d16110-566c-4e95-a1df-55d175e9e201/manifest.m3u8', category: 'Kids', country: 'USA', countryCode: 'US' },            { name: 'Catholic TV', url: 'https://catholictvhd-lh.akamaized.net/hls/live/2043390/CTVLiveHD/master.m3u8', category: 'Religious', country: 'USA', countryCode: 'US' }
        ];

        let allChannels = [];
        let currentDisplayedChannels = [];
        let selectedCountry = 'All';

        // Load live channels
        function loadLiveChannels(category) {
            allChannels = [...allWorldChannels];

            // Map category to country name
            const categoryMap = {
                'favourites': 'Favourites',
                'all': 'All',
                'canada': 'Canada',
                'germany': 'Germany',
                'lebanon': 'Lebanon',
                'saudi': 'Saudi Arabia',
                'uae': 'UAE',
                'usa': 'USA'
            };

            selectedCountry = category ? (categoryMap[category] || 'All') : 'All';

            if (selectedCountry === 'Favourites') {
                currentDisplayedChannels = channelFavourites;
            } else if (selectedCountry === 'All') {
                currentDisplayedChannels = [...allChannels];
            } else {
                currentDisplayedChannels = allChannels.filter(ch => ch.country === selectedCountry);
            }

            displayLiveChannels(currentDisplayedChannels);
        }

        // Populate country filter dropdown (kept for potential future use)
        function populateCountryFilter() {
            const countries = ['Favourites', 'All', ...new Set(allChannels.map(ch => ch.country))].sort((a, b) => {
                // Keep Favourites first, All second, then alphabetical
                if (a === 'Favourites') return -1;
                if (b === 'Favourites') return 1;
                if (a === 'All') return -1;
                if (b === 'All') return 1;
                return a.localeCompare(b);
            });
            const container = document.getElementById('countryFilterButtons');
            if (!container) return;

            container.innerHTML = countries.map(country => {
                const isActive = country === selectedCountry ? 'active' : '';
                const icon = country === 'Favourites' ? '' : '';
                return `<button class="bg-animation-toggle ${isActive}" onclick="filterByCountry('${country}')" id="country_${country.replace(/\s+/g, '_')}">
                    ${icon} ${country}
                </button>`;
            }).join('');
        }

        // Filter channels by country
        function filterByCountry(country) {
            selectedCountry = country;

            // Update button states
            document.querySelectorAll('#countryFilterButtons .bg-animation-toggle').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.getElementById(`country_${country.replace(/\s+/g, '_')}`);
            if (activeBtn) activeBtn.classList.add('active');

            // Filter channels
            if (country === 'Favourites') {
                currentDisplayedChannels = channelFavourites;
            } else if (country === 'All') {
                currentDisplayedChannels = [...allChannels];
            } else {
                currentDisplayedChannels = allChannels.filter(ch => ch.country === country);
            }

            // Clear search when changing country
            const searchInput = document.getElementById('channelsSearchInput');
            const clearBtn = document.getElementById('clearChannelsSearchBtn');
            if (searchInput) searchInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';

            displayLiveChannels(currentDisplayedChannels);
        }

        // Display channels as a list
        function displayLiveChannels(channels) {
            const container = document.getElementById('liveChannels');

            if (!channels || channels.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 60px 20px; color: #666;">
                        <h3 style="font-size: 24px; margin-bottom: 12px; color: #00d9ff;">No channels available</h3>
                        <p style="font-size: 18px;">Check back later for live channels</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="channels-list" style="display: flex; flex-direction: column; gap: 8px;">
                    ${channels.map((channel, index) => createChannelRow(channel, index)).join('')}
                </div>
            `;
        }

        // Create a channel row for list view
        function createChannelRow(channel, index) {
            // Get category color
            const categoryColors = {
                'News': '#ff0000',
                'General': '#00d9ff',
                'Music': '#ff00ff',
                'Entertainment': '#00ff9f',
                'Sports': '#ffaa00',
                'Religious': '#9d00ff',
                'Kids': '#ff69b4',
                'Education': '#00bfff',
                'Documentary': '#ffa500',
                'Shopping': '#32cd32',
                'Movies': '#dc143c'
            };
            const categoryColor = categoryColors[channel.category] || '#00d9ff';

            // Country flag emojis
            const countryFlags = {
                'LB': '',
                'SA': '',
                'AE': '',
                'EG': '',
                'CA': '',
                'GB': '',
                'DE': '',
                'US': ''
            };
            const flag = countryFlags[channel.countryCode] || '';

            // Check if channel is in favourites
            const isFavourited = channelFavourites.some(fav => fav.name === channel.name || fav.url === channel.url);

            // Category icons
            const categoryIcons = {
                'News': '',
                'General': '',
                'Music': '',
                'Entertainment': '',
                'Sports': '',
                'Religious': '',
                'Kids': '',
                'Education': '',
                'Documentary': '',
                'Shopping': '',
                'Movies': ''
            };
            const categoryIcon = categoryIcons[channel.category] || '';

            return `
                <div style="
                    display: flex;
                    align-items: center;
                    padding: 12px 16px;
                    background: linear-gradient(135deg, rgba(15, 15, 30, 0.9) 0%, rgba(26, 26, 46, 0.9) 100%);
                    border: 1px solid rgba(0, 217, 255, 0.2);
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    gap: 16px;
                " onclick='playChannel(${index})' onmouseover="this.style.background='linear-gradient(135deg, rgba(26, 26, 46, 1) 0%, rgba(30, 30, 60, 1) 100%)'; this.style.borderColor='${categoryColor}';" onmouseout="this.style.background='linear-gradient(135deg, rgba(15, 15, 30, 0.9) 0%, rgba(26, 26, 46, 0.9) 100%)'; this.style.borderColor='rgba(0, 217, 255, 0.2)';">

                    <!-- Favourite Button -->
                    <button type="button" onclick="event.stopPropagation(); event.preventDefault(); toggleChannelFavourite(${index}); return false;" style="
                        width: 36px;
                        height: 36px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: ${isFavourited ? 'rgba(255, 215, 0, 0.2)' : 'rgba(100, 100, 100, 0.2)'};
                        border: 1px solid ${isFavourited ? '#ffd700' : 'rgba(100, 100, 100, 0.4)'};
                        border-radius: 50%;
                        color: ${isFavourited ? '#ffd700' : '#666'};
                        font-size: 18px;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " title="${isFavourited ? 'Remove from Favourites' : 'Add to Favourites'}">${isFavourited ? '' : ''}</button>

                    <!-- Channel Logo -->
                    <div style="
                        width: 60px;
                        height: 40px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: rgba(0, 0, 0, 0.3);
                        border-radius: 4px;
                        overflow: hidden;
                    ">
                        ${channel.logo ? `
                            <img src="${channel.logo}"
                                 alt="${channel.name}"
                                 style="max-width: 100%; max-height: 100%; object-fit: contain;"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div style="display: none; font-size: 20px;"></div>
                        ` : `
                            <div style="font-size: 20px;"></div>
                        `}
                    </div>

                    <!-- Channel Name -->
                    <div style="flex: 1; min-width: 0;">
                        <div style="color: #00ff9f; font-weight: bold; font-size: 16px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${channel.name}
                        </div>
                    </div>

                    <!-- Category/Type -->
                    <div style="
                        min-width: 120px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        padding: 6px 12px;
                        background: rgba(${categoryColor === '#ff0000' ? '255,0,0' : categoryColor === '#ff00ff' ? '255,0,255' : categoryColor === '#00ff9f' ? '0,255,159' : categoryColor === '#ffaa00' ? '255,170,0' : '0,217,255'}, 0.15);
                        border: 1px solid ${categoryColor};
                        border-radius: 4px;
                        color: ${categoryColor};
                        font-size: 13px;
                    ">
                        <span>${categoryIcon}</span>
                        <span>${channel.category}</span>
                    </div>

                    <!-- Country -->
                    <div style="
                        min-width: 100px;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        color: #888;
                        font-size: 14px;
                    ">
                        <span style="font-size: 18px;">${flag}</span>
                        <span>${channel.country}</span>
                    </div>

                    <!-- Play Icon -->
                    <div style="
                        width: 36px;
                        height: 36px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        background: rgba(0, 255, 159, 0.1);
                        border: 1px solid rgba(0, 255, 159, 0.3);
                        border-radius: 50%;
                        color: #00ff9f;
                        font-size: 14px;
                    "></div>
                </div>
            `;
        }

        // Search channels
        function searchChannels() {
            const searchInput = document.getElementById('channelsSearchInput');
            const clearBtn = document.getElementById('clearChannelsSearchBtn');
            const query = searchInput.value.toLowerCase().trim();

            // Show/hide clear button
            if (clearBtn) {
                clearBtn.style.display = query ? 'block' : 'none';
            }

            // Start with channels filtered by country or favourites
            let baseChannels;
            if (selectedCountry === 'Favourites') {
                baseChannels = channelFavourites; // Use global variable loaded from DB
            } else if (selectedCountry === 'All') {
                baseChannels = allChannels;
            } else {
                baseChannels = allChannels.filter(ch => ch.country === selectedCountry);
            }

            if (!query) {
                currentDisplayedChannels = baseChannels;
                displayLiveChannels(baseChannels);
                return;
            }

            // Filter channels by name, category, or country
            const filteredChannels = baseChannels.filter(channel =>
                channel.name.toLowerCase().includes(query) ||
                channel.category.toLowerCase().includes(query) ||
                channel.country.toLowerCase().includes(query)
            );

            currentDisplayedChannels = filteredChannels;
            displayLiveChannels(filteredChannels);
        }

        // Clear channels search
        function clearChannelsSearch() {
            const searchInput = document.getElementById('channelsSearchInput');
            const clearBtn = document.getElementById('clearChannelsSearchBtn');

            if (searchInput) searchInput.value = '';
            if (clearBtn) clearBtn.style.display = 'none';

            // Respect country filter when clearing search
            if (selectedCountry === 'Favourites') {
                currentDisplayedChannels = channelFavourites; // Use global variable loaded from DB
            } else if (selectedCountry === 'All') {
                currentDisplayedChannels = allChannels;
            } else {
                currentDisplayedChannels = allChannels.filter(ch => ch.country === selectedCountry);
            }
            displayLiveChannels(currentDisplayedChannels);
        }

        // Toggle channel favourite
        async function toggleChannelFavourite(channelIndex) {
            const channel = currentDisplayedChannels[channelIndex];
            if (!channel) return;

            // Require authentication - no localStorage fallback
            if (!authToken) {
                showError('Please login to save favorites');
                showLoginModal();
                return;
            }

            // Use database only - don't redeclare, use the global variable
            const existingIndex = channelFavourites.findIndex(fav => fav.name === channel.name || fav.url === channel.url);

            try {
                if (existingIndex > -1) {
                    // Remove from favourites
                    await removeFromFavoritesAPI(channel.url || channel.name);
                } else {
                    // Add to favourites
                    await addToFavoritesAPI(channel.url || channel.name, channel.name);
                }

                // Reload favorites from database
                await loadFavorites();

                // Refresh the display - if on Favourites view, update currentDisplayedChannels
                if (selectedCountry === 'Favourites') {
                    currentDisplayedChannels = channelFavourites;
                }
                displayLiveChannels(currentDisplayedChannels);
            } catch (error) {
                console.error('Failed to update favorites:', error);
                showError('Failed to update favorites');
            }
        }

        // Play a channel
        function playChannel(channelIndex) {
            const channel = currentDisplayedChannels[channelIndex];
            if (!channel) {
                showError('Channel not found');
                return;
            }

            console.log('Playing channel:', channel);

            // Update current content info
            currentContentId = channelIndex;
            currentContentType = 'channel';
            currentContentTitle = channel.name;

            // Show the player section
            const playerSection = document.getElementById('playerSection');
            const currentContent = document.getElementById('currentContent');
            if (playerSection) playerSection.style.display = 'block';
            if (currentContent) currentContent.style.display = 'block';

            // Hide TV controls
            const tvControls = document.getElementById('tvControls');
            if (tvControls) tvControls.style.display = 'none';

            // Hide OMDB details
            const omdbDetails = document.getElementById('omdbDetails');
            const omdbRatings = document.getElementById('omdbRatings');
            if (omdbDetails) omdbDetails.style.display = 'none';
            if (omdbRatings) omdbRatings.style.display = 'none';

            // Hide sports source button
            const sportsSourceBtn = document.getElementById('sportsSourceBtn');
            if (sportsSourceBtn) sportsSourceBtn.style.display = 'none';

            // Hide video source button
            const sourceMenuContainer2 = document.getElementById('sourceMenuContainer');
            if (sourceMenuContainer2) sourceMenuContainer2.style.display = 'none';

            // Hide source hint
            dismissSourceHint();

            // Hide next episode button
            const nextEpisodeBtn = document.getElementById('nextEpisodeBtn');
            if (nextEpisodeBtn) nextEpisodeBtn.style.display = 'none';

            // Update content info display
            const titleEl = document.getElementById('currentTitle');
            const yearEl = document.getElementById('currentYear');
            const overviewEl = document.getElementById('currentOverview');
            const posterEl = document.getElementById('currentPoster');

            if (titleEl) titleEl.textContent = channel.name;
            if (yearEl) yearEl.textContent = `${channel.category}  ${channel.country} TV - Live Now`;
            if (overviewEl) overviewEl.textContent = `Watch ${channel.name} live from ${channel.country}`;

            // Set backdrop
            const backdropImage = document.getElementById('backdropImage');
            if (backdropImage) {
                backdropImage.style.backgroundImage = 'linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%)';
            }

            // Hide poster for channels
            if (posterEl) {
                posterEl.style.display = 'none';
            }

            // Load the stream - use HLS.js for m3u8 streams
            loadChannelStream(channel.url);

            // Scroll to player
            if (currentContent) {
                currentContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }

            showStatus(`Loading ${channel.name}...`);
        }

        // Load channel stream using HLS.js
        function loadChannelStream(streamUrl) {
            const playerIframe = document.getElementById('contentPlayer');
            const playerVideo = document.getElementById('playerVideo');
            const placeholder = document.getElementById('playerPlaceholder');

            // Hide iframe and placeholder
            if (playerIframe) playerIframe.style.display = 'none';
            if (placeholder) placeholder.style.display = 'none';

            // Show video element and stop button
            if (playerVideo) {
                playerVideo.style.display = 'block';
                const stopBtn = document.getElementById('stopBtn');
                if (stopBtn) stopBtn.style.display = 'inline-block';

                // Check if HLS.js is supported
                if (Hls.isSupported()) {
                    // Destroy existing HLS instance if any
                    if (window.hls) {
                        window.hls.destroy();
                    }

                    // Create new HLS instance
                    window.hls = new Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });

                    // Load the source
                    window.hls.loadSource(streamUrl);
                    window.hls.attachMedia(playerVideo);

                    // Handle events
                    window.hls.on(Hls.Events.MANIFEST_PARSED, function() {
                        playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                    });

                    // Add watchparty sync listeners for live channels
                    setupVideoSyncListeners(playerVideo);

                    window.hls.on(Hls.Events.ERROR, function(event, data) {
                        console.error('HLS error:', data);
                        if (data.fatal) {
                            switch(data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    showError('Network error - trying to recover...');
                                    window.hls.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    showError('Media error - trying to recover...');
                                    window.hls.recoverMediaError();
                                    break;
                                default:
                                    showError('Fatal error - cannot play this stream');
                                    window.hls.destroy();
                                    break;
                            }
                        }
                    });
                }
                // Check if the browser supports HLS natively (Safari)
                else if (playerVideo.canPlayType('application/vnd.apple.mpegurl')) {
                    playerVideo.src = streamUrl;
                    playerVideo.addEventListener('loadedmetadata', function() {
                        playerVideo.play().catch(e => console.log('Autoplay prevented:', e));
                    });

                    // Add watchparty sync listeners for live channels
                    setupVideoSyncListeners(playerVideo);
                } else {
                    showError('HLS playback not supported in this browser');
                }
            }
        }

        // ============= END LIVE CHANNELS SECTION =============

        // ============= AUTHENTICATION & API SYSTEM =============

        // Automatically detect API base URL based on environment
        const AUTH_API_BASE_URL = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
            ? 'http://localhost:5001/api'  // Local development
            : `${window.location.origin}/api`;  // Production (same origin)

        let authToken = localStorage.getItem('authToken');
        window.authToken = authToken;  // Set globally for rating system
        let currentUser = null;
        try {
            const storedUser = localStorage.getItem('currentUser');
            if (storedUser) {
                currentUser = JSON.parse(storedUser);
                window.currentUser = currentUser;  // Set globally for rating system
            }
        } catch(e) {
            console.error('Failed to load currentUser from localStorage:', e);
        }

        // API Helper Function
        async function apiRequest(endpoint, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            const url = `${AUTH_API_BASE_URL}${endpoint}`;
            console.log('[API] Request:', options.method || 'GET', url);
            console.log('[API] Headers:', headers);

            try {
                const response = await fetch(url, {
                    ...options,
                    headers
                });

                console.log('[API] Response status:', response.status);

                if (response.status === 401) {
                    // Token expired or invalid
                    console.log('[API] 401 Unauthorized - logging out');
                    logout();
                    throw new Error('Authentication required');
                }

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'API request failed');
                }

                return data;
            } catch (error) {
                console.error('API Error:', error);
                throw error;
            }
        }

        // Modal Functions - exposed to global scope for onclick handlers
        window.showLoginModal = function() {
            console.log('[showLoginModal] Opening login modal');
            document.getElementById('loginModal').style.display = 'flex';
            document.getElementById('loginError').style.display = 'none';
        }

        window.closeLoginModal = function() {
            document.getElementById('loginModal').style.display = 'none';
            document.getElementById('loginForm').reset();
        }

        window.showRegisterModal = function() {
            document.getElementById('registerModal').style.display = 'flex';
            document.getElementById('registerError').style.display = 'none';
        }

        window.closeRegisterModal = function() {
            document.getElementById('registerModal').style.display = 'none';
            document.getElementById('registerForm').reset();
        }

        window.showFriendsModal = function() {
            document.getElementById('friendsModal').style.display = 'block';
            loadFriends();
            loadFriendRequests();
        }

        window.closeFriendsModal = function() {
            document.getElementById('friendsModal').style.display = 'none';
        }

        // Friend Request Notifications
        let pendingFriendRequests = [];

        async function fetchPendingFriendRequests() {
            if (!authToken) {
                console.log('[Friend Requests] No auth token, skipping fetch');
                return;
            }

            try {
                console.log('[Friend Requests] Fetching pending requests...');
                const requests = await apiRequest('/friends/requests', { method: 'GET' });
                console.log('[Friend Requests] Received:', requests);
                pendingFriendRequests = requests || [];
                console.log('[Friend Requests] Count:', pendingFriendRequests.length);
                updateFriendRequestNotification();
            } catch (error) {
                console.error('[Friend Requests] Failed to fetch:', error);
                pendingFriendRequests = [];
                updateFriendRequestNotification();
            }
        }

        function updateFriendRequestNotification() {
            const countElement = document.getElementById('friendRequestCount');
            const notificationIcon = document.getElementById('friendRequestNotification');
            const badgeElement = document.getElementById('friendRequestBadge');
            const count = pendingFriendRequests.length;

            console.log('[Friend Requests] Updating count - count:', count, 'element:', !!countElement);

            if (countElement) {
                if (count > 0) {
                    countElement.textContent = `(+${count})`;
                    countElement.style.display = 'inline';
                    console.log('[Friend Requests] Count shown:', count);
                } else {
                    countElement.style.display = 'none';
                    console.log('[Friend Requests] Count hidden (no requests)');
                }
            } else {
                console.error('[Friend Requests] Count element not found!');
            }

            // Update the home screen notification icon
            if (notificationIcon && badgeElement) {
                if (count > 0) {
                    notificationIcon.classList.add('has-requests');
                    badgeElement.textContent = count;
                    console.log('[Friend Requests] Home icon shown with count:', count);
                } else {
                    notificationIcon.classList.remove('has-requests');
                    console.log('[Friend Requests] Home icon hidden (no requests)');
                }
            }
        }

        // No longer need dropdown functionality - count shows on Friends button
        // When user clicks Friends button, modal opens showing all pending requests

        // Poll for friend requests every 30 seconds
        setInterval(fetchPendingFriendRequests, 30000);

        // Expose for testing
        window.testFriendNotification = fetchPendingFriendRequests;

        // Close modals on outside click
        document.getElementById('loginModal')?.addEventListener('click', function(e) {
            if (e.target === this) closeLoginModal();
        });
        document.getElementById('registerModal')?.addEventListener('click', function(e) {
            if (e.target === this) closeRegisterModal();
        });

        // Authentication Handlers
        async function handleLogin(event) {
            event.preventDefault();
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;
            const errorEl = document.getElementById('loginError');

            try {
                const data = await apiRequest('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({ username, password })
                });

                authToken = data.access_token;
                window.authToken = authToken;  // Set globally for rating system
                localStorage.setItem('authToken', authToken);
                currentUser = data.user;
                window.currentUser = currentUser;  // Set globally for rating system
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

                closeLoginModal();
                updateAuthUI();
                await loadUserData();
                showStatus('Logged in successfully!');
            } catch (error) {
                errorEl.textContent = error.message;
                errorEl.style.display = 'block';
            }
        }

        async function handleRegister(event) {
            event.preventDefault();
            const username = document.getElementById('registerUsername').value;
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const errorEl = document.getElementById('registerError');

            try {
                const data = await apiRequest('/auth/register', {
                    method: 'POST',
                    body: JSON.stringify({ username, email, password })
                });

                authToken = data.access_token;
                window.authToken = authToken;  // Set globally for rating system
                localStorage.setItem('authToken', authToken);
                currentUser = data.user;
                window.currentUser = currentUser;  // Set globally for rating system
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

                closeRegisterModal();
                updateAuthUI();
                await loadUserData();
                showStatus('Account created successfully!');
            } catch (error) {
                errorEl.textContent = error.message;
                errorEl.style.display = 'block';
            }
        }

        window.logout = function() {
            authToken = null;
            window.authToken = null;  // Clear global token
            currentUser = null;
            window.currentUser = null;  // Clear global user
            localStorage.removeItem('authToken');
            localStorage.removeItem('currentUser');

            // Clear database-loaded data from memory
            watchlists = JSON.parse(localStorage.getItem('streamingSite_watchlists') || '{"My Watchlist": []}');
            watchHistory = JSON.parse(localStorage.getItem('streamingSite_watchHistory') || '[]');

            // Stop comments polling
            if (commentsPollingInterval) {
                clearInterval(commentsPollingInterval);
                commentsPollingInterval = null;
            }

            // Hide comments section
            hideCommentsSection();

            // Don't auto-switch to any tab - let user choose
            // Reset current tab
            currentTab = null;
            // Hide all sections
            document.getElementById('contentResults').style.display = 'none';
            document.getElementById('continueWatchingDisplay').style.display = 'none';
            document.getElementById('watchlistDisplay').style.display = 'none';
            document.getElementById('statisticsDisplay').style.display = 'none';
            document.getElementById('sportsDisplay').style.display = 'none';
            document.getElementById('channelsDisplay').style.display = 'none';
            // Remove active tab styling
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            updateAuthUI();
            showStatus('Logged out successfully');
        }

        function updateAuthUI() {
            const authButtons = document.getElementById('authButtons');
            const userMenu = document.getElementById('userMenu');
            const usernameDisplay = document.getElementById('usernameDisplay');
            const userMenuBtn = document.getElementById('userMenuBtn');
            const userMenuDropdown = document.getElementById('userMenuDropdown');
            const userMenuText = document.getElementById('userMenuText');
            const userMenuIcon = document.getElementById('userMenuIcon');

            // Get icon sources with fallback
            const userIcon = (typeof BASE64_IMAGES !== 'undefined' && BASE64_IMAGES.USER_ICON) ? BASE64_IMAGES.USER_ICON : '';
            const friendsIcon = (typeof BASE64_IMAGES !== 'undefined' && BASE64_IMAGES.FRIENDS_ICON) ? BASE64_IMAGES.FRIENDS_ICON : '';
            const logoutIcon = (typeof BASE64_IMAGES !== 'undefined' && BASE64_IMAGES.LOGOUT_ICON) ? BASE64_IMAGES.LOGOUT_ICON : '';

            if (authToken && currentUser) {
                // Hide old buttons
                authButtons.style.display = 'none';
                userMenu.style.display = 'none';
                usernameDisplay.textContent = currentUser.username;

                // Update new user menu
                userMenuBtn.classList.add('logged-in');
                userMenuText.textContent = currentUser.username;
                userMenuText.style.display = 'inline';

                // Update icon size for logged in state (20x20)
                userMenuIcon.style.width = '20px';
                userMenuIcon.style.height = '20px';

                // Populate dropdown for logged-in user
                userMenuDropdown.innerHTML = `
                    <div class="user-menu-username">@${currentUser.username}</div>
                    <button class="user-menu-item" onclick="showFriendsModal(); closeUserMenu();">
                        ${friendsIcon ? `<img src="${friendsIcon}" alt="Friends" style="width: 32px; height: 32px; image-rendering: pixelated; margin-right: 10px;">` : '<span style="font-size: 28px; margin-right: 10px;"></span>'} Friends
                    </button>
                    <button class="user-menu-item" onclick="toggleThemeSelector(); closeUserMenu();">
                        <img src="Icons/theme.png" alt="Theme" style="width: 32px; height: 32px; margin-right: 10px;"> Theme
                    </button>
                    <button class="user-menu-item" onclick="toggleEffectsPanel(); closeUserMenu();">
                        <img src="Icons/effect.png" alt="Effects" style="width: 32px; height: 32px; margin-right: 10px;"> Effects
                    </button>
                    <button class="user-menu-item" onclick="toggleWatchpartyPanel(); closeUserMenu();">
                        <img src="Icons/party.png" alt="Party" style="width: 32px; height: 32px; margin-right: 10px;"> Party
                    </button>
                    <div class="user-menu-divider"></div>
                    <button class="user-menu-item" onclick="showTab('statistics'); closeUserMenu();">
                        <img src="Icons/stats.png" alt="Stats" style="width: 32px; height: 32px; margin-right: 10px;"> Stats
                    </button>
                    <button class="user-menu-item" onclick="logout(); closeUserMenu();" style="justify-content: center; padding: 0;">
                        <img src="Icons/logout.png" alt="Logout" style="width: 120px; height: 100px; display: block;">
                    </button>
                `;
            } else {
                // Hide old buttons
                authButtons.style.display = 'none';
                userMenu.style.display = 'none';

                // Update new user menu
                userMenuBtn.classList.remove('logged-in');
                userMenuText.textContent = '';
                userMenuText.style.display = 'none';

                // Update icon size for logged out state (30x30)
                userMenuIcon.style.width = '30px';
                userMenuIcon.style.height = '30px';

                // Populate dropdown for guest user
                userMenuDropdown.innerHTML = `
                    <button class="user-menu-item" onclick="showLoginModal(); closeUserMenu();">
                        ${userIcon ? `<img src="${userIcon}" alt="Login" style="width: 32px; height: 32px; image-rendering: pixelated; margin-right: 10px;">` : '<span style="font-size: 28px; margin-right: 10px;"></span>'} Login
                    </button>
                    <button class="user-menu-item" onclick="showRegisterModal(); closeUserMenu();">
                        <span style="font-size: 28px; margin-right: 10px;"></span> Sign Up
                    </button>
                `;
            }
        }

        // User Menu Toggle Functions
        window.toggleUserMenu = function() {
            const dropdown = document.getElementById('userMenuDropdown');
            const btn = document.getElementById('userMenuBtn');
            dropdown.classList.toggle('show');
            btn.classList.toggle('menu-open');
        };

        window.closeUserMenu = function() {
            const dropdown = document.getElementById('userMenuDropdown');
            const btn = document.getElementById('userMenuBtn');
            dropdown.classList.remove('show');
            btn.classList.remove('menu-open');
        };

        // Close user menu when clicking outside
        document.addEventListener('click', function(event) {
            const userMenuContainer = document.querySelector('.user-menu-container');
            const dock = document.getElementById('glassDock');
            const dropdown = document.getElementById('userMenuDropdown');
            const btn = document.getElementById('userMenuBtn');
            if (userMenuContainer && !userMenuContainer.contains(event.target) && !(dock && dock.contains(event.target))) {
                dropdown.classList.remove('show');
                if (btn) btn.classList.remove('menu-open');
            }
        });

        // Load user data on page load
        async function loadUserData() {
            if (!authToken) {
                console.log('[Auth] No auth token found, skipping user data load');
                return;
            }

            console.log('[Auth] Loading user data...');
            try {
                currentUser = await apiRequest('/auth/me');
                console.log('[Auth] User authenticated:', currentUser.username);
                updateAuthUI();

                await Promise.all([
                    loadWatchlist(),
                    loadContinueWatching(),
                    loadFavorites(),
                    fetchPendingFriendRequests()
                ]);

                console.log('[Auth] User data loaded successfully');
                // Don't auto-switch to any tab - let user choose
            } catch (error) {
                console.error('[Auth] Failed to load user data:', error);
                if (error.message && error.message.includes('401')) {
                    console.log('[Auth] Token expired or invalid, clearing auth');
                    // Token is invalid, clear it
                    authToken = null;
                    localStorage.removeItem('authToken');
                    updateAuthUI();
                }
            }
        }

        // Watchlist Functions
        async function loadWatchlist() {
            if (!authToken) return;

            try {
                const watchlist = await apiRequest('/watchlist');
                console.log('[Watchlist] Loaded from database:', watchlist);
                console.log('[Watchlist] Is array?', Array.isArray(watchlist), 'Length:', watchlist?.length);

                // Only update if API call was successful (database is source of truth)
                // Don't clear existing data until we have the DB response
                if (watchlist && watchlist.length > 0) {
                    // Organize items by list_name
                    watchlists = {};
                    watchlist.forEach(item => {
                        const listName = item.list_name || 'My Watchlist';
                        if (!watchlists[listName]) {
                            watchlists[listName] = [];
                        }
                        watchlists[listName].push({
                            id: item.content_id,
                            type: item.content_type,
                            title: item.title,
                            posterUrl: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : 'https://via.placeholder.com/500x750/333/fff?text=No+Poster'
                        });
                    });
                    console.log('[Watchlist] Updated with DB data, lists:', Object.keys(watchlists));
                } else if (watchlist && watchlist.length === 0) {
                    // API returned successfully but empty - user has no watchlist items
                    watchlists = { 'My Watchlist': [] };
                    console.log('[Watchlist] DB returned empty, cleared watchlist');
                }
                // If watchlist is null/undefined (API error), keep existing data

                // Update UI if watchlist tab is active
                const watchlistTab = document.querySelector('[onclick*="watchlist"]');
                if (watchlistTab && watchlistTab.classList.contains('active')) {
                    displayWatchlistInResults();
                }
            } catch (error) {
                console.error('[Watchlist] Failed to load:', error);
                // Don't clear existing data on error - keep localStorage data
            }
        }

        async function addToWatchlistAPI(contentId, contentType, title, posterPath, listName = 'My Watchlist') {
            if (!authToken) {
                showLoginModal();
                return;
            }

            try {
                // Extract just the path if it's a full URL
                let posterPathOnly = posterPath;
                if (posterPath && posterPath.includes('image.tmdb.org')) {
                    // Extract path from: https://image.tmdb.org/t/p/w500/abc.jpg -> /abc.jpg
                    const match = posterPath.match(/\/t\/p\/w\d+(\/.+)/);
                    if (match) posterPathOnly = match[1];
                }

                console.log('[Watchlist] Adding to DB:', {
                    content_id: contentId,
                    content_type: contentType,
                    title: title,
                    poster_path: posterPathOnly,
                    list_name: listName
                });

                const result = await apiRequest('/watchlist', {
                    method: 'POST',
                    body: JSON.stringify({
                        content_id: contentId,
                        content_type: contentType,
                        title: title,
                        poster_path: posterPathOnly,
                        list_name: listName
                    })
                });
                console.log('[Watchlist] Added successfully:', result);
                showStatus(`Added to ${listName}!`);
                await loadWatchlist();
            } catch (error) {
                console.error('[Watchlist] Failed to add:', error);
                showError(error.message);
            }
        }

        async function removeFromWatchlistAPI(contentId) {
            if (!authToken) return;

            try {
                await apiRequest(`/watchlist/${contentId}`, { method: 'DELETE' });
                showStatus('Removed from watchlist');
                await loadWatchlist();
            } catch (error) {
                showError(error.message);
            }
        }

        // Continue Watching Functions
        async function loadContinueWatching() {
            if (!authToken) return;

            try {
                const items = await apiRequest('/continue-watching');
                console.log('[Continue Watching] Loaded from database:', items);
                console.log('[Continue Watching] Is array?', Array.isArray(items), 'Length:', items?.length);

                // Only update if API call was successful (database is source of truth)
                // Don't clear existing data until we have the DB response
                if (items && items.length > 0) {
                    watchHistory = items.map(item => ({
                        id: item.content_id,
                        type: item.content_type,
                        title: item.title,
                        posterUrl: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : 'https://via.placeholder.com/200x300/333/fff?text=No+Poster',
                        progress: item.progress || 0,
                        lastWatched: item.last_watched || new Date().toISOString(),
                        year: item.year || new Date().getFullYear(),
                        season: item.season || 1,
                        episode: item.episode || 1
                    }));
                    console.log('[Continue Watching] Updated with DB data, now has', watchHistory.length, 'items');
                } else if (items && items.length === 0) {
                    // API returned successfully but empty - user has no continue watching items
                    watchHistory = [];
                    console.log('[Continue Watching] DB returned empty, cleared history');
                }
                // If items is null/undefined (API error), keep existing data

                // Update UI if continue watching tab is active
                displayContinueWatchingInResults();
            } catch (error) {
                console.error('[Continue Watching] Failed to load:', error);
                // Don't clear existing data on error - keep localStorage data
            }
        }

        async function updateContinueWatchingAPI(contentId, contentType, title, posterPath, progress, season, episode) {
            if (!authToken) return;

            try {
                // Extract just the path if it's a full URL
                let posterPathOnly = posterPath;
                if (posterPath && posterPath.includes('image.tmdb.org')) {
                    const match = posterPath.match(/\/t\/p\/w\d+(\/.+)/);
                    if (match) posterPathOnly = match[1];
                } else if (posterPath && posterPath.includes('placeholder')) {
                    posterPathOnly = null; // Don't save placeholder URLs
                }

                console.log('[Continue Watching] Updating in DB:', {
                    content_id: contentId,
                    content_type: contentType,
                    title: title,
                    poster_path: posterPathOnly,
                    progress: progress,
                    season: season,
                    episode: episode
                });

                const result = await apiRequest('/continue-watching', {
                    method: 'POST',
                    body: JSON.stringify({
                        content_id: contentId,
                        content_type: contentType,
                        title: title,
                        poster_path: posterPathOnly,
                        progress: progress,
                        season: season,
                        episode: episode
                    })
                });
                console.log('[Continue Watching] Updated successfully:', result);
            } catch (error) {
                console.error('[Continue Watching] Failed to update:', error);
            }
        }

        // Favorites Functions
        async function loadFavorites() {
            if (!authToken) return;

            try {
                const favorites = await apiRequest('/favorites');
                console.log('Favorites loaded from database:', favorites);

                // Update global variable - database is source of truth
                channelFavourites = [];

                if (favorites && favorites.length > 0) {
                    favorites.forEach(fav => {
                        channelFavourites.push({
                            name: fav.channel_name,
                            url: fav.channel_id,
                            id: fav.channel_id
                        });
                    });
                }

                // Refresh live channels display if on that tab
                const liveChannelsTab = document.querySelector('[onclick*="live-channels"]');
                if (liveChannelsTab && liveChannelsTab.classList.contains('active')) {
                    // Redisplay current channels to show updated favorites
                    if (typeof currentDisplayedChannels !== 'undefined' && currentDisplayedChannels) {
                        displayLiveChannels(currentDisplayedChannels);
                    }
                }
            } catch (error) {
                console.error('Failed to load favorites:', error);
            }
        }

        async function addToFavoritesAPI(channelId, channelName) {
            if (!authToken) {
                showLoginModal();
                return;
            }

            try {
                await apiRequest('/favorites', {
                    method: 'POST',
                    body: JSON.stringify({
                        channel_id: channelId,
                        channel_name: channelName
                    })
                });
                showStatus('Added to favorites!');
                await loadFavorites();
            } catch (error) {
                showError(error.message);
            }
        }

        async function removeFromFavoritesAPI(channelId) {
            if (!authToken) return;

            try {
                await apiRequest('/favorites/' + encodeURIComponent(channelId), {
                    method: 'DELETE'
                });
                showStatus('Removed from favorites');
                await loadFavorites();
            } catch (error) {
                // Fallback: try POST route
                try {
                    await apiRequest('/favorites/remove', {
                        method: 'POST',
                        body: JSON.stringify({ channel_id: channelId })
                    });
                    showStatus('Removed from favorites');
                    await loadFavorites();
                } catch (e2) {
                    showError(e2.message);
                }
            }
        }

        // Friends Functions
        // Store friends list globally for checking status
        let currentFriendsList = [];

        async function loadFriends() {
            console.log('[Friends] loadFriends called, authToken:', !!authToken);
            if (!authToken) return;

            try {
                console.log('[Friends] Fetching friends list...');
                const response = await apiRequest('/friends');
                console.log('[Friends] Received response:', response);
                console.log('[Friends] Response type:', typeof response);
                console.log('[Friends] Is array:', Array.isArray(response));

                // Handle different response formats
                let friends = response;
                if (response && response.friends && Array.isArray(response.friends)) {
                    friends = response.friends;
                } else if (!Array.isArray(response)) {
                    console.error('[Friends] Response is not an array:', response);
                    const friendsList = document.getElementById('friendsList');
                    friendsList.innerHTML = '<div class="friends-empty-state"><span style="color: #ff6b6b;"> Error loading connections</span></div>';
                    return;
                }

                console.log('[Friends] Friends array:', friends);
                currentFriendsList = friends; // Store for checking status
                const friendsList = document.getElementById('friendsList');

                if (friends.length === 0) {
                    console.log('[Friends] No friends found');
                    friendsList.innerHTML = '<div class="friends-empty-state"> No connections established</div>';
                    return;
                }

                console.log('[Friends] Rendering', friends.length, 'friends');

                // Clear existing content
                friendsList.innerHTML = '';

                // Create elements with new Network Terminal styling
                friends.forEach(friend => {
                    const container = document.createElement('div');
                    container.className = 'friend-card';

                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'friend-request-info';

                    const avatar = document.createElement('div');
                    avatar.className = 'friend-avatar friend-status-online';
                    avatar.textContent = friend.username ? friend.username.charAt(0).toUpperCase() : '?';

                    const username = document.createElement('span');
                    username.className = 'friend-username';
                    username.textContent = friend.username;

                    infoDiv.appendChild(avatar);
                    infoDiv.appendChild(username);

                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'friend-btn-reject';
                    removeBtn.textContent = 'Disconnect';
                    removeBtn.onclick = () => removeFriend(friend.id);

                    container.appendChild(infoDiv);
                    container.appendChild(removeBtn);
                    friendsList.appendChild(container);
                });
            } catch (error) {
                console.error('Failed to load friends:', error);
            }
        }

        async function loadFriendRequests() {
            if (!authToken) return;

            try {
                const requests = await apiRequest('/friends/requests');
                const requestsList = document.getElementById('friendRequestsList');

                if (requests.length === 0) {
                    requestsList.innerHTML = '<div class="friends-empty-state"> No incoming requests</div>';
                    return;
                }

                // Clear existing content
                requestsList.innerHTML = '';

                // Create elements with Network Terminal styling
                requests.forEach(req => {
                    const container = document.createElement('div');
                    container.className = 'friend-request-card';

                    const infoDiv = document.createElement('div');
                    infoDiv.className = 'friend-request-info';

                    const avatar = document.createElement('div');
                    avatar.className = 'friend-avatar';
                    avatar.style.borderColor = '#ff00ff';
                    avatar.textContent = req.from_user.username ? req.from_user.username.charAt(0).toUpperCase() : '?';

                    const username = document.createElement('span');
                    username.className = 'friend-username';
                    username.textContent = req.from_user.username;

                    infoDiv.appendChild(avatar);
                    infoDiv.appendChild(username);

                    const buttonContainer = document.createElement('div');
                    buttonContainer.className = 'friend-request-actions';

                    const acceptBtn = document.createElement('button');
                    acceptBtn.className = 'friend-btn-accept';
                    acceptBtn.textContent = ' Accept';
                    acceptBtn.onclick = () => acceptFriendRequest(req.id);

                    const rejectBtn = document.createElement('button');
                    rejectBtn.className = 'friend-btn-reject';
                    rejectBtn.textContent = ' Reject';
                    rejectBtn.onclick = () => rejectFriendRequest(req.id);

                    buttonContainer.appendChild(acceptBtn);
                    buttonContainer.appendChild(rejectBtn);

                    container.appendChild(infoDiv);
                    container.appendChild(buttonContainer);

                    requestsList.appendChild(container);
                });
            } catch (error) {
                console.error('Failed to load friend requests:', error);
            }
        }

        let searchFriendsTimeout;
        async function searchFriends() {
            const query = document.getElementById('friendSearchInput').value.trim();
            const resultsDiv = document.getElementById('friendSearchResults');
            console.log('[Friends] Search query:', query);

            if (query.length < 2) {
                resultsDiv.innerHTML = '';
                return;
            }

            clearTimeout(searchFriendsTimeout);
            searchFriendsTimeout = setTimeout(async () => {
                try {
                    console.log('[Friends] Searching for:', query);
                    const results = await apiRequest(`/friends/search?q=${encodeURIComponent(query)}`);
                    console.log('[Friends] Search results:', results);

                    if (results.length === 0) {
                        resultsDiv.innerHTML = '<p style="color: #666; padding: 12px;">No users found</p>';
                        return;
                    }

                    // Clear existing content
                    resultsDiv.innerHTML = '';

                    // Create elements programmatically
                    results.forEach(user => {
                        const container = document.createElement('div');
                        container.style.cssText = 'background: rgba(15, 15, 30, 0.6); border: 2px solid var(--accent-color); padding: 12px; margin-bottom: 8px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;';

                        const username = document.createElement('span');
                        username.style.cssText = 'color: #e0e0e0; font-family: "VT323", monospace; font-size: 18px;';
                        username.textContent = user.username;

                        // Check if already friends
                        const isFriend = currentFriendsList.some(f => f.id === user.id || f.username === user.username);

                        const addBtn = document.createElement('button');
                        addBtn.className = 'btn';
                        if (isFriend) {
                            addBtn.style.cssText = 'padding: 8px 16px; background: #00ff9f; cursor: default;';
                            addBtn.textContent = ' Friends';
                            addBtn.disabled = true;
                        } else {
                            addBtn.style.cssText = 'padding: 8px 16px;';
                            addBtn.textContent = 'Add Friend';
                            addBtn.onclick = () => sendFriendRequest(user.username);
                        }

                        container.appendChild(username);
                        container.appendChild(addBtn);
                        resultsDiv.appendChild(container);
                    });
                } catch (error) {
                    resultsDiv.innerHTML = '<p style="color: #ff6b6b; padding: 12px;">Error searching users</p>';
                }
            }, 300);
        }

        async function sendFriendRequest(username) {
            try {
                await apiRequest('/friends/request', {
                    method: 'POST',
                    body: JSON.stringify({ username })
                });
                showStatus('Friend request sent!');
                document.getElementById('friendSearchInput').value = '';
                document.getElementById('friendSearchResults').innerHTML = '';
            } catch (error) {
                showError(error.message);
            }
        }

        async function acceptFriendRequest(requestId) {
            try {
                await apiRequest(`/friends/requests/${requestId}/accept`, { method: 'POST' });
                showStatus('Friend request accepted!');
                await loadFriends();
                await loadFriendRequests();
                await fetchPendingFriendRequests();
            } catch (error) {
                showError(error.message);
            }
        }

        async function rejectFriendRequest(requestId) {
            try {
                await apiRequest(`/friends/requests/${requestId}/reject`, { method: 'POST' });
                showStatus('Friend request rejected');
                await loadFriendRequests();
                await fetchPendingFriendRequests();
            } catch (error) {
                showError(error.message);
            }
        }

        async function removeFriend(friendId) {
            if (!confirm('Are you sure you want to remove this friend?')) return;

            try {
                await apiRequest(`/friends/${friendId}`, { method: 'DELETE' });
                showStatus('Friend removed');
                await loadFriends();
            } catch (error) {
                showError(error.message);
            }
        }

        // Comments Functions
        let currentContentComments = [];
        let commentsPollingInterval = null;
        let lastCommentsHash = '';

        async function loadComments(contentId) {
            if (!authToken) return [];

            try {
                const comments = await apiRequest(`/comments/${contentId}`);
                console.log('[Comments] Loaded comments:', comments);
                console.log('[Comments] Number of top-level comments:', comments.length);
                comments.forEach((comment, i) => {
                    console.log(`[Comments] Comment ${i}:`, comment.comment_text.substring(0, 30));
                    console.log(`[Comments]   - Has ${comment.replies?.length || 0} direct replies`);
                    if (comment.replies && comment.replies.length > 0) {
                        comment.replies.forEach((reply, j) => {
                            console.log(`[Comments]     Reply ${j}:`, reply.comment_text.substring(0, 30));
                            console.log(`[Comments]       - Has ${reply.replies?.length || 0} nested replies`);
                        });
                    }
                });
                currentContentComments = comments;
                return comments;
            } catch (error) {
                console.error('Failed to load comments:', error);
                return [];
            }
        }

        async function addComment(contentId, contentType, commentText) {
            if (!authToken) {
                showLoginModal();
                return;
            }

            try {
                await apiRequest('/comments', {
                    method: 'POST',
                    body: JSON.stringify({
                        content_id: contentId,
                        content_type: contentType,
                        comment_text: commentText
                    })
                });
                showStatus('Comment added!');
                return await loadComments(contentId);
            } catch (error) {
                showError(error.message);
                return [];
            }
        }

        async function deleteComment(commentId, contentId) {
            try {
                await apiRequest(`/comments/${commentId}`, { method: 'DELETE' });
                showStatus('Comment deleted');
                return await loadComments(contentId);
            } catch (error) {
                showError(error.message);
                return [];
            }
        }

        // Comments UI Functions

        window.toggleComments = function() {
            const commentsSection = document.getElementById('commentsSection');
            const isVisible = commentsSection.style.display === 'block';

            if (isVisible) {
                hideCommentsSection();
            } else if (currentContentId && currentContentType) {
                showCommentsSection(currentContentId, currentContentType);
            } else {
                showError('No content is currently playing');
            }
        }

        function showCommentsSection(contentId, contentType) {
            if (!authToken) {
                showError('Please login to view and post comments');
                return;
            }

            currentContentId = contentId;
            currentContentType = contentType;
            document.getElementById('commentsSection').style.display = 'block';
            displayComments(contentId);

            // Start polling for new comments every 30 seconds
            if (commentsPollingInterval) {
                clearInterval(commentsPollingInterval);
            }
            commentsPollingInterval = setInterval(() => {
                displayComments(contentId);
            }, 30000);
        }

        function hideCommentsSection() {
            document.getElementById('commentsSection').style.display = 'none';

            // Stop polling when comments section is hidden
            if (commentsPollingInterval) {
                clearInterval(commentsPollingInterval);
                commentsPollingInterval = null;
            }
        }

        // Recursive function to render nested replies
        function renderReplies(replies, depth = 0) {
            console.log(`[Comments] renderReplies called with ${replies?.length || 0} replies at depth ${depth}`);
            if (!replies || replies.length === 0) return '';

            return replies.map((reply, index) => {
                console.log(`[Comments]   Rendering reply ${index} at depth ${depth}: "${reply.comment_text.substring(0, 30)}"`);
                console.log(`[Comments]     Reply has ${reply.replies?.length || 0} nested replies`);
                const replyDate = new Date(reply.created_at);
                const isOwnReply = currentUser && reply.user_id === currentUser.id;
                const likeIconReply = reply.liked_by_user ? '' : '';
                const userInitial = reply.username ? reply.username.charAt(0).toUpperCase() : '?';

                // Recursively render nested replies underneath this reply
                const nestedRepliesHTML = renderReplies(reply.replies || [], depth + 1);

                return `
                    <div class="transmission-reply">
                        <div class="transmission-message ${isOwnReply ? 'own-message' : ''}" style="margin-bottom: 8px;">
                            <div class="transmission-message-header">
                                <div class="transmission-avatar" style="width: 32px; height: 32px; font-size: 14px; ${isOwnReply ? 'border-color: #00ff9f;' : ''}">${userInitial}</div>
                                <span class="transmission-username" style="font-size: 16px;">${reply.username}${isOwnReply ? ' (You)' : ''}</span>
                                <span class="transmission-timestamp">${replyDate.toLocaleDateString()} ${replyDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                                ${isOwnReply ? `<button onclick="event.stopPropagation(); deleteCommentUI('${reply._id}')" class="transmission-action-btn" style="color: #ff6b6b; margin-left: 8px; font-size: 12px;"></button>` : ''}
                            </div>
                            <div class="transmission-content" style="padding-left: 42px; font-size: 16px;">${escapeHtml(reply.comment_text)}</div>
                            <div class="transmission-actions" style="padding-left: 42px;">
                                <button onclick="event.stopPropagation(); toggleLike('${reply._id}')" class="transmission-action-btn ${reply.liked_by_user ? 'liked' : ''}" style="font-size: 13px;">
                                    <span>${likeIconReply}</span>
                                    <span id="like-count-${reply._id}">${reply.like_count || 0}</span>
                                </button>
                                <button onclick="event.stopPropagation(); showReplyBox('${reply._id}')" class="transmission-action-btn" style="font-size: 13px;">
                                     Reply
                                </button>
                            </div>
                            <div id="reply-box-${reply._id}" class="transmission-reply-box" style="display: none; margin-left: 42px;">
                                <textarea id="reply-textarea-${reply._id}" placeholder="Transmit reply..."
                                          maxlength="500"
                                          rows="1"
                                          oninput="autoResizeTextarea(this)"></textarea>
                                <div class="transmission-reply-actions">
                                    <button onclick="submitReply('${reply._id}')" class="transmission-reply-btn"> Send</button>
                                    <button onclick="hideReplyBox('${reply._id}')" class="transmission-reply-btn cancel">Cancel</button>
                                </div>
                            </div>
                        </div>
                        ${nestedRepliesHTML}
                    </div>
                `;
            }).join('');
        }

        async function displayComments(contentId) {
            const comments = await loadComments(contentId);
            const commentsList = document.getElementById('commentsList');

            // Skip DOM rebuild if comments data hasn't changed
            const commentsHash = JSON.stringify(comments);
            if (commentsHash === lastCommentsHash) {
                return;
            }
            lastCommentsHash = commentsHash;

            // Preserve scroll position, open reply boxes, textarea values, AND focus state
            const scrollPos = commentsList.scrollTop;
            const openReplyBoxes = [];
            const textareaValues = {};
            let focusedTextareaId = null;
            let focusedSelectionStart = 0;
            let focusedSelectionEnd = 0;
            document.querySelectorAll('[id^="reply-box-"]').forEach(box => {
                if (box.style.display !== 'none') {
                    const commentId = box.id.replace('reply-box-', '');
                    openReplyBoxes.push(commentId);
                    // Also preserve the textarea value
                    const textarea = document.getElementById(`reply-textarea-${commentId}`);
                    if (textarea) {
                        if (textarea.value) {
                            textareaValues[commentId] = textarea.value;
                        }
                        // Track if this textarea is focused
                        if (document.activeElement === textarea) {
                            focusedTextareaId = `reply-textarea-${commentId}`;
                            focusedSelectionStart = textarea.selectionStart;
                            focusedSelectionEnd = textarea.selectionEnd;
                        }
                    }
                }
            });

            if (comments.length === 0) {
                commentsList.innerHTML = '<div class="friends-empty-state" style="padding: 40px; text-align: center;"><span style="font-size: 40px; display: block; margin-bottom: 16px; opacity: 0.5;"></span><p style="color: rgba(0, 217, 255, 0.6); font-family: \'VT323\', monospace; font-size: 18px;">No transmissions yet.<br>Be the first to broadcast.</p></div>';
                return;
            }

            // Generate new comments HTML with Transmission Log styling
            const newCommentsHTML = comments.map(comment => {
                const date = new Date(comment.created_at);
                const isOwnComment = currentUser && comment.user_id === currentUser.id;

                // Use recursive function to render all nested replies
                const repliesHTML = renderReplies(comment.replies || [], 0);

                const likeIcon = comment.liked_by_user ? '' : '';
                const userInitial = comment.username ? comment.username.charAt(0).toUpperCase() : '?';

                return`
                    <div class="transmission-message ${isOwnComment ? 'own-message' : ''}">
                        <div class="transmission-message-header">
                            <div class="transmission-avatar" style="${isOwnComment ? 'border-color: #00ff9f;' : ''}">${userInitial}</div>
                            <span class="transmission-username">${comment.username}${isOwnComment ? ' (You)' : ''}</span>
                            <span class="transmission-timestamp">${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                            ${isOwnComment ? `<button onclick="event.stopPropagation(); deleteCommentUI('${comment._id}')" class="transmission-action-btn" style="color: #ff6b6b; margin-left: 8px;"> Delete</button>` : ''}
                        </div>
                        <div class="transmission-content">${escapeHtml(comment.comment_text)}</div>
                        <div class="transmission-actions">
                            <button onclick="event.stopPropagation(); toggleLike('${comment._id}')" class="transmission-action-btn ${comment.liked_by_user ? 'liked' : ''}">
                                <span>${likeIcon}</span>
                                <span id="like-count-${comment._id}">${comment.like_count || 0}</span>
                            </button>
                            <button onclick="event.stopPropagation(); showReplyBox('${comment._id}')" class="transmission-action-btn">
                                 Reply
                            </button>
                        </div>
                        <div id="reply-box-${comment._id}" class="transmission-reply-box" style="display: none;">
                            <textarea id="reply-textarea-${comment._id}" placeholder="Transmit reply..."
                                      maxlength="500"
                                      rows="1"
                                      oninput="autoResizeTextarea(this)"></textarea>
                            <div class="transmission-reply-actions">
                                <button onclick="submitReply('${comment._id}')" class="transmission-reply-btn"> Send</button>
                                <button onclick="hideReplyBox('${comment._id}')" class="transmission-reply-btn cancel">Cancel</button>
                            </div>
                        </div>
                        ${repliesHTML}
                    </div>
                `;
            }).join('');

            // Only update if content changed to avoid flashing
            if (commentsList.innerHTML !== newCommentsHTML) {
                commentsList.innerHTML = newCommentsHTML;
                // Restore scroll position
                commentsList.scrollTop = scrollPos;
                // Restore open reply boxes AND their textarea values
                openReplyBoxes.forEach(commentId => {
                    const replyBox = document.getElementById(`reply-box-${commentId}`);
                    if (replyBox) {
                        replyBox.style.display = 'block';
                        // Restore the textarea value if it existed
                        if (textareaValues[commentId]) {
                            const textarea = document.getElementById(`reply-textarea-${commentId}`);
                            if (textarea) {
                                textarea.value = textareaValues[commentId];
                                // Re-trigger auto-resize to match content
                                autoResizeTextarea(textarea);
                            }
                        }
                    }
                });
                // Restore focus and cursor position
                if (focusedTextareaId) {
                    const textarea = document.getElementById(focusedTextareaId);
                    if (textarea) {
                        textarea.focus();
                        textarea.setSelectionRange(focusedSelectionStart, focusedSelectionEnd);
                    }
                }
            }
        }

        window.submitComment = async function() {
            const textarea = document.getElementById('commentTextarea');
            const commentText = textarea.value.trim();

            if (!commentText) {
                showError('Please enter a comment');
                return;
            }

            if (!currentContentId || !currentContentType) {
                showError('No content selected');
                return;
            }

            await addComment(currentContentId, currentContentType, commentText);
            textarea.value = '';
            textarea.style.height = 'auto';
            updateCharCount();
            await displayComments(currentContentId);
        }

        async function deleteCommentUI(commentId) {
            if (!confirm('Delete this comment?')) return;
            await deleteComment(commentId, currentContentId);
            await displayComments(currentContentId);
        }

        function updateCharCount() {
            const textarea = document.getElementById('commentTextarea');
            const charCount = document.getElementById('commentCharCount');
            if (textarea && charCount) {
                charCount.textContent = `${textarea.value.length}/500`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Auto-resize textarea
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, parseInt(textarea.style.maxHeight)) + 'px';
        }

        // Toggle like on a comment
        async function toggleLike(commentId) {
            if (!authToken) {
                showError('Please login to like comments');
                return;
            }

            try {
                const likeCountEl = document.getElementById(`like-count-${commentId}`);
                if (!likeCountEl) return;

                // Check if already liked by finding the heart icon
                const likeBtn = likeCountEl.closest('button');
                const heartIcon = likeBtn.querySelector('span:first-child');
                const isLiked = heartIcon.textContent === '';

                if (isLiked) {
                    // Unlike
                    const response = await apiRequest(`/comments/${commentId}/like`, { method: 'DELETE' });
                    likeCountEl.textContent = response.like_count;
                    heartIcon.textContent = '';
                } else {
                    // Like
                    const response = await apiRequest(`/comments/${commentId}/like`, { method: 'POST' });
                    likeCountEl.textContent = response.like_count;
                    heartIcon.textContent = '';
                }
            } catch (error) {
                console.error('Failed to toggle like:', error);
            }
        }

        // Show reply box
        function showReplyBox(commentId) {
            const replyBox = document.getElementById(`reply-box-${commentId}`);
            if (replyBox) {
                replyBox.style.display = 'block';
                const textarea = document.getElementById(`reply-textarea-${commentId}`);
                if (textarea) textarea.focus();
            }
        }

        // Hide reply box
        function hideReplyBox(commentId) {
            const replyBox = document.getElementById(`reply-box-${commentId}`);
            if (replyBox) {
                replyBox.style.display = 'none';
                const textarea = document.getElementById(`reply-textarea-${commentId}`);
                if (textarea) textarea.value = '';
            }
        }

        // Submit reply
        async function submitReply(parentCommentId) {
            console.log('[Comments] submitReply called with parentCommentId:', parentCommentId);
            const textarea = document.getElementById(`reply-textarea-${parentCommentId}`);
            const replyText = textarea.value.trim();
            console.log('[Comments] Reply text:', replyText);

            if (!replyText) {
                showError('Please enter a reply');
                return;
            }

            if (!currentContentId || !currentContentType) {
                showError('No content selected');
                return;
            }

            const payload = {
                content_id: currentContentId,
                content_type: currentContentType,
                comment_text: replyText,
                parent_comment_id: parentCommentId
            };
            console.log('[Comments] Submitting reply with payload:', payload);

            try {
                const result = await apiRequest('/comments', {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });
                console.log('[Comments] Reply submitted successfully:', result);

                textarea.value = '';
                hideReplyBox(parentCommentId);
                console.log('[Comments] Refreshing comments display...');
                await displayComments(currentContentId);
                console.log('[Comments] Comments display refreshed');
            } catch (error) {
                console.error('[Comments] Error submitting reply:', error);
                showError(error.message);
            }
        }

        // Add event listener for character count
        document.addEventListener('DOMContentLoaded', function() {
            const textarea = document.getElementById('commentTextarea');
            if (textarea) {
                textarea.addEventListener('input', updateCharCount);
            }
        });

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateAuthUI();
            loadUserData();
        });

        // ============= END AUTHENTICATION & API SYSTEM =============

        // Log that all functions are loaded
        console.log('[INIT] Script fully loaded. Functions available:', {
            showTab: typeof window.showTab,
            showLoginModal: typeof window.showLoginModal,
            showRegisterModal: typeof window.showRegisterModal,
            logout: typeof window.logout
        });

        // ============= END THEME & ANIMATION SYSTEM =============
    </script>
    <script>
        /* ===================== User Ratings Injection (You + Friends) ===================== */
        (function(){
          if (window.__userRatingsInjected) return; 
          window.__userRatingsInjected = true;
        
          // --- small helpers ---
          function getToken(){
            return (window.authToken) ||
                   localStorage.getItem('authToken') ||
                   localStorage.getItem('jwt') ||
                   localStorage.getItem('token') ||
                   localStorage.getItem('access_token');
          }
          function getCurrentUser(){
            if (window.currentUser) return window.currentUser;
            try { return JSON.parse(localStorage.getItem('currentUser') || 'null'); } catch(_) { return null; }
          }
          function showToast(msg){
            try { (window.showError || window.showToast || console.log)(msg); } catch(_) {}
          }
        
          // Prefer site-wide API helper if present (cookie/session), else add Authorization header
          const API_BASE = '/api';
          const baseFetch = async (path, opt={}) => {
                // Always ensure path starts with /api but don't double it
                let url = path;
                if (!path.startsWith('/api')) {
                  url = API_BASE + (path.startsWith('/') ? '' : '/') + path;
                }
                const token = getToken();
                const headers = Object.assign({'Content-Type':'application/json'}, opt.headers || {});
                if (token) headers['Authorization'] = 'Bearer ' + token;
                const res = await fetch(url, Object.assign({ headers, credentials: 'include' }, opt));
                if (!res.ok) {
                  const text = await res.text().catch(()=> '');
                  const err = new Error(text || ('HTTP ' + res.status));
                  err.status = res.status;
                  throw err;
                }
                return res.status === 204 ? null : res.json();
              };
        
          // Track current title identity (movie/tv + TMDB id)
          let currentContentType = window.currentContentType || null;
          let currentContentId   = window.currentContentId   || null;
          let isRefreshing = false; // Prevent concurrent refreshes
        
          // ---- DOM location helpers ----
          function closestContainerFromKnownIds(){
            const ids = ['imdbRating','rtRating','metacriticRating'];
            const els = ids.map(id => document.getElementById(id)).filter(Boolean);
            if (!els.length) return null;
            for (const el of els) {
              const grid = el.closest('.ratings-container');
              if (grid) return grid;
            }
            // Fallback: common parent of value nodes
            let parent = els[0].parentElement;
            for (let i=1;i<els.length;i++){
              const set = new Set();
              let n = els[i].parentElement;
              while (n){ set.add(n); n = n.parentElement; }
              while (parent && !set.has(parent)) parent = parent.parentElement;
              if (!parent) break;
            }
            return parent || null;
          }
        
          function hostRatingsBox(){
            let container =
              document.querySelector('#omdbRatings .ratings-container') ||
              document.querySelector('.omdb-ratings .ratings-container') ||
              document.querySelector('.ratings-container');
        
            if (!container){
              container = closestContainerFromKnownIds();
            }
        
            if (!container){
              // Last resort: create a minimal grid under the info column
              const info = document.querySelector('.current-content-info') || document.querySelector('.player-section') || document.body;
              if (!info) return null;
              let outer = document.getElementById('omdbRatings') || document.createElement('div');
              if (!outer.id) outer.id = 'omdbRatings';
              outer.classList.add('omdb-ratings');
              container = document.createElement('div');
              container.className = 'ratings-container';
              outer.appendChild(container);
              info.prepend(outer);
            }
            return container;
          }
        
          // ---- UI creation ----
          function ensurePill(container){
            if (!container) return null;
            let pill = document.getElementById('userRatingPill');
            if (pill && pill.parentElement !== container){
              pill.remove(); pill = null;
            }
            if (pill) return pill;
        
            pill = document.createElement('div');
            pill.className = 'rating-item user-pill';
            pill.id = 'userRatingPill';
            pill.innerHTML = `
              <div class="rating-source">You</div>
              <div class="rating-value" id="userRatingValue"></div>
              <div style="display:flex; align-items:center; gap:8px; margin-top:4px;">
                <input id="userRatingInput" type="number" min="1" max="10" step="0.1" placeholder="110" />
                <button class="post-btn" id="postUserRatingBtn">Post</button>
              </div>
            `;
            container.appendChild(pill);
            const btn = pill.querySelector('#postUserRatingBtn');
            btn.addEventListener('click', postUserRating);
            return pill;
          }
        
          async function getFriendUsernames(){
            try {
              const r = await baseFetch('/friends', { method: 'GET' });
              console.log('[Ratings] getFriendUsernames response:', r);

              // Handle both array and object formats
              let friendsList = [];
              if (Array.isArray(r)) {
                // Backend returns array directly: [{id: '...', username: '...'}, ...]
                friendsList = r;
              } else if (r && Array.isArray(r.friends)) {
                // Backend returns object: {friends: [...]}
                friendsList = r.friends;
              }

              const usernames = friendsList.map(f => (f.username || f));
              console.log('[Ratings] Friend usernames:', usernames);
              return usernames;
            } catch(e){
              console.error('[Ratings] getFriendUsernames failed:', e);
              return [];
            }
          }
        
          async function postUserRating(){
            console.log('[Ratings] postUserRating called');
            if (!currentContentId || !currentContentType){
              console.log('[Ratings] Missing content info', { currentContentId, currentContentType });
              showToast('Select a title first');
              return;
            }
            const input = document.getElementById('userRatingInput');
            const val = parseFloat(input && input.value);
            console.log('[Ratings] Rating value:', val);
            if (isNaN(val) || val < 1 || val > 10){
              showToast('Enter a rating from 1 to 10');
              return;
            }
            try{
              const url = `/ratings/${currentContentType}/${currentContentId}`;
              console.log('[Ratings] Posting to:', url, 'with rating:', val);
              const result = await baseFetch(url, {
                method: 'POST',
                body: JSON.stringify({ rating: val })
              });
              console.log('[Ratings] Post result:', result);
              await refreshRatingsUI();
              showToast('Saved');
            }catch(e){
              console.error('[Ratings] Post failed:', e);
              if (e && (e.status === 401 || /401/.test(String(e.message||'')))){
                if (window.showLoginModal) showLoginModal(); else alert('Please log in');
              } else {
                console.error(e); showToast('Failed to save');
              }
            }
          }
        
          async function refreshRatingsUI(){
            console.log('[Ratings] refreshRatingsUI called', { currentContentType, currentContentId, isRefreshing });

            // Prevent concurrent refreshes
            if (isRefreshing) {
              console.log('[Ratings] Already refreshing, skipping...');
              return;
            }

            const container = hostRatingsBox();
            if (!container || !currentContentId || !currentContentType) {
              console.log('[Ratings] Missing container or content info', { container: !!container, currentContentId, currentContentType });
              return;
            }

            isRefreshing = true;
            console.log('[Ratings] Starting refresh...');

            // Ensure "You" tile
            ensurePill(container);

            // Fetch aggregated ratings
            let data = { ratings_by_user: {} };
            try {
              const url = `/ratings/${currentContentType}/${currentContentId}`;
              console.log('[Ratings] Fetching from:', url);
              data = await baseFetch(url, { method: 'GET' });
              console.log('[Ratings] Received data:', data);
            } catch(e){
              console.error('[Ratings] Fetch failed:', e);
            }

            const cu = getCurrentUser();
            console.log('[Ratings] getCurrentUser() returned:', cu);
            const me = (cu && (cu.username || cu.name)) || null;
            console.log('[Ratings] Current user (me):', me);
            console.log('[Ratings] window.currentUser:', window.currentUser);
            console.log('[Ratings] localStorage currentUser:', localStorage.getItem('currentUser'));
            console.log('[Ratings] Ratings by user:', data.ratings_by_user);
            console.log('[Ratings] All usernames in ratings:', Object.keys(data.ratings_by_user || {}));

            // Update "You" tile UI
            const input = document.getElementById('userRatingInput');
            const btn = document.getElementById('postUserRatingBtn');
            const youValEl = document.getElementById('userRatingValue');
            const yourVal = me ? data.ratings_by_user?.[me] : null;
            console.log('[Ratings] Checking for rating: data.ratings_by_user[' + me + '] =', data.ratings_by_user?.[me]);
            console.log('[Ratings] Your rating value (yourVal):', yourVal);

            if (input) input.value = (yourVal || '');
            if (btn) btn.textContent = yourVal ? 'Update' : 'Post';
            if (youValEl) {
                const displayValue = yourVal ? `${yourVal}/10` : '';
                console.log('[Ratings] Setting youValEl.textContent to:', displayValue);
                youValEl.textContent = displayValue;
            } else {
                console.log('[Ratings] youValEl not found!');
            }

            // Remove prior friend tiles
            container.querySelectorAll('.friend-rating-item').forEach(n => n.remove());

            // Render friend ratings as tiles like others
            try{
              const friends = await getFriendUsernames();
              console.log('[Ratings] Friends list:', friends);
              console.log('[Ratings] Current user (me):', me);

              // Log all ratings to see who has rated
              const allRatings = Object.entries(data.ratings_by_user || {});
              console.log('[Ratings] All ratings:', allRatings);

              // Filter to only show friend ratings (exclude own rating)
              const friendEntries = allRatings.filter(([username, rating]) => {
                const isMe = (me && username === me);
                const isFriend = friends.includes(username);
                console.log(`[Ratings] Check ${username}: isMe=${isMe}, isFriend=${isFriend}`);
                return !isMe && isFriend;
              });
              console.log('[Ratings] Friend ratings to display:', friendEntries);
              console.log('[Ratings] Number of friend ratings:', friendEntries.length);

              for (const [u, v] of friendEntries){
                console.log(`[Ratings] Creating tile for friend ${u} with rating ${v}`);
                const tile = document.createElement('div');
                tile.className = 'rating-item friend-rating-item';
                tile.innerHTML = `
                  <div class="rating-source">@${u}</div>
                  <div class="rating-value">${v}/10</div>
                `;
                container.appendChild(tile);
                console.log('[Ratings] Tile appended to container for ${u}');
              }
              console.log('[Ratings] Finished rendering friend ratings. Total rendered:', friendEntries.length);
            }catch(e){
              console.error('[Ratings] Friends rendering failed:', e);
            } finally {
              isRefreshing = false;
              console.log('[Ratings] Refresh complete, flag reset');
            }
          }
        
          // --- Wire-up: when details are loaded, set ids and refresh ---
          if (!window.fetch.__rfRatingsWrap){
            const _orig = window.fetch;
            const wrapped = async function(url, options){
              const res = await _orig.apply(this, arguments);
              try{
                let href = typeof url === 'string' ? url : (url && url.url) || '';
                const m = href && href.match(/\/api\/(movie|tv)\/(\d+)/);
                if (m){
                  currentContentType = m[1];
                  currentContentId = parseInt(m[2], 10);
                  console.log('[Ratings] Fetch intercepted:', currentContentType, currentContentId);
                  // after response resolves and DOM updates, seed the pill
                  // Try multiple times with increasing delays to ensure DOM is ready
                  setTimeout(() => {
                    console.log('[Ratings] First attempt to setup ratings UI');
                    setupUserRatingsPill();
                  }, 300);
                  setTimeout(() => {
                    console.log('[Ratings] Second attempt to setup ratings UI');
                    setupUserRatingsPill();
                  }, 800);
                }
              }catch(e){
                console.error('[Ratings] Fetch wrapper error:', e);
              }
              return res;
            };
            Object.defineProperty(wrapped, '__rfRatingsWrap', { value: true });
            window.fetch = wrapped;
          }
        
          // Keep pill present if grid re-renders
          let __gridObserver = null;
          function observeGrid(container){
            try{
              if (!container) return;
              if (__gridObserver) __gridObserver.disconnect();
              __gridObserver = new MutationObserver(() => {
                if (!document.getElementById('userRatingPill')) ensurePill(container);
              });
              __gridObserver.observe(container, { childList: true });
            }catch(_){}
          }
        
          let __lastRefreshedContentId = null;

          function setupUserRatingsPill(){
            const box = hostRatingsBox();
            console.log('[Ratings] setupUserRatingsPill called - container found:', !!box, 'contentType:', currentContentType, 'contentId:', currentContentId);
            if (!box) {
              console.log('[Ratings] No ratings container found yet, will retry');
              return;
            }
            console.log('[Ratings] Ensuring pill exists...');
            ensurePill(box);
            console.log('[Ratings] Setting up grid observer...');
            observeGrid(box);

            // Only refresh if we have valid content info and haven't already refreshed for this content
            if (currentContentType && currentContentId) {
              const contentKey = `${currentContentType}_${currentContentId}`;
              if (__lastRefreshedContentId !== contentKey) {
                console.log('[Ratings] Calling refreshRatingsUI to load friend ratings for:', contentKey);
                __lastRefreshedContentId = contentKey;
                try {
                  refreshRatingsUI();
                } catch(e){
                  console.error('[Ratings] refreshRatingsUI error:', e);
                }
              } else {
                console.log('[Ratings] Already refreshed for this content:', contentKey);
              }
            } else {
              console.log('[Ratings] No valid content info yet, skipping refresh');
            }
          }
        
          document.addEventListener('DOMContentLoaded', () => {
            setTimeout(setupUserRatingsPill, 300);
          });
        })();
        </script>
    <script>
        // Set base64 images from external file
            // Set custom cursor from base64
            if (typeof BASE64_IMAGES !== 'undefined' && BASE64_IMAGES.CURSOR_ICON) {
                document.documentElement.style.setProperty('--custom-cursor', "url('" + BASE64_IMAGES.CURSOR_ICON + "') 0 0");
            }

        document.addEventListener('DOMContentLoaded', function() {
            const userMenuIcon = document.getElementById('userMenuIcon');
            if (userMenuIcon) {
                userMenuIcon.src = 'Icons/user.png';
            }
        });
    </script>

    <!-- ============= AUTH GATE & ONBOARDING SCRIPT ============= -->
    <script>
    (function() {
        'use strict';

        // ========== AUTH GATE SYSTEM ==========

        const AUTH_GATE_API_BASE = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
            ? 'http://localhost:5001/api'
            : `${window.location.origin}/api`;

        // Create floating particles for auth gate
        function createAuthParticles() {
            const container = document.getElementById('authParticles');
            if (!container) return;

            const colors = ['#00ff9f', '#00d9ff', '#ff00ff'];
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'auth-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (15 + Math.random() * 15) + 's';
                container.appendChild(particle);
            }
        }

        // Switch between login and signup tabs
        window.switchAuthTab = function(tab) {
            const loginTab = document.getElementById('authLoginTab');
            const signupTab = document.getElementById('authSignupTab');
            const loginPanel = document.getElementById('authLoginPanel');
            const signupPanel = document.getElementById('authSignupPanel');

            // Clear errors
            document.getElementById('authLoginError').classList.remove('visible');
            document.getElementById('authSignupError').classList.remove('visible');

            if (tab === 'login') {
                loginTab.classList.add('active');
                signupTab.classList.remove('active');
                loginPanel.classList.add('active');
                signupPanel.classList.remove('active');
            } else {
                loginTab.classList.remove('active');
                signupTab.classList.add('active');
                loginPanel.classList.remove('active');
                signupPanel.classList.add('active');
            }
        };

        // Auth gate login handler
        window.handleAuthGateLogin = async function(event) {
            event.preventDefault();
            const username = document.getElementById('authLoginUsername').value;
            const password = document.getElementById('authLoginPassword').value;
            const errorEl = document.getElementById('authLoginError');

            try {
                const response = await fetch(`${AUTH_GATE_API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Login failed');
                }

                // Store auth data
                authToken = data.access_token;
                currentUser = data.user;
                localStorage.setItem('authToken', data.access_token);
                localStorage.setItem('currentUser', JSON.stringify(data.user));
                window.authToken = data.access_token;
                window.currentUser = data.user;

                // Hide auth gate
                hideAuthGate();

                // Update main UI
                if (typeof updateAuthUI === 'function') {
                    updateAuthUI();
                }
                if (typeof loadUserData === 'function') {
                    loadUserData();
                }
                if (typeof showStatus === 'function') {
                    showStatus('Welcome back, ' + data.user.username + '!');
                }

            } catch (error) {
                errorEl.textContent = error.message;
                errorEl.classList.add('visible');
            }
        };

        // Auth gate signup handler
        window.handleAuthGateSignup = async function(event) {
            event.preventDefault();
            const username = document.getElementById('authSignupUsername').value;
            const email = document.getElementById('authSignupEmail').value;
            const password = document.getElementById('authSignupPassword').value;
            const errorEl = document.getElementById('authSignupError');

            try {
                const response = await fetch(`${AUTH_GATE_API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Registration failed');
                }

                // Store auth data
                authToken = data.access_token;
                currentUser = data.user;
                localStorage.setItem('authToken', data.access_token);
                localStorage.setItem('currentUser', JSON.stringify(data.user));
                window.authToken = data.access_token;
                window.currentUser = data.user;

                // Hide auth gate
                hideAuthGate();

                // Mark as new user for onboarding
                localStorage.setItem('glitchbox_onboarding_pending', 'true');

                // Show onboarding for new users
                showOnboarding(data.user.username);

                // Update main UI
                if (typeof updateAuthUI === 'function') {
                    updateAuthUI();
                }
                if (typeof loadUserData === 'function') {
                    loadUserData();
                }

            } catch (error) {
                errorEl.textContent = error.message;
                errorEl.classList.add('visible');
            }
        };

        // Hide auth gate with animation
        function hideAuthGate() {
            const gate = document.getElementById('authGate');
            if (gate) {
                gate.classList.add('hidden');
                setTimeout(() => {
                    gate.style.display = 'none';
                }, 800);
            }
        }

        // Show auth gate
        function showAuthGate() {
            const gate = document.getElementById('authGate');
            if (gate) {
                gate.style.display = 'flex';
                gate.classList.remove('hidden');
            }
        }

        // Check authentication status on page load
        function checkAuthOnLoad() {
            const token = localStorage.getItem('authToken');
            const user = localStorage.getItem('currentUser');

            if (token && user) {
                // User is logged in, hide auth gate
                hideAuthGate();

                // Check if onboarding was pending (interrupted)
                const onboardingPending = localStorage.getItem('glitchbox_onboarding_pending');
                const onboardingCompleted = localStorage.getItem('glitchbox_onboarding_completed');

                if (onboardingPending === 'true' && onboardingCompleted !== 'true') {
                    try {
                        const userData = JSON.parse(user);
                        showOnboarding(userData.username);
                    } catch(e) {
                        console.error('Failed to parse user data for onboarding:', e);
                    }
                }
            } else {
                // User not logged in, show auth gate
                showAuthGate();
            }
        }

        // ========== ONBOARDING SYSTEM ==========

        let currentOnboardingSlide = 0;
        const totalOnboardingSlides = 8;

        // Create progress dots
        function createOnboardingProgress() {
            const container = document.getElementById('onboardingProgress');
            if (!container) return;

            container.innerHTML = '';
            for (let i = 0; i < totalOnboardingSlides; i++) {
                const dot = document.createElement('div');
                dot.className = 'onboarding-progress-dot' + (i === 0 ? ' active' : '');
                dot.dataset.slide = i;
                dot.onclick = () => goToOnboardingSlide(i);
                container.appendChild(dot);
            }
        }

        // Show onboarding overlay
        function showOnboarding(username) {
            const overlay = document.getElementById('onboardingOverlay');
            const usernameEl = document.getElementById('onboardingUsername');

            if (usernameEl) {
                usernameEl.textContent = username || 'User';
            }

            currentOnboardingSlide = 0;
            createOnboardingProgress();
            updateOnboardingSlide();

            if (overlay) {
                overlay.classList.add('active');
            }
        }

        // Update visible slide
        function updateOnboardingSlide() {
            // Update slides
            for (let i = 0; i < totalOnboardingSlides; i++) {
                const slide = document.getElementById('onboardingSlide' + i);
                if (slide) {
                    slide.classList.remove('active', 'exiting');
                    if (i === currentOnboardingSlide) {
                        slide.classList.add('active');
                    }
                }
            }

            // Update progress dots
            const dots = document.querySelectorAll('.onboarding-progress-dot');
            dots.forEach((dot, i) => {
                dot.classList.remove('active', 'completed');
                if (i < currentOnboardingSlide) {
                    dot.classList.add('completed');
                } else if (i === currentOnboardingSlide) {
                    dot.classList.add('active');
                }
            });

            // Update button text
            const nextBtn = document.getElementById('onboardingNext');
            const skipBtn = document.getElementById('onboardingSkip');

            if (nextBtn) {
                if (currentOnboardingSlide === totalOnboardingSlides - 1) {
                    nextBtn.textContent = 'Start Streaming';
                } else if (currentOnboardingSlide === 0) {
                    nextBtn.textContent = "Let's Go";
                } else {
                    nextBtn.textContent = 'Next';
                }
            }

            // Hide skip on last slide
            if (skipBtn) {
                skipBtn.style.display = currentOnboardingSlide === totalOnboardingSlides - 1 ? 'none' : 'inline-block';
            }
        }

        // Go to specific slide
        function goToOnboardingSlide(index) {
            if (index < 0 || index >= totalOnboardingSlides) return;

            const currentSlide = document.getElementById('onboardingSlide' + currentOnboardingSlide);
            if (currentSlide) {
                currentSlide.classList.add('exiting');
            }

            setTimeout(() => {
                currentOnboardingSlide = index;
                updateOnboardingSlide();
            }, 200);
        }

        // Next slide
        window.nextOnboardingSlide = function() {
            if (currentOnboardingSlide < totalOnboardingSlides - 1) {
                goToOnboardingSlide(currentOnboardingSlide + 1);
            } else {
                completeOnboarding();
            }
        };

        // Skip onboarding
        window.skipOnboarding = function() {
            completeOnboarding();
        };

        // Complete onboarding
        function completeOnboarding() {
            const overlay = document.getElementById('onboardingOverlay');

            // Mark onboarding as completed
            localStorage.setItem('glitchbox_onboarding_completed', 'true');
            localStorage.removeItem('glitchbox_onboarding_pending');

            // Create confetti effect
            createConfetti();

            // Hide overlay after animation
            setTimeout(() => {
                if (overlay) {
                    overlay.classList.remove('active');
                }

                // Show welcome message
                if (typeof showStatus === 'function') {
                    const user = localStorage.getItem('currentUser');
                    try {
                        const userData = JSON.parse(user);
                        showStatus('Welcome to GlitchBox, ' + userData.username + '!');
                    } catch(e) {
                        showStatus('Welcome to GlitchBox!');
                    }
                }
            }, 500);
        }

        // Create confetti celebration effect
        function createConfetti() {
            const overlay = document.getElementById('onboardingOverlay');
            if (!overlay) return;

            const colors = ['#00ff9f', '#00d9ff', '#ff00ff', '#ffbd2e', '#ff5f56'];
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'onboarding-confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.top = '-20px';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = (5 + Math.random() * 10) + 'px';
                confetti.style.height = (5 + Math.random() * 10) + 'px';
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                overlay.appendChild(confetti);

                setTimeout(() => {
                    confetti.classList.add('active');
                }, 50);

                // Clean up
                setTimeout(() => {
                    confetti.remove();
                }, 3500);
            }
        }

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', function() {
            createAuthParticles();
            checkAuthOnLoad();
        });

        // Override the logout function to show auth gate again
        const originalLogout = window.logout;
        window.logout = function() {
            if (originalLogout) {
                originalLogout();
            }
            showAuthGate();
        };

    })();
    </script>
    <!-- ============= END AUTH GATE & ONBOARDING SCRIPT ============= -->

    <!-- Liquid Glass SVG Filter -->
    <svg style="display:none">
        <filter id="glass-distortion" x="0%" y="0%" width="100%" height="100%" filterUnits="objectBoundingBox">
            <feTurbulence type="fractalNoise" baseFrequency="0.001 0.005" numOctaves="1" seed="17" result="turbulence"/>
            <feComponentTransfer in="turbulence" result="mapped">
                <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5"/>
                <feFuncG type="gamma" amplitude="0" exponent="1" offset="0"/>
                <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5"/>
            </feComponentTransfer>
            <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap"/>
            <feSpecularLighting in="softMap" surfaceScale="5" specularConstant="1" specularExponent="100" lightingColor="white" result="specLight">
                <fePointLight x="-200" y="-200" z="300"/>
            </feSpecularLighting>
            <feComposite in="specLight" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" result="litImage"/>
            <feDisplacementMap in="SourceGraphic" in2="softMap" scale="200" xChannelSelector="R" yChannelSelector="G"/>
        </filter>
    </svg>

    <!-- Liquid Glass Dock -->
    <div class="glass-dock-wrapper" id="glassDock">
        <div class="glass-dock">
            <div class="glass-dock-blur"></div>
            <div class="glass-dock-tint"></div>
            <div class="glass-dock-specular"></div>
            <div class="glass-dock-items">
                <button class="glass-dock-btn" id="dockBtnUser" data-tooltip="Profile" onclick="dockTogglePanel('user')">
                    <img id="dockUserIcon" src="Icons/user.png" alt="User">
                </button>
                <div class="glass-dock-sep"></div>
                <button class="glass-dock-btn" id="dockBtnLists" data-tooltip="My Lists" onclick="dockTogglePanel('lists')">
                    <img src="to-do-list.png" alt="Lists" style="filter: brightness(1.3);">
                </button>
                <button class="glass-dock-btn" id="dockBtnLive" data-tooltip="Live" onclick="dockTogglePanel('live')">
                    <img src="live-stream.png" alt="Live">
                </button>
                <div class="glass-dock-sep"></div>
                <button class="glass-dock-btn" id="dockBtnSearch" data-tooltip="Search" onclick="dockTogglePanel('search')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
    // ============= LIQUID GLASS DOCK CONTROLLER =============
    (function() {
        var activeDockPanel = null;

        function closeAllDockPanels() {
            // User menu
            var userDrop = document.getElementById('userMenuDropdown');
            if (userDrop) userDrop.classList.remove('show');

            // Watchlist
            var wlPanel = document.getElementById('watchlistSlidePanel');
            if (wlPanel) wlPanel.classList.remove('active');
            if (typeof window.watchlistPanelOpen !== 'undefined') window.watchlistPanelOpen = false;

            // Live
            var livePanel = document.getElementById('liveSlidePanel');
            if (livePanel) livePanel.classList.remove('active');
            if (typeof window.livePanelOpen !== 'undefined') window.livePanelOpen = false;

            // Search
            var searchPanel = document.querySelector('.floating-search-panel');
            if (searchPanel) searchPanel.classList.remove('active');
            if (typeof window.floatingSearchOpen !== 'undefined') window.floatingSearchOpen = false;

            // Remove active states from all dock buttons
            document.querySelectorAll('.glass-dock-btn').forEach(function(btn) {
                btn.classList.remove('dock-active');
            });

            activeDockPanel = null;
        }

        window.dockTogglePanel = function(panelName) {
            var wasActive = activeDockPanel === panelName;

            // Close everything first
            closeAllDockPanels();

            if (wasActive) return; // Was open, now closed

            activeDockPanel = panelName;

            switch(panelName) {
                case 'user':
                    var dropdown = document.getElementById('userMenuDropdown');
                    if (dropdown) dropdown.classList.add('show');
                    document.getElementById('dockBtnUser').classList.add('dock-active');
                    break;

                case 'lists':
                    var wl = document.getElementById('watchlistSlidePanel');
                    if (wl) {
                        wl.classList.add('active');
                        window.watchlistPanelOpen = true;
                        if (typeof renderWatchlistLists === 'function') renderWatchlistLists();
                    }
                    document.getElementById('dockBtnLists').classList.add('dock-active');
                    break;

                case 'live':
                    var lp = document.getElementById('liveSlidePanel');
                    if (lp) {
                        lp.classList.add('active');
                        window.livePanelOpen = true;
                        if (typeof showLiveMainOptions === 'function') showLiveMainOptions();
                    }
                    document.getElementById('dockBtnLive').classList.add('dock-active');
                    break;

                case 'search':
                    var sp = document.querySelector('.floating-search-panel');
                    if (sp) {
                        sp.classList.add('active');
                        window.floatingSearchOpen = true;
                        setTimeout(function() {
                            var input = document.getElementById('floatingSearchInput');
                            if (input) { input.focus(); input.select(); }
                        }, 150);
                    }
                    document.getElementById('dockBtnSearch').classList.add('dock-active');
                    break;
            }
        };

        // Initialize dock: tag panels with dock-panel class and activate dock mode
        function initDock() {
            document.body.classList.add('glass-dock-active');

            var userDrop = document.getElementById('userMenuDropdown');
            if (userDrop) userDrop.classList.add('dock-panel');

            var wlPanel = document.getElementById('watchlistSlidePanel');
            if (wlPanel) wlPanel.classList.add('dock-panel');

            var livePanel = document.getElementById('liveSlidePanel');
            if (livePanel) livePanel.classList.add('dock-panel');

            var searchPanel = document.querySelector('.floating-search-panel');
            if (searchPanel) searchPanel.classList.add('dock-panel');

            // Make watchlist and live containers visible (dock handles display now)
            var wlContainer = document.getElementById('watchlistContainer');
            if (wlContainer) wlContainer.style.display = 'block';

            var liveContainer = document.getElementById('liveContainer');
            if (liveContainer) liveContainer.style.display = 'block';

            var searchContainer = document.getElementById('floatingSearch');
            if (searchContainer) searchContainer.style.display = 'block';

            // Sync dock user icon with user menu icon
            var origIcon = document.getElementById('userMenuIcon');
            var dockIcon = document.getElementById('dockUserIcon');
            if (origIcon && dockIcon) {
                dockIcon.src = origIcon.src;
                // Watch for icon source changes
                var iconObserver = new MutationObserver(function() {
                    dockIcon.src = origIcon.src;
                });
                iconObserver.observe(origIcon, { attributes: true, attributeFilter: ['src'] });
            }
        }

        // Close panels on click outside
        document.addEventListener('click', function(e) {
            if (!activeDockPanel) return;
            var dock = document.getElementById('glassDock');
            var panels = document.querySelectorAll('.dock-panel.show, .dock-panel.active');
            var clickedInsideDock = dock && dock.contains(e.target);
            var clickedInsidePanel = false;
            panels.forEach(function(p) {
                if (p.contains(e.target)) clickedInsidePanel = true;
            });
            if (!clickedInsideDock && !clickedInsidePanel) {
                closeAllDockPanels();
            }
        });

        // Escape key closes panels
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && activeDockPanel) {
                closeAllDockPanels();
            }
        });

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initDock);
        } else {
            initDock();
        }
    })();
    // ============= END LIQUID GLASS DOCK CONTROLLER =============
    </script>

</body>
</html>